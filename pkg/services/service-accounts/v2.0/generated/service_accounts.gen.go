// Package serviceaccounts provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/do87/oapi-codegen version v0.5.1 DO NOT EDIT.
package serviceaccounts

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/pkg/errors"

	common "github.com/SchwarzIT/community-stackit-go-client/internal/common"
	"github.com/SchwarzIT/community-stackit-go-client/pkg/validate"
	"github.com/do87/oapi-codegen/pkg/runtime"
	openapi_types "github.com/do87/oapi-codegen/pkg/types"
)

const (
	AuthorizationScopes = "Authorization.Scopes"
)

// Defines values for ServiceAccountKeyListResponseKeyAlgorithm.
const (
	SERVICE_ACCOUNT_KEY_LIST_RESPONSE_KEY_ALGORITHM_RSA_2048 ServiceAccountKeyListResponseKeyAlgorithm = "RSA_2048"
)

// Defines values for ServiceAccountKeyListResponseKeyOrigin.
const (
	SERVICE_ACCOUNT_KEY_LIST_RESPONSE_KEY_ORIGIN_GENERATED     ServiceAccountKeyListResponseKeyOrigin = "GENERATED"
	SERVICE_ACCOUNT_KEY_LIST_RESPONSE_KEY_ORIGIN_USER_PROVIDED ServiceAccountKeyListResponseKeyOrigin = "USER_PROVIDED"
)

// Defines values for ServiceAccountKeyListResponseKeyType.
const (
	SERVICE_ACCOUNT_KEY_LIST_RESPONSE_KEY_TYPE_SYSTEM_MANAGED ServiceAccountKeyListResponseKeyType = "SYSTEM_MANAGED"
	SERVICE_ACCOUNT_KEY_LIST_RESPONSE_KEY_TYPE_USER_MANAGED   ServiceAccountKeyListResponseKeyType = "USER_MANAGED"
)

// Defines values for ServiceAccountKeyPatchResponseKeyAlgorithm.
const (
	SERVICE_ACCOUNT_KEY_PATCH_RESPONSE_KEY_ALGORITHM_RSA_2048 ServiceAccountKeyPatchResponseKeyAlgorithm = "RSA_2048"
)

// Defines values for ServiceAccountKeyPatchResponseKeyOrigin.
const (
	SERVICE_ACCOUNT_KEY_PATCH_RESPONSE_KEY_ORIGIN_GENERATED     ServiceAccountKeyPatchResponseKeyOrigin = "GENERATED"
	SERVICE_ACCOUNT_KEY_PATCH_RESPONSE_KEY_ORIGIN_USER_PROVIDED ServiceAccountKeyPatchResponseKeyOrigin = "USER_PROVIDED"
)

// Defines values for ServiceAccountKeyPatchResponseKeyType.
const (
	SERVICE_ACCOUNT_KEY_PATCH_RESPONSE_KEY_TYPE_SYSTEM_MANAGED ServiceAccountKeyPatchResponseKeyType = "SYSTEM_MANAGED"
	SERVICE_ACCOUNT_KEY_PATCH_RESPONSE_KEY_TYPE_USER_MANAGED   ServiceAccountKeyPatchResponseKeyType = "USER_MANAGED"
)

// Defines values for ServiceAccountKeyPrivateResponseKeyAlgorithm.
const (
	SERVICE_ACCOUNT_KEY_PRIVATE_RESPONSE_KEY_ALGORITHM_RSA_2048 ServiceAccountKeyPrivateResponseKeyAlgorithm = "RSA_2048"
)

// Defines values for ServiceAccountKeyPrivateResponseKeyOrigin.
const (
	SERVICE_ACCOUNT_KEY_PRIVATE_RESPONSE_KEY_ORIGIN_GENERATED     ServiceAccountKeyPrivateResponseKeyOrigin = "GENERATED"
	SERVICE_ACCOUNT_KEY_PRIVATE_RESPONSE_KEY_ORIGIN_USER_PROVIDED ServiceAccountKeyPrivateResponseKeyOrigin = "USER_PROVIDED"
)

// Defines values for ServiceAccountKeyPrivateResponseKeyType.
const (
	SERVICE_ACCOUNT_KEY_PRIVATE_RESPONSE_KEY_TYPE_SYSTEM_MANAGED ServiceAccountKeyPrivateResponseKeyType = "SYSTEM_MANAGED"
	SERVICE_ACCOUNT_KEY_PRIVATE_RESPONSE_KEY_TYPE_USER_MANAGED   ServiceAccountKeyPrivateResponseKeyType = "USER_MANAGED"
)

// Defines values for ServiceAccountKeyResponseWithKeyKeyAlgorithm.
const (
	SERVICE_ACCOUNT_KEY_RESPONSE_WITH_KEY_KEY_ALGORITHM_RSA_2048 ServiceAccountKeyResponseWithKeyKeyAlgorithm = "RSA_2048"
)

// Defines values for ServiceAccountKeyResponseWithKeyKeyOrigin.
const (
	SERVICE_ACCOUNT_KEY_RESPONSE_WITH_KEY_KEY_ORIGIN_GENERATED     ServiceAccountKeyResponseWithKeyKeyOrigin = "GENERATED"
	SERVICE_ACCOUNT_KEY_RESPONSE_WITH_KEY_KEY_ORIGIN_USER_PROVIDED ServiceAccountKeyResponseWithKeyKeyOrigin = "USER_PROVIDED"
)

// Defines values for ServiceAccountKeyResponseWithKeyKeyType.
const (
	SERVICE_ACCOUNT_KEY_RESPONSE_WITH_KEY_KEY_TYPE_SYSTEM_MANAGED ServiceAccountKeyResponseWithKeyKeyType = "SYSTEM_MANAGED"
	SERVICE_ACCOUNT_KEY_RESPONSE_WITH_KEY_KEY_TYPE_USER_MANAGED   ServiceAccountKeyResponseWithKeyKeyType = "USER_MANAGED"
)

// Defines values for TokenRequestBodyGrantType.
const (
	REFRESH_TOKEN                               TokenRequestBodyGrantType = "refresh_token"
	URN_IETF_PARAMS_OAUTH_GRANT_TYPE_JWT_BEARER TokenRequestBodyGrantType = "urn:ietf:params:oauth:grant-type:jwt-bearer"
)

// Defines values for TokenResponseBodyTokenType.
const (
	BEARER TokenResponseBodyTokenType = "Bearer"
)

// Defines values for GetKeyParamsFormat.
const (
	X509_PEM GetKeyParamsFormat = "X509_PEM"
)

// AccessTokenMetadataV2 Does not contain the actual token.
type AccessTokenMetadataV2 struct {
	// Active If true, access token can be used for authorized API calls, if false, the token is not usable anymore.
	Active bool `json:"active"`

	// CreatedAt Creation time of the access token.
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique ID of the access token. Also used as JTI field.
	ID openapi_types.UUID `json:"id"`

	// ValidUntil Approximate expiration time of the access token. Check the JWT for actual validity date.
	ValidUntil time.Time `json:"validUntil"`
}

// AccessTokenV2 Contains token metadata and actual token.
type AccessTokenV2 struct {
	// Active Newly created access tokens are valid, and can be revoked if needed.
	Active bool `json:"active"`

	// CreatedAt Creation time of the access token.
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique ID of the access token. Also used as JTI field.
	ID openapi_types.UUID `json:"id"`

	// Token The access token in JWT format. Use this with `Bearer` prefix for API calls. Store it, as it is not recoverable later.
	Token string `json:"token"`

	// ValidUntil Approximate expiration time of the access token. Check the JWT for actual validity date.
	ValidUntil time.Time `json:"validUntil"`
}

// AuthError defines model for AuthError.
type AuthError struct {
	Error struct {
		Code    int    `json:"code"`
		Message string `json:"message"`
		Status  string `json:"status"`
	} `json:"error"`
}

// CreateAccessTokenRequestBody defines model for CreateAccessTokenRequestBody.
type CreateAccessTokenRequestBody struct {
	// TtlDays The duration in days for how long the new Access Token should be valid.
	TtlDays int `json:"ttlDays"`
}

// CreateServiceAccountRequestBodyV2 defines model for CreateServiceAccountRequestBodyV2.
type CreateServiceAccountRequestBodyV2 struct {
	// Name The requested name of the service account. The service will generate a unique email from this name.
	Name string `json:"name"`
}

// Error Contains error information.
type Error struct {
	Error     string    `json:"error"`
	Message   string    `json:"message"`
	Path      string    `json:"path"`
	Status    int       `json:"status"`
	TimeStamp time.Time `json:"timeStamp"`
}

// GetAccessTokensResponseBodyV2 defines model for GetAccessTokensResponseBodyV2.
type GetAccessTokensResponseBodyV2 struct {
	Items *[]AccessTokenMetadataV2 `json:"items,omitempty"`
}

// GetJWKResponseBody defines model for GetJWKResponseBody.
type GetJWKResponseBody struct {
	Keys []JsonWebKey `json:"keys"`
}

// GetServiceAccountsKeysResponseBody defines model for GetServiceAccountsKeysResponseBody.
type GetServiceAccountsKeysResponseBody struct {
	Items []ServiceAccountKeyListResponse `json:"items"`
}

// GetServiceAccountsResponseBodyV2 defines model for GetServiceAccountsResponseBodyV2.
type GetServiceAccountsResponseBodyV2 struct {
	Items []ServiceAccountV2 `json:"items"`
}

// JsonWebKey JSON Web Key according to https://datatracker.ietf.org/doc/html/rfc7517#section-4
type JsonWebKey struct {
	Alg    *string `json:"alg,omitempty"`
	E      string  `json:"e"`
	Kid    *string `json:"kid,omitempty"`
	Ks     *string `json:"ks,omitempty"`
	N      string  `json:"n"`
	Ops    *string `json:"ops,omitempty"`
	Use    *string `json:"use,omitempty"`
	X5c    *string `json:"x5c,omitempty"`
	X5t    *string `json:"x5t,omitempty"`
	X5t256 *string `json:"x5t256,omitempty"`
	X5u    *string `json:"x5u,omitempty"`
}

// ServiceAccountKeyListResponse defines model for ServiceAccountKeyListResponse.
type ServiceAccountKeyListResponse struct {
	Active bool `json:"active"`

	// CreatedAt Creation time of the key
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique ID of the key.
	ID           openapi_types.UUID                        `json:"id"`
	KeyAlgorithm ServiceAccountKeyListResponseKeyAlgorithm `json:"keyAlgorithm"`
	KeyOrigin    ServiceAccountKeyListResponseKeyOrigin    `json:"keyOrigin"`
	KeyType      ServiceAccountKeyListResponseKeyType      `json:"keyType"`

	// ValidUntil If specified, the timestamp until the key is active. May be null
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// ServiceAccountKeyListResponseKeyAlgorithm defines model for ServiceAccountKeyListResponse.KeyAlgorithm.
type ServiceAccountKeyListResponseKeyAlgorithm string

// ServiceAccountKeyListResponseKeyOrigin defines model for ServiceAccountKeyListResponse.KeyOrigin.
type ServiceAccountKeyListResponseKeyOrigin string

// ServiceAccountKeyListResponseKeyType defines model for ServiceAccountKeyListResponse.KeyType.
type ServiceAccountKeyListResponseKeyType string

// ServiceAccountKeyPatchResponse defines model for ServiceAccountKeyPatchResponse.
type ServiceAccountKeyPatchResponse struct {
	Active bool `json:"active"`

	// CreatedAt Creation time of the key
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique ID of the key.
	ID           openapi_types.UUID                         `json:"id"`
	KeyAlgorithm ServiceAccountKeyPatchResponseKeyAlgorithm `json:"keyAlgorithm"`
	KeyOrigin    ServiceAccountKeyPatchResponseKeyOrigin    `json:"keyOrigin"`
	KeyType      ServiceAccountKeyPatchResponseKeyType      `json:"keyType"`

	// ValidUntil If specified, the timestamp until the key is active. May be null
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// ServiceAccountKeyPatchResponseKeyAlgorithm defines model for ServiceAccountKeyPatchResponse.KeyAlgorithm.
type ServiceAccountKeyPatchResponseKeyAlgorithm string

// ServiceAccountKeyPatchResponseKeyOrigin defines model for ServiceAccountKeyPatchResponse.KeyOrigin.
type ServiceAccountKeyPatchResponseKeyOrigin string

// ServiceAccountKeyPatchResponseKeyType defines model for ServiceAccountKeyPatchResponse.KeyType.
type ServiceAccountKeyPatchResponseKeyType string

// ServiceAccountKeyPrivateResponse defines model for ServiceAccountKeyPrivateResponse.
type ServiceAccountKeyPrivateResponse struct {
	Active bool `json:"active"`

	// CreatedAt Creation time of the key
	CreatedAt   time.Time `json:"createdAt"`
	Credentials struct {
		// Aud Audience - service account API URL
		Aud string `json:"aud"`

		// Iss Service account email
		Iss openapi_types.Email `json:"iss"`

		// Kid Key id to use
		Kid string `json:"kid"`

		// PrivateKey Private key. Only present, if the service account API was generating the key. Not recoverable later.
		PrivateKey *string `json:"privateKey,omitempty"`

		// Sub Service account id
		Sub openapi_types.UUID `json:"sub"`
	} `json:"credentials"`

	// Id Unique ID of the key.
	ID           openapi_types.UUID                           `json:"id"`
	KeyAlgorithm ServiceAccountKeyPrivateResponseKeyAlgorithm `json:"keyAlgorithm"`
	KeyOrigin    ServiceAccountKeyPrivateResponseKeyOrigin    `json:"keyOrigin"`
	KeyType      ServiceAccountKeyPrivateResponseKeyType      `json:"keyType"`

	// PublicKey Public key, that was provider, or was generated by the service account API
	PublicKey string `json:"publicKey"`

	// ValidUntil If specified, the timestamp until the key is active. May be null
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// ServiceAccountKeyPrivateResponseKeyAlgorithm defines model for ServiceAccountKeyPrivateResponse.KeyAlgorithm.
type ServiceAccountKeyPrivateResponseKeyAlgorithm string

// ServiceAccountKeyPrivateResponseKeyOrigin defines model for ServiceAccountKeyPrivateResponse.KeyOrigin.
type ServiceAccountKeyPrivateResponseKeyOrigin string

// ServiceAccountKeyPrivateResponseKeyType defines model for ServiceAccountKeyPrivateResponse.KeyType.
type ServiceAccountKeyPrivateResponseKeyType string

// ServiceAccountKeyRequest defines model for ServiceAccountKeyRequest.
type ServiceAccountKeyRequest struct {
	// PublicKey Optional, public key part of the user generated RSA key-pair wrapped in a [X.509 v3 certificate](https://www.rfc-editor.org/rfc/rfc5280)
	PublicKey *string `json:"publicKey,omitempty"`

	// ValidUntil Optional, date of key expiration. When omitted, key is valid until deleted
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// ServiceAccountKeyResponseWithKey defines model for ServiceAccountKeyResponseWithKey.
type ServiceAccountKeyResponseWithKey struct {
	Active bool `json:"active"`

	// CreatedAt Creation time of the key
	CreatedAt   time.Time `json:"createdAt"`
	Credentials struct {
		// Aud Audience - service account API URL
		Aud string `json:"aud"`

		// Iss Service account email
		Iss openapi_types.Email `json:"iss"`

		// Kid Key id to use
		Kid string `json:"kid"`

		// Sub Service account id
		Sub openapi_types.UUID `json:"sub"`
	} `json:"credentials"`

	// Id Unique ID of the key.
	ID           openapi_types.UUID                           `json:"id"`
	KeyAlgorithm ServiceAccountKeyResponseWithKeyKeyAlgorithm `json:"keyAlgorithm"`
	KeyOrigin    ServiceAccountKeyResponseWithKeyKeyOrigin    `json:"keyOrigin"`
	KeyType      ServiceAccountKeyResponseWithKeyKeyType      `json:"keyType"`

	// PublicKey Public key, in the requested format
	PublicKey *string `json:"publicKey,omitempty"`

	// ValidUntil If specified, the timestamp until the key is active. May be null
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// ServiceAccountKeyResponseWithKeyKeyAlgorithm defines model for ServiceAccountKeyResponseWithKey.KeyAlgorithm.
type ServiceAccountKeyResponseWithKeyKeyAlgorithm string

// ServiceAccountKeyResponseWithKeyKeyOrigin defines model for ServiceAccountKeyResponseWithKey.KeyOrigin.
type ServiceAccountKeyResponseWithKeyKeyOrigin string

// ServiceAccountKeyResponseWithKeyKeyType defines model for ServiceAccountKeyResponseWithKey.KeyType.
type ServiceAccountKeyResponseWithKeyKeyType string

// ServiceAccountKeyUpdateRequest defines model for ServiceAccountKeyUpdateRequest.
type ServiceAccountKeyUpdateRequest struct {
	// Active Active keys are valid, while inactive keys are temporarily deactivated.
	Active *bool `json:"active,omitempty"`

	// ValidUntil Optional, date of key expiration. When omitted, key is valid until deleted
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// ServiceAccountV2 defines model for ServiceAccountV2.
type ServiceAccountV2 struct {
	// Email Unique identifier of the service account in format of an email address generated by the service containing the prefix provided by the user during creation.
	Email openapi_types.Email `json:"email"`

	// Id Unique ID of the service account. It is also used in the 'sub' field of the service accounts access tokens.
	ID openapi_types.UUID `json:"id"`

	// ProjectId ID of the related project
	ProjectID string `json:"projectId"`
}

// TokenRequestBody defines model for TokenRequestBody.
type TokenRequestBody struct {
	// Assertion The self signed JWT. Must be given when grant_type is urn:ietf:params:oauth:grant-type:jwt-bearer
	Assertion *string `json:"assertion,omitempty"`

	// GrantType Always use URL encoded values. E.g. urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer
	GrantType TokenRequestBodyGrantType `json:"grant_type"`

	// RefreshToken Refresh token provided by a previous call with a self signed token. Must be given when grant_type is refresh_token
	RefreshToken *string `json:"refresh_token,omitempty"`
}

// TokenRequestBodyGrantType Always use URL encoded values. E.g. urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer
type TokenRequestBodyGrantType string

// TokenResponseBody defines model for TokenResponseBody.
type TokenResponseBody struct {
	// AccessToken The short lived token that can be used for API access
	AccessToken string `json:"access_token"`
	ExpiresIn   int    `json:"expires_in"`

	// RefreshToken Refresh token that can be used to request a new access token when it expires (and before refresh token expires). Tokens are rotated.
	RefreshToken string `json:"refresh_token"`

	// Scope scope field of the self signed token
	Scope     string                     `json:"scope"`
	TokenType TokenResponseBodyTokenType `json:"token_type"`
}

// TokenResponseBodyTokenType defines model for TokenResponseBody.TokenType.
type TokenResponseBodyTokenType string

// GetKeyParams defines parameters for GetKey.
type GetKeyParams struct {
	// Format Requested format for the public key
	Format *GetKeyParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetKeyParamsFormat defines parameters for GetKey.
type GetKeyParamsFormat string

// CreateTokenFormdataRequestBody defines body for CreateToken for application/x-www-form-urlencoded ContentType.
type CreateTokenFormdataRequestBody = TokenRequestBody

// CreateV2JSONRequestBody defines body for CreateV2 for application/json ContentType.
type CreateV2JSONRequestBody = CreateServiceAccountRequestBodyV2

// CreateServiceAccountIDAccessTokensV2JSONRequestBody defines body for CreateServiceAccountIDAccessTokensV2 for application/json ContentType.
type CreateServiceAccountIDAccessTokensV2JSONRequestBody = CreateAccessTokenRequestBody

// CreateKeysJSONRequestBody defines body for CreateKeys for application/json ContentType.
type CreateKeysJSONRequestBody = ServiceAccountKeyRequest

// UpdateKeysJSONRequestBody defines body for UpdateKeys for application/json ContentType.
type UpdateKeysJSONRequestBody = ServiceAccountKeyUpdateRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client common.Client
}

// Creates a new Client, with reasonable defaults
func NewClient(server string, httpClient common.Client) *Client {
	// create a client with sane default values
	client := Client{
		Server: server,
		Client: httpClient,
	}
	return &client
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateToken request with any body
	CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTokenWithFormdataBody(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetV2 request
	GetV2(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateV2 request with any body
	CreateV2WithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateV2(ctx context.Context, projectId string, body CreateV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceAccountIDV2 request
	DeleteServiceAccountIDV2(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceAccountIDAccessTokensV2 request
	GetServiceAccountIDAccessTokensV2(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceAccountIDAccessTokensV2 request with any body
	CreateServiceAccountIDAccessTokensV2WithBody(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServiceAccountIDAccessTokensV2(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, body CreateServiceAccountIDAccessTokensV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceAccountIDAccessTokensAccessTokenIDV2 request
	DeleteServiceAccountIDAccessTokensAccessTokenIDV2(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, accessTokenId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceAccountJwks request
	GetServiceAccountJwks(ctx context.Context, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeys request
	GetKeys(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeys request with any body
	CreateKeysWithBody(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeys(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, body CreateKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKeys request
	DeleteKeys(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKey request
	GetKey(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, params *GetKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateKeys request with any body
	UpdateKeysWithBody(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateKeys(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, body UpdateKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(ctx, c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithFormdataBody(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithFormdataBody(ctx, c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetV2(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetV2Request(ctx, c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateV2WithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateV2RequestWithBody(ctx, c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateV2(ctx context.Context, projectId string, body CreateV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateV2Request(ctx, c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceAccountIDV2(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceAccountIDV2Request(ctx, c.Server, projectId, serviceAccountEmail)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceAccountIDAccessTokensV2(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceAccountIDAccessTokensV2Request(ctx, c.Server, projectId, serviceAccountEmail)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountIDAccessTokensV2WithBody(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountIDAccessTokensV2RequestWithBody(ctx, c.Server, projectId, serviceAccountEmail, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountIDAccessTokensV2(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, body CreateServiceAccountIDAccessTokensV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountIDAccessTokensV2Request(ctx, c.Server, projectId, serviceAccountEmail, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceAccountIDAccessTokensAccessTokenIDV2(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, accessTokenId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceAccountIDAccessTokensAccessTokenIDV2Request(ctx, c.Server, projectId, serviceAccountEmail, accessTokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceAccountJwks(ctx context.Context, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceAccountJwksRequest(ctx, c.Server, serviceAccountEmail)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeys(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeysRequest(ctx, c.Server, projectId, serviceAccountEmail)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeysWithBody(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeysRequestWithBody(ctx, c.Server, projectId, serviceAccountEmail, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeys(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, body CreateKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeysRequest(ctx, c.Server, projectId, serviceAccountEmail, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKeys(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeysRequest(ctx, c.Server, projectId, serviceAccountEmail, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKey(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, params *GetKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeyRequest(ctx, c.Server, projectId, serviceAccountEmail, keyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeysWithBody(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeysRequestWithBody(ctx, c.Server, projectId, serviceAccountEmail, keyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeys(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, body UpdateKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeysRequest(ctx, c.Server, projectId, serviceAccountEmail, keyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateTokenRequestWithFormdataBody calls the generic CreateToken builder with application/x-www-form-urlencoded body
func NewCreateTokenRequestWithFormdataBody(ctx context.Context, server string, body CreateTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCreateTokenRequestWithBody(ctx, server, "application/x-www-form-urlencoded", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(ctx context.Context, server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetV2Request generates requests for GetV2
func NewGetV2Request(ctx context.Context, server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/service-accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateV2Request calls the generic CreateV2 builder with application/json body
func NewCreateV2Request(ctx context.Context, server string, projectId string, body CreateV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateV2RequestWithBody(ctx, server, projectId, "application/json", bodyReader)
}

// NewCreateV2RequestWithBody generates requests for CreateV2 with any type of body
func NewCreateV2RequestWithBody(ctx context.Context, server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/service-accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceAccountIDV2Request generates requests for DeleteServiceAccountIDV2
func NewDeleteServiceAccountIDV2Request(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/service-accounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceAccountIDAccessTokensV2Request generates requests for GetServiceAccountIDAccessTokensV2
func NewGetServiceAccountIDAccessTokensV2Request(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/service-accounts/%s/access-tokens", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServiceAccountIDAccessTokensV2Request calls the generic CreateServiceAccountIDAccessTokensV2 builder with application/json body
func NewCreateServiceAccountIDAccessTokensV2Request(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email, body CreateServiceAccountIDAccessTokensV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceAccountIDAccessTokensV2RequestWithBody(ctx, server, projectId, serviceAccountEmail, "application/json", bodyReader)
}

// NewCreateServiceAccountIDAccessTokensV2RequestWithBody generates requests for CreateServiceAccountIDAccessTokensV2 with any type of body
func NewCreateServiceAccountIDAccessTokensV2RequestWithBody(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/service-accounts/%s/access-tokens", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceAccountIDAccessTokensAccessTokenIDV2Request generates requests for DeleteServiceAccountIDAccessTokensAccessTokenIDV2
func NewDeleteServiceAccountIDAccessTokensAccessTokenIDV2Request(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email, accessTokenId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "accessTokenId", runtime.ParamLocationPath, accessTokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/service-accounts/%s/access-tokens/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceAccountJwksRequest generates requests for GetServiceAccountJwks
func NewGetServiceAccountJwksRequest(ctx context.Context, server string, serviceAccountEmail openapi_types.Email) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/service-accounts/public/jwk/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeysRequest generates requests for GetKeys
func NewGetKeysRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2alpha1/projects/%s/service-accounts/%s/keys", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeysRequest calls the generic CreateKeys builder with application/json body
func NewCreateKeysRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email, body CreateKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeysRequestWithBody(ctx, server, projectId, serviceAccountEmail, "application/json", bodyReader)
}

// NewCreateKeysRequestWithBody generates requests for CreateKeys with any type of body
func NewCreateKeysRequestWithBody(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2alpha1/projects/%s/service-accounts/%s/keys", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeysRequest generates requests for DeleteKeys
func NewDeleteKeysRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2alpha1/projects/%s/service-accounts/%s/keys/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeyRequest generates requests for GetKey
func NewGetKeyRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, params *GetKeyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2alpha1/projects/%s/service-accounts/%s/keys/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Format != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateKeysRequest calls the generic UpdateKeys builder with application/json body
func NewUpdateKeysRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, body UpdateKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateKeysRequestWithBody(ctx, server, projectId, serviceAccountEmail, keyId, "application/json", bodyReader)
}

// NewUpdateKeysRequestWithBody generates requests for UpdateKeys with any type of body
func NewUpdateKeysRequestWithBody(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2alpha1/projects/%s/service-accounts/%s/keys/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, httpClient common.Client) *ClientWithResponses {
	return &ClientWithResponses{NewClient(server, httpClient)}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateToken request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithFormdataBodyWithResponse(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// GetV2 request
	GetV2WithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*GetV2Response, error)

	// CreateV2 request with any body
	CreateV2WithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateV2Response, error)

	CreateV2WithResponse(ctx context.Context, projectId string, body CreateV2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateV2Response, error)

	// DeleteServiceAccountIDV2 request
	DeleteServiceAccountIDV2WithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*DeleteServiceAccountIDV2Response, error)

	// GetServiceAccountIDAccessTokensV2 request
	GetServiceAccountIDAccessTokensV2WithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*GetServiceAccountIDAccessTokensV2Response, error)

	// CreateServiceAccountIDAccessTokensV2 request with any body
	CreateServiceAccountIDAccessTokensV2WithBodyWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountIDAccessTokensV2Response, error)

	CreateServiceAccountIDAccessTokensV2WithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, body CreateServiceAccountIDAccessTokensV2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountIDAccessTokensV2Response, error)

	// DeleteServiceAccountIDAccessTokensAccessTokenIDV2 request
	DeleteServiceAccountIDAccessTokensAccessTokenIDV2WithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, accessTokenId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteServiceAccountIDAccessTokensAccessTokenIDV2Response, error)

	// GetServiceAccountJwks request
	GetServiceAccountJwksWithResponse(ctx context.Context, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*GetServiceAccountJwksResponse, error)

	// GetKeys request
	GetKeysWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*GetKeysResponse, error)

	// CreateKeys request with any body
	CreateKeysWithBodyWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeysResponse, error)

	CreateKeysWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, body CreateKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeysResponse, error)

	// DeleteKeys request
	DeleteKeysWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteKeysResponse, error)

	// GetKey request
	GetKeyWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, params *GetKeyParams, reqEditors ...RequestEditorFn) (*GetKeyResponse, error)

	// UpdateKeys request with any body
	UpdateKeysWithBodyWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeysResponse, error)

	UpdateKeysWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, body UpdateKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeysResponse, error)
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponseBody
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetServiceAccountsResponseBodyV2
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *AuthError
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServiceAccountV2
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON409      *Error
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r CreateV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceAccountIDV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON404      *Error
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r DeleteServiceAccountIDV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceAccountIDV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceAccountIDAccessTokensV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAccessTokensResponseBodyV2
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON404      *Error
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetServiceAccountIDAccessTokensV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceAccountIDAccessTokensV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceAccountIDAccessTokensV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AccessTokenV2
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON404      *Error
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r CreateServiceAccountIDAccessTokensV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceAccountIDAccessTokensV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceAccountIDAccessTokensAccessTokenIDV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r DeleteServiceAccountIDAccessTokensAccessTokenIDV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceAccountIDAccessTokensAccessTokenIDV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceAccountJwksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetJWKResponseBody
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetServiceAccountJwksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceAccountJwksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetServiceAccountsKeysResponseBody
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *AuthError
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServiceAccountKeyPrivateResponse
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON409      *Error
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r CreateKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *AuthError
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r DeleteKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccountKeyResponseWithKey
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *AuthError
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServiceAccountKeyPatchResponse
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON409      *Error
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r UpdateKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithFormdataBodyWithResponse(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateTokenResponse(rsp)
}

// GetV2WithResponse request returning *GetV2Response
func (c *ClientWithResponses) GetV2WithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*GetV2Response, error) {
	rsp, err := c.GetV2(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetV2Response(rsp)
}

// CreateV2WithBodyWithResponse request with arbitrary body returning *CreateV2Response
func (c *ClientWithResponses) CreateV2WithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateV2Response, error) {
	rsp, err := c.CreateV2WithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateV2Response(rsp)
}

func (c *ClientWithResponses) CreateV2WithResponse(ctx context.Context, projectId string, body CreateV2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateV2Response, error) {
	rsp, err := c.CreateV2(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateV2Response(rsp)
}

// DeleteServiceAccountIDV2WithResponse request returning *DeleteServiceAccountIDV2Response
func (c *ClientWithResponses) DeleteServiceAccountIDV2WithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*DeleteServiceAccountIDV2Response, error) {
	rsp, err := c.DeleteServiceAccountIDV2(ctx, projectId, serviceAccountEmail, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseDeleteServiceAccountIDV2Response(rsp)
}

// GetServiceAccountIDAccessTokensV2WithResponse request returning *GetServiceAccountIDAccessTokensV2Response
func (c *ClientWithResponses) GetServiceAccountIDAccessTokensV2WithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*GetServiceAccountIDAccessTokensV2Response, error) {
	rsp, err := c.GetServiceAccountIDAccessTokensV2(ctx, projectId, serviceAccountEmail, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetServiceAccountIDAccessTokensV2Response(rsp)
}

// CreateServiceAccountIDAccessTokensV2WithBodyWithResponse request with arbitrary body returning *CreateServiceAccountIDAccessTokensV2Response
func (c *ClientWithResponses) CreateServiceAccountIDAccessTokensV2WithBodyWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountIDAccessTokensV2Response, error) {
	rsp, err := c.CreateServiceAccountIDAccessTokensV2WithBody(ctx, projectId, serviceAccountEmail, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateServiceAccountIDAccessTokensV2Response(rsp)
}

func (c *ClientWithResponses) CreateServiceAccountIDAccessTokensV2WithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, body CreateServiceAccountIDAccessTokensV2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountIDAccessTokensV2Response, error) {
	rsp, err := c.CreateServiceAccountIDAccessTokensV2(ctx, projectId, serviceAccountEmail, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateServiceAccountIDAccessTokensV2Response(rsp)
}

// DeleteServiceAccountIDAccessTokensAccessTokenIDV2WithResponse request returning *DeleteServiceAccountIDAccessTokensAccessTokenIDV2Response
func (c *ClientWithResponses) DeleteServiceAccountIDAccessTokensAccessTokenIDV2WithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, accessTokenId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteServiceAccountIDAccessTokensAccessTokenIDV2Response, error) {
	rsp, err := c.DeleteServiceAccountIDAccessTokensAccessTokenIDV2(ctx, projectId, serviceAccountEmail, accessTokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseDeleteServiceAccountIDAccessTokensAccessTokenIDV2Response(rsp)
}

// GetServiceAccountJwksWithResponse request returning *GetServiceAccountJwksResponse
func (c *ClientWithResponses) GetServiceAccountJwksWithResponse(ctx context.Context, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*GetServiceAccountJwksResponse, error) {
	rsp, err := c.GetServiceAccountJwks(ctx, serviceAccountEmail, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetServiceAccountJwksResponse(rsp)
}

// GetKeysWithResponse request returning *GetKeysResponse
func (c *ClientWithResponses) GetKeysWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*GetKeysResponse, error) {
	rsp, err := c.GetKeys(ctx, projectId, serviceAccountEmail, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetKeysResponse(rsp)
}

// CreateKeysWithBodyWithResponse request with arbitrary body returning *CreateKeysResponse
func (c *ClientWithResponses) CreateKeysWithBodyWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeysResponse, error) {
	rsp, err := c.CreateKeysWithBody(ctx, projectId, serviceAccountEmail, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateKeysResponse(rsp)
}

func (c *ClientWithResponses) CreateKeysWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, body CreateKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeysResponse, error) {
	rsp, err := c.CreateKeys(ctx, projectId, serviceAccountEmail, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateKeysResponse(rsp)
}

// DeleteKeysWithResponse request returning *DeleteKeysResponse
func (c *ClientWithResponses) DeleteKeysWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteKeysResponse, error) {
	rsp, err := c.DeleteKeys(ctx, projectId, serviceAccountEmail, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseDeleteKeysResponse(rsp)
}

// GetKeyWithResponse request returning *GetKeyResponse
func (c *ClientWithResponses) GetKeyWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, params *GetKeyParams, reqEditors ...RequestEditorFn) (*GetKeyResponse, error) {
	rsp, err := c.GetKey(ctx, projectId, serviceAccountEmail, keyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetKeyResponse(rsp)
}

// UpdateKeysWithBodyWithResponse request with arbitrary body returning *UpdateKeysResponse
func (c *ClientWithResponses) UpdateKeysWithBodyWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeysResponse, error) {
	rsp, err := c.UpdateKeysWithBody(ctx, projectId, serviceAccountEmail, keyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseUpdateKeysResponse(rsp)
}

func (c *ClientWithResponses) UpdateKeysWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, body UpdateKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeysResponse, error) {
	rsp, err := c.UpdateKeys(ctx, projectId, serviceAccountEmail, keyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseUpdateKeysResponse(rsp)
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func (c *ClientWithResponses) ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetV2Response parses an HTTP response from a GetV2WithResponse call
func (c *ClientWithResponses) ParseGetV2Response(rsp *http.Response) (*GetV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetServiceAccountsResponseBodyV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateV2Response parses an HTTP response from a CreateV2WithResponse call
func (c *ClientWithResponses) ParseCreateV2Response(rsp *http.Response) (*CreateV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServiceAccountV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteServiceAccountIDV2Response parses an HTTP response from a DeleteServiceAccountIDV2WithResponse call
func (c *ClientWithResponses) ParseDeleteServiceAccountIDV2Response(rsp *http.Response) (*DeleteServiceAccountIDV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceAccountIDV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetServiceAccountIDAccessTokensV2Response parses an HTTP response from a GetServiceAccountIDAccessTokensV2WithResponse call
func (c *ClientWithResponses) ParseGetServiceAccountIDAccessTokensV2Response(rsp *http.Response) (*GetServiceAccountIDAccessTokensV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceAccountIDAccessTokensV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAccessTokensResponseBodyV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateServiceAccountIDAccessTokensV2Response parses an HTTP response from a CreateServiceAccountIDAccessTokensV2WithResponse call
func (c *ClientWithResponses) ParseCreateServiceAccountIDAccessTokensV2Response(rsp *http.Response) (*CreateServiceAccountIDAccessTokensV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceAccountIDAccessTokensV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AccessTokenV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteServiceAccountIDAccessTokensAccessTokenIDV2Response parses an HTTP response from a DeleteServiceAccountIDAccessTokensAccessTokenIDV2WithResponse call
func (c *ClientWithResponses) ParseDeleteServiceAccountIDAccessTokensAccessTokenIDV2Response(rsp *http.Response) (*DeleteServiceAccountIDAccessTokensAccessTokenIDV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceAccountIDAccessTokensAccessTokenIDV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetServiceAccountJwksResponse parses an HTTP response from a GetServiceAccountJwksWithResponse call
func (c *ClientWithResponses) ParseGetServiceAccountJwksResponse(rsp *http.Response) (*GetServiceAccountJwksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceAccountJwksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetJWKResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetKeysResponse parses an HTTP response from a GetKeysWithResponse call
func (c *ClientWithResponses) ParseGetKeysResponse(rsp *http.Response) (*GetKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetServiceAccountsKeysResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateKeysResponse parses an HTTP response from a CreateKeysWithResponse call
func (c *ClientWithResponses) ParseCreateKeysResponse(rsp *http.Response) (*CreateKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServiceAccountKeyPrivateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteKeysResponse parses an HTTP response from a DeleteKeysWithResponse call
func (c *ClientWithResponses) ParseDeleteKeysResponse(rsp *http.Response) (*DeleteKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetKeyResponse parses an HTTP response from a GetKeyWithResponse call
func (c *ClientWithResponses) ParseGetKeyResponse(rsp *http.Response) (*GetKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccountKeyResponseWithKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdateKeysResponse parses an HTTP response from a UpdateKeysWithResponse call
func (c *ClientWithResponses) ParseUpdateKeysResponse(rsp *http.Response) (*UpdateKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServiceAccountKeyPatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON409 = &dest

	}

	return response, nil
}
