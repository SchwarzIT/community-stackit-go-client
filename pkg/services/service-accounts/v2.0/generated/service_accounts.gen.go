// Package serviceaccounts provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/do87/oapi-codegen version v0.5.1 DO NOT EDIT.
package serviceaccounts

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/pkg/errors"

	common "github.com/SchwarzIT/community-stackit-go-client/internal/common"
	"github.com/SchwarzIT/community-stackit-go-client/pkg/validate"
	"github.com/do87/oapi-codegen/pkg/runtime"
	openapi_types "github.com/do87/oapi-codegen/pkg/types"
)

const (
	AuthorizationScopes = "Authorization.Scopes"
)

// Defines values for ServiceAccountKeyListResponseKeyAlgorithm.
const (
	SERVICE_ACCOUNT_KEY_LIST_RESPONSE_KEY_ALGORITHM_RSA_2048 ServiceAccountKeyListResponseKeyAlgorithm = "RSA_2048"
)

// Defines values for ServiceAccountKeyListResponseKeyOrigin.
const (
	SERVICE_ACCOUNT_KEY_LIST_RESPONSE_KEY_ORIGIN_GENERATED     ServiceAccountKeyListResponseKeyOrigin = "GENERATED"
	SERVICE_ACCOUNT_KEY_LIST_RESPONSE_KEY_ORIGIN_USER_PROVIDED ServiceAccountKeyListResponseKeyOrigin = "USER_PROVIDED"
)

// Defines values for ServiceAccountKeyListResponseKeyType.
const (
	SERVICE_ACCOUNT_KEY_LIST_RESPONSE_KEY_TYPE_SYSTEM_MANAGED ServiceAccountKeyListResponseKeyType = "SYSTEM_MANAGED"
	SERVICE_ACCOUNT_KEY_LIST_RESPONSE_KEY_TYPE_USER_MANAGED   ServiceAccountKeyListResponseKeyType = "USER_MANAGED"
)

// Defines values for ServiceAccountKeyPatchResponseKeyAlgorithm.
const (
	SERVICE_ACCOUNT_KEY_PATCH_RESPONSE_KEY_ALGORITHM_RSA_2048 ServiceAccountKeyPatchResponseKeyAlgorithm = "RSA_2048"
)

// Defines values for ServiceAccountKeyPatchResponseKeyOrigin.
const (
	SERVICE_ACCOUNT_KEY_PATCH_RESPONSE_KEY_ORIGIN_GENERATED     ServiceAccountKeyPatchResponseKeyOrigin = "GENERATED"
	SERVICE_ACCOUNT_KEY_PATCH_RESPONSE_KEY_ORIGIN_USER_PROVIDED ServiceAccountKeyPatchResponseKeyOrigin = "USER_PROVIDED"
)

// Defines values for ServiceAccountKeyPatchResponseKeyType.
const (
	SERVICE_ACCOUNT_KEY_PATCH_RESPONSE_KEY_TYPE_SYSTEM_MANAGED ServiceAccountKeyPatchResponseKeyType = "SYSTEM_MANAGED"
	SERVICE_ACCOUNT_KEY_PATCH_RESPONSE_KEY_TYPE_USER_MANAGED   ServiceAccountKeyPatchResponseKeyType = "USER_MANAGED"
)

// Defines values for ServiceAccountKeyPrivateResponseKeyAlgorithm.
const (
	SERVICE_ACCOUNT_KEY_PRIVATE_RESPONSE_KEY_ALGORITHM_RSA_2048 ServiceAccountKeyPrivateResponseKeyAlgorithm = "RSA_2048"
)

// Defines values for ServiceAccountKeyPrivateResponseKeyOrigin.
const (
	SERVICE_ACCOUNT_KEY_PRIVATE_RESPONSE_KEY_ORIGIN_GENERATED     ServiceAccountKeyPrivateResponseKeyOrigin = "GENERATED"
	SERVICE_ACCOUNT_KEY_PRIVATE_RESPONSE_KEY_ORIGIN_USER_PROVIDED ServiceAccountKeyPrivateResponseKeyOrigin = "USER_PROVIDED"
)

// Defines values for ServiceAccountKeyPrivateResponseKeyType.
const (
	SERVICE_ACCOUNT_KEY_PRIVATE_RESPONSE_KEY_TYPE_SYSTEM_MANAGED ServiceAccountKeyPrivateResponseKeyType = "SYSTEM_MANAGED"
	SERVICE_ACCOUNT_KEY_PRIVATE_RESPONSE_KEY_TYPE_USER_MANAGED   ServiceAccountKeyPrivateResponseKeyType = "USER_MANAGED"
)

// Defines values for ServiceAccountKeyResponseWithKeyKeyAlgorithm.
const (
	SERVICE_ACCOUNT_KEY_RESPONSE_WITH_KEY_KEY_ALGORITHM_RSA_2048 ServiceAccountKeyResponseWithKeyKeyAlgorithm = "RSA_2048"
)

// Defines values for ServiceAccountKeyResponseWithKeyKeyOrigin.
const (
	SERVICE_ACCOUNT_KEY_RESPONSE_WITH_KEY_KEY_ORIGIN_GENERATED     ServiceAccountKeyResponseWithKeyKeyOrigin = "GENERATED"
	SERVICE_ACCOUNT_KEY_RESPONSE_WITH_KEY_KEY_ORIGIN_USER_PROVIDED ServiceAccountKeyResponseWithKeyKeyOrigin = "USER_PROVIDED"
)

// Defines values for ServiceAccountKeyResponseWithKeyKeyType.
const (
	SERVICE_ACCOUNT_KEY_RESPONSE_WITH_KEY_KEY_TYPE_SYSTEM_MANAGED ServiceAccountKeyResponseWithKeyKeyType = "SYSTEM_MANAGED"
	SERVICE_ACCOUNT_KEY_RESPONSE_WITH_KEY_KEY_TYPE_USER_MANAGED   ServiceAccountKeyResponseWithKeyKeyType = "USER_MANAGED"
)

// Defines values for TokenRequestBodyGrantType.
const (
	REFRESH_TOKEN                               TokenRequestBodyGrantType = "refresh_token"
	URN_IETF_PARAMS_OAUTH_GRANT_TYPE_JWT_BEARER TokenRequestBodyGrantType = "urn:ietf:params:oauth:grant-type:jwt-bearer"
)

// Defines values for TokenResponseBodyTokenType.
const (
	BEARER TokenResponseBodyTokenType = "Bearer"
)

// Defines values for GetSAKeysKeyIDParamsFormat.
const (
	X509_PEM GetSAKeysKeyIDParamsFormat = "X509_PEM"
)

// AccessTokenMetadataV2 Does not contain the actual token.
type AccessTokenMetadataV2 struct {
	// Active If true, access token can be used for authorized API calls, if false, the token is not usable anymore.
	Active bool `json:"active"`

	// CreatedAt Creation time of the access token.
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique ID of the access token. Also used as JTI field.
	ID openapi_types.UUID `json:"id"`

	// ValidUntil Approximate expiration time of the access token. Check the JWT for actual validity date.
	ValidUntil time.Time `json:"validUntil"`
}

// AccessTokenV2 Contains token metadata and actual token.
type AccessTokenV2 struct {
	// Active Newly created access tokens are valid, and can be revoked if needed.
	Active bool `json:"active"`

	// CreatedAt Creation time of the access token.
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique ID of the access token. Also used as JTI field.
	ID openapi_types.UUID `json:"id"`

	// Token The access token in JWT format. Use this with `Bearer` prefix for API calls. Store it, as it is not recoverable later.
	Token string `json:"token"`

	// ValidUntil Approximate expiration time of the access token. Check the JWT for actual validity date.
	ValidUntil time.Time `json:"validUntil"`
}

// AuthError defines model for AuthError.
type AuthError struct {
	Error struct {
		Code    int    `json:"code"`
		Message string `json:"message"`
		Status  string `json:"status"`
	} `json:"error"`
}

// CreateAccessTokenRequestBody defines model for CreateAccessTokenRequestBody.
type CreateAccessTokenRequestBody struct {
	// TtlDays The duration in days for how long the new Access Token should be valid.
	TtlDays int `json:"ttlDays"`
}

// CreateServiceAccountRequestBodyV2 defines model for CreateServiceAccountRequestBodyV2.
type CreateServiceAccountRequestBodyV2 struct {
	// Name The requested name of the service account. The service will generate a unique email from this name.
	Name string `json:"name"`
}

// Error Contains error information.
type Error struct {
	Error     string    `json:"error"`
	Message   string    `json:"message"`
	Path      string    `json:"path"`
	Status    int       `json:"status"`
	TimeStamp time.Time `json:"timeStamp"`
}

// GetAccessTokensResponseBodyV2 defines model for GetAccessTokensResponseBodyV2.
type GetAccessTokensResponseBodyV2 struct {
	Items *[]AccessTokenMetadataV2 `json:"items,omitempty"`
}

// GetJWKResponseBody defines model for GetJWKResponseBody.
type GetJWKResponseBody struct {
	Keys []JsonWebKey `json:"keys"`
}

// GetServiceAccountsKeysResponseBody defines model for GetServiceAccountsKeysResponseBody.
type GetServiceAccountsKeysResponseBody struct {
	Items []ServiceAccountKeyListResponse `json:"items"`
}

// GetServiceAccountsResponseBodyV2 defines model for GetServiceAccountsResponseBodyV2.
type GetServiceAccountsResponseBodyV2 struct {
	Items []ServiceAccountV2 `json:"items"`
}

// JsonWebKey JSON Web Key according to https://datatracker.ietf.org/doc/html/rfc7517#section-4
type JsonWebKey struct {
	Alg    *string `json:"alg,omitempty"`
	E      string  `json:"e"`
	Kid    *string `json:"kid,omitempty"`
	Ks     *string `json:"ks,omitempty"`
	N      string  `json:"n"`
	Ops    *string `json:"ops,omitempty"`
	Use    *string `json:"use,omitempty"`
	X5c    *string `json:"x5c,omitempty"`
	X5t    *string `json:"x5t,omitempty"`
	X5t256 *string `json:"x5t256,omitempty"`
	X5u    *string `json:"x5u,omitempty"`
}

// ServiceAccountKeyListResponse defines model for ServiceAccountKeyListResponse.
type ServiceAccountKeyListResponse struct {
	Active bool `json:"active"`

	// CreatedAt Creation time of the key
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique ID of the key.
	ID           openapi_types.UUID                        `json:"id"`
	KeyAlgorithm ServiceAccountKeyListResponseKeyAlgorithm `json:"keyAlgorithm"`
	KeyOrigin    ServiceAccountKeyListResponseKeyOrigin    `json:"keyOrigin"`
	KeyType      ServiceAccountKeyListResponseKeyType      `json:"keyType"`

	// ValidUntil If specified, the timestamp until the key is active. May be null
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// ServiceAccountKeyListResponseKeyAlgorithm defines model for ServiceAccountKeyListResponse.KeyAlgorithm.
type ServiceAccountKeyListResponseKeyAlgorithm string

// ServiceAccountKeyListResponseKeyOrigin defines model for ServiceAccountKeyListResponse.KeyOrigin.
type ServiceAccountKeyListResponseKeyOrigin string

// ServiceAccountKeyListResponseKeyType defines model for ServiceAccountKeyListResponse.KeyType.
type ServiceAccountKeyListResponseKeyType string

// ServiceAccountKeyPatchResponse defines model for ServiceAccountKeyPatchResponse.
type ServiceAccountKeyPatchResponse struct {
	Active bool `json:"active"`

	// CreatedAt Creation time of the key
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique ID of the key.
	ID           openapi_types.UUID                         `json:"id"`
	KeyAlgorithm ServiceAccountKeyPatchResponseKeyAlgorithm `json:"keyAlgorithm"`
	KeyOrigin    ServiceAccountKeyPatchResponseKeyOrigin    `json:"keyOrigin"`
	KeyType      ServiceAccountKeyPatchResponseKeyType      `json:"keyType"`

	// ValidUntil If specified, the timestamp until the key is active. May be null
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// ServiceAccountKeyPatchResponseKeyAlgorithm defines model for ServiceAccountKeyPatchResponse.KeyAlgorithm.
type ServiceAccountKeyPatchResponseKeyAlgorithm string

// ServiceAccountKeyPatchResponseKeyOrigin defines model for ServiceAccountKeyPatchResponse.KeyOrigin.
type ServiceAccountKeyPatchResponseKeyOrigin string

// ServiceAccountKeyPatchResponseKeyType defines model for ServiceAccountKeyPatchResponse.KeyType.
type ServiceAccountKeyPatchResponseKeyType string

// ServiceAccountKeyPrivateResponse defines model for ServiceAccountKeyPrivateResponse.
type ServiceAccountKeyPrivateResponse struct {
	Active bool `json:"active"`

	// CreatedAt Creation time of the key
	CreatedAt   time.Time `json:"createdAt"`
	Credentials struct {
		// Aud Audience - service account API URL
		Aud string `json:"aud"`

		// Iss Service account email
		Iss openapi_types.Email `json:"iss"`

		// Kid Key id to use
		Kid string `json:"kid"`

		// PrivateKey Private key. Only present, if the service account API was generating the key. Not recoverable later.
		PrivateKey *string `json:"privateKey,omitempty"`

		// Sub Service account id
		Sub openapi_types.UUID `json:"sub"`
	} `json:"credentials"`

	// Id Unique ID of the key.
	ID           openapi_types.UUID                           `json:"id"`
	KeyAlgorithm ServiceAccountKeyPrivateResponseKeyAlgorithm `json:"keyAlgorithm"`
	KeyOrigin    ServiceAccountKeyPrivateResponseKeyOrigin    `json:"keyOrigin"`
	KeyType      ServiceAccountKeyPrivateResponseKeyType      `json:"keyType"`

	// PublicKey Public key, that was provider, or was generated by the service account API
	PublicKey string `json:"publicKey"`

	// ValidUntil If specified, the timestamp until the key is active. May be null
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// ServiceAccountKeyPrivateResponseKeyAlgorithm defines model for ServiceAccountKeyPrivateResponse.KeyAlgorithm.
type ServiceAccountKeyPrivateResponseKeyAlgorithm string

// ServiceAccountKeyPrivateResponseKeyOrigin defines model for ServiceAccountKeyPrivateResponse.KeyOrigin.
type ServiceAccountKeyPrivateResponseKeyOrigin string

// ServiceAccountKeyPrivateResponseKeyType defines model for ServiceAccountKeyPrivateResponse.KeyType.
type ServiceAccountKeyPrivateResponseKeyType string

// ServiceAccountKeyRequest defines model for ServiceAccountKeyRequest.
type ServiceAccountKeyRequest struct {
	// PublicKey Optional, public key part of the user generated RSA key-pair wrapped in a [X.509 v3 certificate](https://www.rfc-editor.org/rfc/rfc5280)
	PublicKey *string `json:"publicKey,omitempty"`

	// ValidUntil Optional, date of key expiration. When omitted, key is valid until deleted
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// ServiceAccountKeyResponseWithKey defines model for ServiceAccountKeyResponseWithKey.
type ServiceAccountKeyResponseWithKey struct {
	Active bool `json:"active"`

	// CreatedAt Creation time of the key
	CreatedAt   time.Time `json:"createdAt"`
	Credentials struct {
		// Aud Audience - service account API URL
		Aud string `json:"aud"`

		// Iss Service account email
		Iss openapi_types.Email `json:"iss"`

		// Kid Key id to use
		Kid string `json:"kid"`

		// Sub Service account id
		Sub openapi_types.UUID `json:"sub"`
	} `json:"credentials"`

	// Id Unique ID of the key.
	ID           openapi_types.UUID                           `json:"id"`
	KeyAlgorithm ServiceAccountKeyResponseWithKeyKeyAlgorithm `json:"keyAlgorithm"`
	KeyOrigin    ServiceAccountKeyResponseWithKeyKeyOrigin    `json:"keyOrigin"`
	KeyType      ServiceAccountKeyResponseWithKeyKeyType      `json:"keyType"`

	// PublicKey Public key, in the requested format
	PublicKey *string `json:"publicKey,omitempty"`

	// ValidUntil If specified, the timestamp until the key is active. May be null
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// ServiceAccountKeyResponseWithKeyKeyAlgorithm defines model for ServiceAccountKeyResponseWithKey.KeyAlgorithm.
type ServiceAccountKeyResponseWithKeyKeyAlgorithm string

// ServiceAccountKeyResponseWithKeyKeyOrigin defines model for ServiceAccountKeyResponseWithKey.KeyOrigin.
type ServiceAccountKeyResponseWithKeyKeyOrigin string

// ServiceAccountKeyResponseWithKeyKeyType defines model for ServiceAccountKeyResponseWithKey.KeyType.
type ServiceAccountKeyResponseWithKeyKeyType string

// ServiceAccountKeyUpdateRequest defines model for ServiceAccountKeyUpdateRequest.
type ServiceAccountKeyUpdateRequest struct {
	// Active Active keys are valid, while inactive keys are temporarily deactivated.
	Active *bool `json:"active,omitempty"`

	// ValidUntil Optional, date of key expiration. When omitted, key is valid until deleted
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// ServiceAccountV2 defines model for ServiceAccountV2.
type ServiceAccountV2 struct {
	// Email Unique identifier of the service account in format of an email address generated by the service containing the prefix provided by the user during creation.
	Email openapi_types.Email `json:"email"`

	// Id Unique ID of the service account. It is also used in the 'sub' field of the service accounts access tokens.
	ID openapi_types.UUID `json:"id"`

	// ProjectId ID of the related project
	ProjectID string `json:"projectId"`
}

// TokenRequestBody defines model for TokenRequestBody.
type TokenRequestBody struct {
	// Assertion The self signed JWT. Must be given when grant_type is urn:ietf:params:oauth:grant-type:jwt-bearer
	Assertion *string `json:"assertion,omitempty"`

	// GrantType Always use URL encoded values. E.g. urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer
	GrantType TokenRequestBodyGrantType `json:"grant_type"`

	// RefreshToken Refresh token provided by a previous call with a self signed token. Must be given when grant_type is refresh_token
	RefreshToken *string `json:"refresh_token,omitempty"`
}

// TokenRequestBodyGrantType Always use URL encoded values. E.g. urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer
type TokenRequestBodyGrantType string

// TokenResponseBody defines model for TokenResponseBody.
type TokenResponseBody struct {
	// AccessToken The short lived token that can be used for API access
	AccessToken string `json:"access_token"`
	ExpiresIn   int    `json:"expires_in"`

	// RefreshToken Refresh token that can be used to request a new access token when it expires (and before refresh token expires). Tokens are rotated.
	RefreshToken string `json:"refresh_token"`

	// Scope scope field of the self signed token
	Scope     string                     `json:"scope"`
	TokenType TokenResponseBodyTokenType `json:"token_type"`
}

// TokenResponseBodyTokenType defines model for TokenResponseBody.TokenType.
type TokenResponseBodyTokenType string

// GetSAKeysKeyIDParams defines parameters for GetSAKeysKeyID.
type GetSAKeysKeyIDParams struct {
	// Format Requested format for the public key
	Format *GetSAKeysKeyIDParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetSAKeysKeyIDParamsFormat defines parameters for GetSAKeysKeyID.
type GetSAKeysKeyIDParamsFormat string

// CreateTokenFormdataRequestBody defines body for CreateToken for application/x-www-form-urlencoded ContentType.
type CreateTokenFormdataRequestBody = TokenRequestBody

// CreateSAv2JSONRequestBody defines body for CreateSAv2 for application/json ContentType.
type CreateSAv2JSONRequestBody = CreateServiceAccountRequestBodyV2

// CreateSAAccessTokensV2JSONRequestBody defines body for CreateSAAccessTokensV2 for application/json ContentType.
type CreateSAAccessTokensV2JSONRequestBody = CreateAccessTokenRequestBody

// CreateSAKeysJSONRequestBody defines body for CreateSAKeys for application/json ContentType.
type CreateSAKeysJSONRequestBody = ServiceAccountKeyRequest

// UpdateSAKeysJSONRequestBody defines body for UpdateSAKeys for application/json ContentType.
type UpdateSAKeysJSONRequestBody = ServiceAccountKeyUpdateRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client common.Client
}

// Creates a new Client, with reasonable defaults
func NewClient(server string, httpClient common.Client) *Client {
	// create a client with sane default values
	client := Client{
		Server: server,
		Client: httpClient,
	}
	return &client
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateToken request with any body
	CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTokenWithFormdataBody(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// List request
	List(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSAv2 request with any body
	CreateSAv2WithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSAv2(ctx context.Context, projectId string, body CreateSAv2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSAv2 request
	DeleteSAv2(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessTokensV2 request
	GetAccessTokensV2(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSAAccessTokensV2 request with any body
	CreateSAAccessTokensV2WithBody(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSAAccessTokensV2(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, body CreateSAAccessTokensV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSAAccessTokensV2 request
	DeleteSAAccessTokensV2(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, accessTokenId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceAccountJwks request
	GetServiceAccountJwks(ctx context.Context, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSAKeys request
	GetSAKeys(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSAKeys request with any body
	CreateSAKeysWithBody(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSAKeys(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, body CreateSAKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSAKeys request
	DeleteSAKeys(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSAKeysKeyID request
	GetSAKeysKeyID(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, params *GetSAKeysKeyIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSAKeys request with any body
	UpdateSAKeysWithBody(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSAKeys(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, body UpdateSAKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(ctx, c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithFormdataBody(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithFormdataBody(ctx, c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) List(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRequest(ctx, c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSAv2WithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSAv2RequestWithBody(ctx, c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSAv2(ctx context.Context, projectId string, body CreateSAv2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSAv2Request(ctx, c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSAv2(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSAv2Request(ctx, c.Server, projectId, serviceAccountEmail)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccessTokensV2(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessTokensV2Request(ctx, c.Server, projectId, serviceAccountEmail)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSAAccessTokensV2WithBody(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSAAccessTokensV2RequestWithBody(ctx, c.Server, projectId, serviceAccountEmail, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSAAccessTokensV2(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, body CreateSAAccessTokensV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSAAccessTokensV2Request(ctx, c.Server, projectId, serviceAccountEmail, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSAAccessTokensV2(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, accessTokenId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSAAccessTokensV2Request(ctx, c.Server, projectId, serviceAccountEmail, accessTokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceAccountJwks(ctx context.Context, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceAccountJwksRequest(ctx, c.Server, serviceAccountEmail)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSAKeys(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSAKeysRequest(ctx, c.Server, projectId, serviceAccountEmail)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSAKeysWithBody(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSAKeysRequestWithBody(ctx, c.Server, projectId, serviceAccountEmail, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSAKeys(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, body CreateSAKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSAKeysRequest(ctx, c.Server, projectId, serviceAccountEmail, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSAKeys(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSAKeysRequest(ctx, c.Server, projectId, serviceAccountEmail, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSAKeysKeyID(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, params *GetSAKeysKeyIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSAKeysKeyIDRequest(ctx, c.Server, projectId, serviceAccountEmail, keyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSAKeysWithBody(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSAKeysRequestWithBody(ctx, c.Server, projectId, serviceAccountEmail, keyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSAKeys(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, body UpdateSAKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSAKeysRequest(ctx, c.Server, projectId, serviceAccountEmail, keyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateTokenRequestWithFormdataBody calls the generic CreateToken builder with application/x-www-form-urlencoded body
func NewCreateTokenRequestWithFormdataBody(ctx context.Context, server string, body CreateTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCreateTokenRequestWithBody(ctx, server, "application/x-www-form-urlencoded", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(ctx context.Context, server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListRequest generates requests for List
func NewListRequest(ctx context.Context, server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/service-accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSAv2Request calls the generic CreateSAv2 builder with application/json body
func NewCreateSAv2Request(ctx context.Context, server string, projectId string, body CreateSAv2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSAv2RequestWithBody(ctx, server, projectId, "application/json", bodyReader)
}

// NewCreateSAv2RequestWithBody generates requests for CreateSAv2 with any type of body
func NewCreateSAv2RequestWithBody(ctx context.Context, server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/service-accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSAv2Request generates requests for DeleteSAv2
func NewDeleteSAv2Request(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/service-accounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccessTokensV2Request generates requests for GetAccessTokensV2
func NewGetAccessTokensV2Request(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/service-accounts/%s/access-tokens", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSAAccessTokensV2Request calls the generic CreateSAAccessTokensV2 builder with application/json body
func NewCreateSAAccessTokensV2Request(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email, body CreateSAAccessTokensV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSAAccessTokensV2RequestWithBody(ctx, server, projectId, serviceAccountEmail, "application/json", bodyReader)
}

// NewCreateSAAccessTokensV2RequestWithBody generates requests for CreateSAAccessTokensV2 with any type of body
func NewCreateSAAccessTokensV2RequestWithBody(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/service-accounts/%s/access-tokens", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSAAccessTokensV2Request generates requests for DeleteSAAccessTokensV2
func NewDeleteSAAccessTokensV2Request(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email, accessTokenId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "accessTokenId", runtime.ParamLocationPath, accessTokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/service-accounts/%s/access-tokens/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceAccountJwksRequest generates requests for GetServiceAccountJwks
func NewGetServiceAccountJwksRequest(ctx context.Context, server string, serviceAccountEmail openapi_types.Email) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/service-accounts/public/jwk/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSAKeysRequest generates requests for GetSAKeys
func NewGetSAKeysRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2alpha1/projects/%s/service-accounts/%s/keys", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSAKeysRequest calls the generic CreateSAKeys builder with application/json body
func NewCreateSAKeysRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email, body CreateSAKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSAKeysRequestWithBody(ctx, server, projectId, serviceAccountEmail, "application/json", bodyReader)
}

// NewCreateSAKeysRequestWithBody generates requests for CreateSAKeys with any type of body
func NewCreateSAKeysRequestWithBody(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2alpha1/projects/%s/service-accounts/%s/keys", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSAKeysRequest generates requests for DeleteSAKeys
func NewDeleteSAKeysRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2alpha1/projects/%s/service-accounts/%s/keys/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSAKeysKeyIDRequest generates requests for GetSAKeysKeyID
func NewGetSAKeysKeyIDRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, params *GetSAKeysKeyIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2alpha1/projects/%s/service-accounts/%s/keys/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Format != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSAKeysRequest calls the generic UpdateSAKeys builder with application/json body
func NewUpdateSAKeysRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, body UpdateSAKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSAKeysRequestWithBody(ctx, server, projectId, serviceAccountEmail, keyId, "application/json", bodyReader)
}

// NewUpdateSAKeysRequestWithBody generates requests for UpdateSAKeys with any type of body
func NewUpdateSAKeysRequestWithBody(ctx context.Context, server string, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2alpha1/projects/%s/service-accounts/%s/keys/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, httpClient common.Client) *ClientWithResponses {
	return &ClientWithResponses{NewClient(server, httpClient)}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateToken request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithFormdataBodyWithResponse(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// List request
	ListWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*ListResponse, error)

	// CreateSAv2 request with any body
	CreateSAv2WithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSAv2Response, error)

	CreateSAv2WithResponse(ctx context.Context, projectId string, body CreateSAv2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSAv2Response, error)

	// DeleteSAv2 request
	DeleteSAv2WithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*DeleteSAv2Response, error)

	// GetAccessTokensV2 request
	GetAccessTokensV2WithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*GetAccessTokensV2Response, error)

	// CreateSAAccessTokensV2 request with any body
	CreateSAAccessTokensV2WithBodyWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSAAccessTokensV2Response, error)

	CreateSAAccessTokensV2WithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, body CreateSAAccessTokensV2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSAAccessTokensV2Response, error)

	// DeleteSAAccessTokensV2 request
	DeleteSAAccessTokensV2WithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, accessTokenId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteSAAccessTokensV2Response, error)

	// GetServiceAccountJwks request
	GetServiceAccountJwksWithResponse(ctx context.Context, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*GetServiceAccountJwksResponse, error)

	// GetSAKeys request
	GetSAKeysWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*GetSAKeysResponse, error)

	// CreateSAKeys request with any body
	CreateSAKeysWithBodyWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSAKeysResponse, error)

	CreateSAKeysWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, body CreateSAKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSAKeysResponse, error)

	// DeleteSAKeys request
	DeleteSAKeysWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteSAKeysResponse, error)

	// GetSAKeysKeyID request
	GetSAKeysKeyIDWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, params *GetSAKeysKeyIDParams, reqEditors ...RequestEditorFn) (*GetSAKeysKeyIDResponse, error)

	// UpdateSAKeys request with any body
	UpdateSAKeysWithBodyWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSAKeysResponse, error)

	UpdateSAKeysWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, body UpdateSAKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSAKeysResponse, error)
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponseBody
	Error     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetServiceAccountsResponseBodyV2
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *AuthError
	Error     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r ListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSAv2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServiceAccountV2
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON409      *Error
	Error     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r CreateSAv2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSAv2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSAv2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON404      *Error
	Error     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r DeleteSAv2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSAv2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessTokensV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAccessTokensResponseBodyV2
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON404      *Error
	Error     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetAccessTokensV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessTokensV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSAAccessTokensV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AccessTokenV2
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON404      *Error
	Error     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r CreateSAAccessTokensV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSAAccessTokensV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSAAccessTokensV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	Error     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r DeleteSAAccessTokensV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSAAccessTokensV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceAccountJwksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetJWKResponseBody
	Error     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetServiceAccountJwksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceAccountJwksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSAKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetServiceAccountsKeysResponseBody
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *AuthError
	Error     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetSAKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSAKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSAKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServiceAccountKeyPrivateResponse
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON409      *Error
	Error     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r CreateSAKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSAKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSAKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *AuthError
	Error     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r DeleteSAKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSAKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSAKeysKeyIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccountKeyResponseWithKey
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *AuthError
	Error     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetSAKeysKeyIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSAKeysKeyIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSAKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServiceAccountKeyPatchResponse
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON409      *Error
	Error     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r UpdateSAKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSAKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithFormdataBodyWithResponse(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateTokenResponse(rsp)
}

// ListWithResponse request returning *ListResponse
func (c *ClientWithResponses) ListWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*ListResponse, error) {
	rsp, err := c.List(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseListResponse(rsp)
}

// CreateSAv2WithBodyWithResponse request with arbitrary body returning *CreateSAv2Response
func (c *ClientWithResponses) CreateSAv2WithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSAv2Response, error) {
	rsp, err := c.CreateSAv2WithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateSAv2Response(rsp)
}

func (c *ClientWithResponses) CreateSAv2WithResponse(ctx context.Context, projectId string, body CreateSAv2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSAv2Response, error) {
	rsp, err := c.CreateSAv2(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateSAv2Response(rsp)
}

// DeleteSAv2WithResponse request returning *DeleteSAv2Response
func (c *ClientWithResponses) DeleteSAv2WithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*DeleteSAv2Response, error) {
	rsp, err := c.DeleteSAv2(ctx, projectId, serviceAccountEmail, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseDeleteSAv2Response(rsp)
}

// GetAccessTokensV2WithResponse request returning *GetAccessTokensV2Response
func (c *ClientWithResponses) GetAccessTokensV2WithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*GetAccessTokensV2Response, error) {
	rsp, err := c.GetAccessTokensV2(ctx, projectId, serviceAccountEmail, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetAccessTokensV2Response(rsp)
}

// CreateSAAccessTokensV2WithBodyWithResponse request with arbitrary body returning *CreateSAAccessTokensV2Response
func (c *ClientWithResponses) CreateSAAccessTokensV2WithBodyWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSAAccessTokensV2Response, error) {
	rsp, err := c.CreateSAAccessTokensV2WithBody(ctx, projectId, serviceAccountEmail, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateSAAccessTokensV2Response(rsp)
}

func (c *ClientWithResponses) CreateSAAccessTokensV2WithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, body CreateSAAccessTokensV2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSAAccessTokensV2Response, error) {
	rsp, err := c.CreateSAAccessTokensV2(ctx, projectId, serviceAccountEmail, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateSAAccessTokensV2Response(rsp)
}

// DeleteSAAccessTokensV2WithResponse request returning *DeleteSAAccessTokensV2Response
func (c *ClientWithResponses) DeleteSAAccessTokensV2WithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, accessTokenId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteSAAccessTokensV2Response, error) {
	rsp, err := c.DeleteSAAccessTokensV2(ctx, projectId, serviceAccountEmail, accessTokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseDeleteSAAccessTokensV2Response(rsp)
}

// GetServiceAccountJwksWithResponse request returning *GetServiceAccountJwksResponse
func (c *ClientWithResponses) GetServiceAccountJwksWithResponse(ctx context.Context, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*GetServiceAccountJwksResponse, error) {
	rsp, err := c.GetServiceAccountJwks(ctx, serviceAccountEmail, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetServiceAccountJwksResponse(rsp)
}

// GetSAKeysWithResponse request returning *GetSAKeysResponse
func (c *ClientWithResponses) GetSAKeysWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, reqEditors ...RequestEditorFn) (*GetSAKeysResponse, error) {
	rsp, err := c.GetSAKeys(ctx, projectId, serviceAccountEmail, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetSAKeysResponse(rsp)
}

// CreateSAKeysWithBodyWithResponse request with arbitrary body returning *CreateSAKeysResponse
func (c *ClientWithResponses) CreateSAKeysWithBodyWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSAKeysResponse, error) {
	rsp, err := c.CreateSAKeysWithBody(ctx, projectId, serviceAccountEmail, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateSAKeysResponse(rsp)
}

func (c *ClientWithResponses) CreateSAKeysWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, body CreateSAKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSAKeysResponse, error) {
	rsp, err := c.CreateSAKeys(ctx, projectId, serviceAccountEmail, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateSAKeysResponse(rsp)
}

// DeleteSAKeysWithResponse request returning *DeleteSAKeysResponse
func (c *ClientWithResponses) DeleteSAKeysWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteSAKeysResponse, error) {
	rsp, err := c.DeleteSAKeys(ctx, projectId, serviceAccountEmail, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseDeleteSAKeysResponse(rsp)
}

// GetSAKeysKeyIDWithResponse request returning *GetSAKeysKeyIDResponse
func (c *ClientWithResponses) GetSAKeysKeyIDWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, params *GetSAKeysKeyIDParams, reqEditors ...RequestEditorFn) (*GetSAKeysKeyIDResponse, error) {
	rsp, err := c.GetSAKeysKeyID(ctx, projectId, serviceAccountEmail, keyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetSAKeysKeyIDResponse(rsp)
}

// UpdateSAKeysWithBodyWithResponse request with arbitrary body returning *UpdateSAKeysResponse
func (c *ClientWithResponses) UpdateSAKeysWithBodyWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSAKeysResponse, error) {
	rsp, err := c.UpdateSAKeysWithBody(ctx, projectId, serviceAccountEmail, keyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseUpdateSAKeysResponse(rsp)
}

func (c *ClientWithResponses) UpdateSAKeysWithResponse(ctx context.Context, projectId string, serviceAccountEmail openapi_types.Email, keyId openapi_types.UUID, body UpdateSAKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSAKeysResponse, error) {
	rsp, err := c.UpdateSAKeys(ctx, projectId, serviceAccountEmail, keyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseUpdateSAKeysResponse(rsp)
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func (c *ClientWithResponses) ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListResponse parses an HTTP response from a ListWithResponse call
func (c *ClientWithResponses) ParseListResponse(rsp *http.Response) (*ListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetServiceAccountsResponseBodyV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateSAv2Response parses an HTTP response from a CreateSAv2WithResponse call
func (c *ClientWithResponses) ParseCreateSAv2Response(rsp *http.Response) (*CreateSAv2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSAv2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServiceAccountV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteSAv2Response parses an HTTP response from a DeleteSAv2WithResponse call
func (c *ClientWithResponses) ParseDeleteSAv2Response(rsp *http.Response) (*DeleteSAv2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSAv2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAccessTokensV2Response parses an HTTP response from a GetAccessTokensV2WithResponse call
func (c *ClientWithResponses) ParseGetAccessTokensV2Response(rsp *http.Response) (*GetAccessTokensV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessTokensV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAccessTokensResponseBodyV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateSAAccessTokensV2Response parses an HTTP response from a CreateSAAccessTokensV2WithResponse call
func (c *ClientWithResponses) ParseCreateSAAccessTokensV2Response(rsp *http.Response) (*CreateSAAccessTokensV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSAAccessTokensV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AccessTokenV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteSAAccessTokensV2Response parses an HTTP response from a DeleteSAAccessTokensV2WithResponse call
func (c *ClientWithResponses) ParseDeleteSAAccessTokensV2Response(rsp *http.Response) (*DeleteSAAccessTokensV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSAAccessTokensV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetServiceAccountJwksResponse parses an HTTP response from a GetServiceAccountJwksWithResponse call
func (c *ClientWithResponses) ParseGetServiceAccountJwksResponse(rsp *http.Response) (*GetServiceAccountJwksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceAccountJwksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetJWKResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSAKeysResponse parses an HTTP response from a GetSAKeysWithResponse call
func (c *ClientWithResponses) ParseGetSAKeysResponse(rsp *http.Response) (*GetSAKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSAKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetServiceAccountsKeysResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateSAKeysResponse parses an HTTP response from a CreateSAKeysWithResponse call
func (c *ClientWithResponses) ParseCreateSAKeysResponse(rsp *http.Response) (*CreateSAKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSAKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServiceAccountKeyPrivateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteSAKeysResponse parses an HTTP response from a DeleteSAKeysWithResponse call
func (c *ClientWithResponses) ParseDeleteSAKeysResponse(rsp *http.Response) (*DeleteSAKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSAKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetSAKeysKeyIDResponse parses an HTTP response from a GetSAKeysKeyIDWithResponse call
func (c *ClientWithResponses) ParseGetSAKeysKeyIDResponse(rsp *http.Response) (*GetSAKeysKeyIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSAKeysKeyIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccountKeyResponseWithKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdateSAKeysResponse parses an HTTP response from a UpdateSAKeysWithResponse call
func (c *ClientWithResponses) ParseUpdateSAKeysResponse(rsp *http.Response) (*UpdateSAKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSAKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServiceAccountKeyPatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON409 = &dest

	}

	return response, nil
}
