// Package serviceaccounts provides primitives to interact with the openapi HTTP API.
//
// Code generated by dev.azure.com/schwarzit/schwarzit.odj.core/_git/stackit-client-generator.git version v1.0.23 DO NOT EDIT.
package serviceaccounts

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/pkg/errors"

	"github.com/SchwarzIT/community-stackit-go-client/internal/helpers/runtime"
	openapiTypes "github.com/SchwarzIT/community-stackit-go-client/internal/helpers/types"
	contracts "github.com/SchwarzIT/community-stackit-go-client/pkg/contracts"
	"github.com/SchwarzIT/community-stackit-go-client/pkg/validate"
)

const (
	AuthorizationScopes = "Authorization.Scopes"
)

// Defines values for ServiceAccountKeyListResponseKeyAlgorithm.
const (
	SERVICE_ACCOUNT_KEY_LIST_RESPONSE_KEY_ALGORITHM_RSA_2048 ServiceAccountKeyListResponseKeyAlgorithm = "RSA_2048"
)

// Defines values for ServiceAccountKeyListResponseKeyOrigin.
const (
	SERVICE_ACCOUNT_KEY_LIST_RESPONSE_KEY_ORIGIN_GENERATED     ServiceAccountKeyListResponseKeyOrigin = "GENERATED"
	SERVICE_ACCOUNT_KEY_LIST_RESPONSE_KEY_ORIGIN_USER_PROVIDED ServiceAccountKeyListResponseKeyOrigin = "USER_PROVIDED"
)

// Defines values for ServiceAccountKeyListResponseKeyType.
const (
	SERVICE_ACCOUNT_KEY_LIST_RESPONSE_KEY_TYPE_SYSTEM_MANAGED ServiceAccountKeyListResponseKeyType = "SYSTEM_MANAGED"
	SERVICE_ACCOUNT_KEY_LIST_RESPONSE_KEY_TYPE_USER_MANAGED   ServiceAccountKeyListResponseKeyType = "USER_MANAGED"
)

// Defines values for ServiceAccountKeyPatchResponseKeyAlgorithm.
const (
	SERVICE_ACCOUNT_KEY_PATCH_RESPONSE_KEY_ALGORITHM_RSA_2048 ServiceAccountKeyPatchResponseKeyAlgorithm = "RSA_2048"
)

// Defines values for ServiceAccountKeyPatchResponseKeyOrigin.
const (
	SERVICE_ACCOUNT_KEY_PATCH_RESPONSE_KEY_ORIGIN_GENERATED     ServiceAccountKeyPatchResponseKeyOrigin = "GENERATED"
	SERVICE_ACCOUNT_KEY_PATCH_RESPONSE_KEY_ORIGIN_USER_PROVIDED ServiceAccountKeyPatchResponseKeyOrigin = "USER_PROVIDED"
)

// Defines values for ServiceAccountKeyPatchResponseKeyType.
const (
	SERVICE_ACCOUNT_KEY_PATCH_RESPONSE_KEY_TYPE_SYSTEM_MANAGED ServiceAccountKeyPatchResponseKeyType = "SYSTEM_MANAGED"
	SERVICE_ACCOUNT_KEY_PATCH_RESPONSE_KEY_TYPE_USER_MANAGED   ServiceAccountKeyPatchResponseKeyType = "USER_MANAGED"
)

// Defines values for ServiceAccountKeyPrivateResponseKeyAlgorithm.
const (
	SERVICE_ACCOUNT_KEY_PRIVATE_RESPONSE_KEY_ALGORITHM_RSA_2048 ServiceAccountKeyPrivateResponseKeyAlgorithm = "RSA_2048"
)

// Defines values for ServiceAccountKeyPrivateResponseKeyOrigin.
const (
	SERVICE_ACCOUNT_KEY_PRIVATE_RESPONSE_KEY_ORIGIN_GENERATED     ServiceAccountKeyPrivateResponseKeyOrigin = "GENERATED"
	SERVICE_ACCOUNT_KEY_PRIVATE_RESPONSE_KEY_ORIGIN_USER_PROVIDED ServiceAccountKeyPrivateResponseKeyOrigin = "USER_PROVIDED"
)

// Defines values for ServiceAccountKeyPrivateResponseKeyType.
const (
	SERVICE_ACCOUNT_KEY_PRIVATE_RESPONSE_KEY_TYPE_SYSTEM_MANAGED ServiceAccountKeyPrivateResponseKeyType = "SYSTEM_MANAGED"
	SERVICE_ACCOUNT_KEY_PRIVATE_RESPONSE_KEY_TYPE_USER_MANAGED   ServiceAccountKeyPrivateResponseKeyType = "USER_MANAGED"
)

// Defines values for ServiceAccountKeyResponseWithKeyKeyAlgorithm.
const (
	SERVICE_ACCOUNT_KEY_RESPONSE_WITH_KEY_KEY_ALGORITHM_RSA_2048 ServiceAccountKeyResponseWithKeyKeyAlgorithm = "RSA_2048"
)

// Defines values for ServiceAccountKeyResponseWithKeyKeyOrigin.
const (
	SERVICE_ACCOUNT_KEY_RESPONSE_WITH_KEY_KEY_ORIGIN_GENERATED     ServiceAccountKeyResponseWithKeyKeyOrigin = "GENERATED"
	SERVICE_ACCOUNT_KEY_RESPONSE_WITH_KEY_KEY_ORIGIN_USER_PROVIDED ServiceAccountKeyResponseWithKeyKeyOrigin = "USER_PROVIDED"
)

// Defines values for ServiceAccountKeyResponseWithKeyKeyType.
const (
	SERVICE_ACCOUNT_KEY_RESPONSE_WITH_KEY_KEY_TYPE_SYSTEM_MANAGED ServiceAccountKeyResponseWithKeyKeyType = "SYSTEM_MANAGED"
	SERVICE_ACCOUNT_KEY_RESPONSE_WITH_KEY_KEY_TYPE_USER_MANAGED   ServiceAccountKeyResponseWithKeyKeyType = "USER_MANAGED"
)

// Defines values for TokenRequestBodyGrantType.
const (
	REFRESH_TOKEN                               TokenRequestBodyGrantType = "refresh_token"
	URN_IETF_PARAMS_OAUTH_GRANT_TYPE_JWT_BEARER TokenRequestBodyGrantType = "urn:ietf:params:oauth:grant-type:jwt-bearer"
)

// Defines values for TokenResponseBodyTokenType.
const (
	BEARER TokenResponseBodyTokenType = "Bearer"
)

// Defines values for GeKeyParamsFormat.
const (
	X509_PEM GeKeyParamsFormat = "X509_PEM"
)

// AccessTokenMetadataV2 Does not contain the actual token.
type AccessTokenMetadataV2 struct {
	// Active If true, access token can be used for authorized API calls, if false, the token is not usable anymore.
	Active bool `json:"active"`

	// CreatedAt Creation time of the access token.
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique ID of the access token. Also used as JTI field.
	ID openapiTypes.UUID `json:"id"`

	// ValidUntil Approximate expiration time of the access token. Check the JWT for actual validity date.
	ValidUntil time.Time `json:"validUntil"`
}

// AccessTokenV2 Contains token metadata and actual token.
type AccessTokenV2 struct {
	// Active Newly created access tokens are valid, and can be revoked if needed.
	Active bool `json:"active"`

	// CreatedAt Creation time of the access token.
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique ID of the access token. Also used as JTI field.
	ID openapiTypes.UUID `json:"id"`

	// Token The access token in JWT format. Use this with `Bearer` prefix for API calls. Store it, as it is not recoverable later.
	Token string `json:"token"`

	// ValidUntil Approximate expiration time of the access token. Check the JWT for actual validity date.
	ValidUntil time.Time `json:"validUntil"`
}

// AuthError defines model for AuthError.
type AuthError struct {
	Error struct {
		Code    int    `json:"code"`
		Message string `json:"message"`
		Status  string `json:"status"`
	} `json:"error"`
}

// CreateAccessTokenRequestBody defines model for CreateAccessTokenRequestBody.
type CreateAccessTokenRequestBody struct {
	// TtlDays The duration in days for how long the new Access Token should be valid.
	TtlDays int `json:"ttlDays"`
}

// CreateServiceAccountRequestBodyV2 defines model for CreateServiceAccountRequestBodyV2.
type CreateServiceAccountRequestBodyV2 struct {
	// Name The requested name of the service account. The service will generate a unique email from this name.
	Name string `json:"name"`
}

// Error Contains error information.
type Error struct {
	Error     string    `json:"error"`
	Message   string    `json:"message"`
	Path      string    `json:"path"`
	Status    int       `json:"status"`
	TimeStamp time.Time `json:"timeStamp"`
}

// GetAccessTokensResponseBodyV2 defines model for GetAccessTokensResponseBodyV2.
type GetAccessTokensResponseBodyV2 struct {
	Items *[]AccessTokenMetadataV2 `json:"items,omitempty"`
}

// GetJWKResponseBody defines model for GetJWKResponseBody.
type GetJWKResponseBody struct {
	Keys []JsonWebKey `json:"keys"`
}

// GetServiceAccountsKeysResponseBody defines model for GetServiceAccountsKeysResponseBody.
type GetServiceAccountsKeysResponseBody struct {
	Items []ServiceAccountKeyListResponse `json:"items"`
}

// GetServiceAccountsResponseBodyV2 defines model for GetServiceAccountsResponseBodyV2.
type GetServiceAccountsResponseBodyV2 struct {
	Items []ServiceAccountV2 `json:"items"`
}

// JsonWebKey JSON Web Key according to https://datatracker.ietf.org/doc/html/rfc7517#section-4
type JsonWebKey struct {
	Alg    *string `json:"alg,omitempty"`
	E      string  `json:"e"`
	Kid    *string `json:"kid,omitempty"`
	Ks     *string `json:"ks,omitempty"`
	N      string  `json:"n"`
	Ops    *string `json:"ops,omitempty"`
	Use    *string `json:"use,omitempty"`
	X5c    *string `json:"x5c,omitempty"`
	X5t    *string `json:"x5t,omitempty"`
	X5t256 *string `json:"x5t256,omitempty"`
	X5u    *string `json:"x5u,omitempty"`
}

// ServiceAccountKeyListResponse defines model for ServiceAccountKeyListResponse.
type ServiceAccountKeyListResponse struct {
	Active bool `json:"active"`

	// CreatedAt Creation time of the key
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique ID of the key.
	ID           openapiTypes.UUID                         `json:"id"`
	KeyAlgorithm ServiceAccountKeyListResponseKeyAlgorithm `json:"keyAlgorithm"`
	KeyOrigin    ServiceAccountKeyListResponseKeyOrigin    `json:"keyOrigin"`
	KeyType      ServiceAccountKeyListResponseKeyType      `json:"keyType"`

	// ValidUntil If specified, the timestamp until the key is active. May be null
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// ServiceAccountKeyListResponseKeyAlgorithm defines model for ServiceAccountKeyListResponse.KeyAlgorithm.
type ServiceAccountKeyListResponseKeyAlgorithm string

// ServiceAccountKeyListResponseKeyOrigin defines model for ServiceAccountKeyListResponse.KeyOrigin.
type ServiceAccountKeyListResponseKeyOrigin string

// ServiceAccountKeyListResponseKeyType defines model for ServiceAccountKeyListResponse.KeyType.
type ServiceAccountKeyListResponseKeyType string

// ServiceAccountKeyPatchResponse defines model for ServiceAccountKeyPatchResponse.
type ServiceAccountKeyPatchResponse struct {
	Active bool `json:"active"`

	// CreatedAt Creation time of the key
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique ID of the key.
	ID           openapiTypes.UUID                          `json:"id"`
	KeyAlgorithm ServiceAccountKeyPatchResponseKeyAlgorithm `json:"keyAlgorithm"`
	KeyOrigin    ServiceAccountKeyPatchResponseKeyOrigin    `json:"keyOrigin"`
	KeyType      ServiceAccountKeyPatchResponseKeyType      `json:"keyType"`

	// ValidUntil If specified, the timestamp until the key is active. May be null
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// ServiceAccountKeyPatchResponseKeyAlgorithm defines model for ServiceAccountKeyPatchResponse.KeyAlgorithm.
type ServiceAccountKeyPatchResponseKeyAlgorithm string

// ServiceAccountKeyPatchResponseKeyOrigin defines model for ServiceAccountKeyPatchResponse.KeyOrigin.
type ServiceAccountKeyPatchResponseKeyOrigin string

// ServiceAccountKeyPatchResponseKeyType defines model for ServiceAccountKeyPatchResponse.KeyType.
type ServiceAccountKeyPatchResponseKeyType string

// ServiceAccountKeyPrivateResponse defines model for ServiceAccountKeyPrivateResponse.
type ServiceAccountKeyPrivateResponse struct {
	Active bool `json:"active"`

	// CreatedAt Creation time of the key
	CreatedAt   time.Time `json:"createdAt"`
	Credentials struct {
		// Aud Audience - service account API URL
		Aud string `json:"aud"`

		// Iss Service account email
		Iss openapiTypes.Email `json:"iss"`

		// Kid Key id to use
		Kid string `json:"kid"`

		// PrivateKey Private key. Only present, if the service account API was generating the key. Not recoverable later.
		PrivateKey *string `json:"privateKey,omitempty"`

		// Sub Service account id
		Sub openapiTypes.UUID `json:"sub"`
	} `json:"credentials"`

	// Id Unique ID of the key.
	ID           openapiTypes.UUID                            `json:"id"`
	KeyAlgorithm ServiceAccountKeyPrivateResponseKeyAlgorithm `json:"keyAlgorithm"`
	KeyOrigin    ServiceAccountKeyPrivateResponseKeyOrigin    `json:"keyOrigin"`
	KeyType      ServiceAccountKeyPrivateResponseKeyType      `json:"keyType"`

	// PublicKey Public key, that was provider, or was generated by the service account API
	PublicKey string `json:"publicKey"`

	// ValidUntil If specified, the timestamp until the key is active. May be null
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// ServiceAccountKeyPrivateResponseKeyAlgorithm defines model for ServiceAccountKeyPrivateResponse.KeyAlgorithm.
type ServiceAccountKeyPrivateResponseKeyAlgorithm string

// ServiceAccountKeyPrivateResponseKeyOrigin defines model for ServiceAccountKeyPrivateResponse.KeyOrigin.
type ServiceAccountKeyPrivateResponseKeyOrigin string

// ServiceAccountKeyPrivateResponseKeyType defines model for ServiceAccountKeyPrivateResponse.KeyType.
type ServiceAccountKeyPrivateResponseKeyType string

// ServiceAccountKeyRequest defines model for ServiceAccountKeyRequest.
type ServiceAccountKeyRequest struct {
	// PublicKey Optional, public key part of the user generated RSA key-pair wrapped in a [X.509 v3 certificate](https://www.rfc-editor.org/rfc/rfc5280)
	PublicKey *string `json:"publicKey,omitempty"`

	// ValidUntil Optional, date of key expiration. When omitted, key is valid until deleted
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// ServiceAccountKeyResponseWithKey defines model for ServiceAccountKeyResponseWithKey.
type ServiceAccountKeyResponseWithKey struct {
	Active bool `json:"active"`

	// CreatedAt Creation time of the key
	CreatedAt   time.Time `json:"createdAt"`
	Credentials struct {
		// Aud Audience - service account API URL
		Aud string `json:"aud"`

		// Iss Service account email
		Iss openapiTypes.Email `json:"iss"`

		// Kid Key id to use
		Kid string `json:"kid"`

		// Sub Service account id
		Sub openapiTypes.UUID `json:"sub"`
	} `json:"credentials"`

	// Id Unique ID of the key.
	ID           openapiTypes.UUID                            `json:"id"`
	KeyAlgorithm ServiceAccountKeyResponseWithKeyKeyAlgorithm `json:"keyAlgorithm"`
	KeyOrigin    ServiceAccountKeyResponseWithKeyKeyOrigin    `json:"keyOrigin"`
	KeyType      ServiceAccountKeyResponseWithKeyKeyType      `json:"keyType"`

	// PublicKey Public key, in the requested format
	PublicKey *string `json:"publicKey,omitempty"`

	// ValidUntil If specified, the timestamp until the key is active. May be null
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// ServiceAccountKeyResponseWithKeyKeyAlgorithm defines model for ServiceAccountKeyResponseWithKey.KeyAlgorithm.
type ServiceAccountKeyResponseWithKeyKeyAlgorithm string

// ServiceAccountKeyResponseWithKeyKeyOrigin defines model for ServiceAccountKeyResponseWithKey.KeyOrigin.
type ServiceAccountKeyResponseWithKeyKeyOrigin string

// ServiceAccountKeyResponseWithKeyKeyType defines model for ServiceAccountKeyResponseWithKey.KeyType.
type ServiceAccountKeyResponseWithKeyKeyType string

// ServiceAccountKeyUpdateRequest defines model for ServiceAccountKeyUpdateRequest.
type ServiceAccountKeyUpdateRequest struct {
	// Active Active keys are valid, while inactive keys are temporarily deactivated.
	Active *bool `json:"active,omitempty"`

	// ValidUntil Optional, date of key expiration. When omitted, key is valid until deleted
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// ServiceAccountV2 defines model for ServiceAccountV2.
type ServiceAccountV2 struct {
	// Email Unique identifier of the service account in format of an email address generated by the service containing the prefix provided by the user during creation.
	Email openapiTypes.Email `json:"email"`

	// Id Unique ID of the service account. It is also used in the 'sub' field of the service accounts access tokens.
	ID openapiTypes.UUID `json:"id"`

	// ProjectId ID of the related project
	ProjectID string `json:"projectId"`
}

// TokenRequestBody defines model for TokenRequestBody.
type TokenRequestBody struct {
	// Assertion The self signed JWT. Must be given when grant_type is urn:ietf:params:oauth:grant-type:jwt-bearer
	Assertion *string `json:"assertion,omitempty"`

	// GrantType Always use URL encoded values. E.g. urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer
	GrantType TokenRequestBodyGrantType `json:"grant_type"`

	// RefreshToken Refresh token provided by a previous call with a self signed token. Must be given when grant_type is refresh_token
	RefreshToken *string `json:"refresh_token,omitempty"`
}

// TokenRequestBodyGrantType Always use URL encoded values. E.g. urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer
type TokenRequestBodyGrantType string

// TokenResponseBody defines model for TokenResponseBody.
type TokenResponseBody struct {
	// AccessToken The short lived token that can be used for API access
	AccessToken string `json:"access_token"`
	ExpiresIn   int    `json:"expires_in"`

	// RefreshToken Refresh token that can be used to request a new access token when it expires (and before refresh token expires). Tokens are rotated.
	RefreshToken string `json:"refresh_token"`

	// Scope scope field of the self signed token
	Scope     string                     `json:"scope"`
	TokenType TokenResponseBodyTokenType `json:"token_type"`
}

// TokenResponseBodyTokenType defines model for TokenResponseBody.TokenType.
type TokenResponseBodyTokenType string

// GeKeyParams defines parameters for GeKey.
type GeKeyParams struct {
	// Format Requested format for the public key
	Format *GeKeyParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GeKeyParamsFormat defines parameters for GeKey.
type GeKeyParamsFormat string

// CreateTokenFormdataRequestBody defines body for CreateToken for application/x-www-form-urlencoded ContentType.
type CreateTokenFormdataRequestBody = TokenRequestBody

// CreateJSONRequestBody defines body for Create for application/json ContentType.
type CreateJSONRequestBody = CreateServiceAccountRequestBodyV2

// CreateAccessTokensJSONRequestBody defines body for CreateAccessTokens for application/json ContentType.
type CreateAccessTokensJSONRequestBody = CreateAccessTokenRequestBody

// CreateKeysJSONRequestBody defines body for CreateKeys for application/json ContentType.
type CreateKeysJSONRequestBody = ServiceAccountKeyRequest

// UpdateKeysJSONRequestBody defines body for UpdateKeys for application/json ContentType.
type UpdateKeysJSONRequestBody = ServiceAccountKeyUpdateRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Client which conforms to the OpenAPI3 specification for this service.
type Client[K contracts.ClientFlowConfig] struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client contracts.ClientInterface[K]
}

// NewRawClient Creates a new Client, with reasonable defaults
func NewRawClient[K contracts.ClientFlowConfig](server string, httpClient contracts.ClientInterface[K]) *Client[K] {
	// create a client with sane default values
	client := Client[K]{
		Server: server,
		Client: httpClient,
	}
	return &client
}

// The interface specification for the client above.
type rawClientInterface interface {
	// CreateToken request with any body
	CreateTokenRawWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTokenWithFormdataBodyRaw(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Get request
	GetRaw(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create request with any body
	CreateRawWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRaw(ctx context.Context, projectId string, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Delete request
	DeleteRaw(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessTokens request
	GetAccessTokensRaw(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAccessTokens request with any body
	CreateAccessTokensRawWithBody(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAccessTokensRaw(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, body CreateAccessTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAccessTokens request
	DeleteAccessTokensRaw(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, accessTokenId openapiTypes.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceAccountJwks request
	GetServiceAccountJwksRaw(ctx context.Context, serviceAccountEmail openapiTypes.Email, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeys request
	GetKeysRaw(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeys request with any body
	CreateKeysRawWithBody(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeysRaw(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, body CreateKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKeys request
	DeleteKeysRaw(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GeKey request
	GeKeyRaw(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, params *GeKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateKeys request with any body
	UpdateKeysRawWithBody(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateKeysRaw(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, body UpdateKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client[K]) CreateTokenRawWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(ctx, c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) CreateTokenWithFormdataBodyRaw(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithFormdataBody(ctx, c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) GetRaw(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequest(ctx, c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) CreateRawWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequestWithBody(ctx, c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) CreateRaw(ctx context.Context, projectId string, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequest(ctx, c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) DeleteRaw(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRequest(ctx, c.Server, projectId, serviceAccountEmail)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) GetAccessTokensRaw(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessTokensRequest(ctx, c.Server, projectId, serviceAccountEmail)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) CreateAccessTokensRawWithBody(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessTokensRequestWithBody(ctx, c.Server, projectId, serviceAccountEmail, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) CreateAccessTokensRaw(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, body CreateAccessTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessTokensRequest(ctx, c.Server, projectId, serviceAccountEmail, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) DeleteAccessTokensRaw(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, accessTokenId openapiTypes.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAccessTokensRequest(ctx, c.Server, projectId, serviceAccountEmail, accessTokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) GetServiceAccountJwksRaw(ctx context.Context, serviceAccountEmail openapiTypes.Email, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceAccountJwksRequest(ctx, c.Server, serviceAccountEmail)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) GetKeysRaw(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeysRequest(ctx, c.Server, projectId, serviceAccountEmail)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) CreateKeysRawWithBody(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeysRequestWithBody(ctx, c.Server, projectId, serviceAccountEmail, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) CreateKeysRaw(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, body CreateKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeysRequest(ctx, c.Server, projectId, serviceAccountEmail, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) DeleteKeysRaw(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeysRequest(ctx, c.Server, projectId, serviceAccountEmail, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) GeKeyRaw(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, params *GeKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGeKeyRequest(ctx, c.Server, projectId, serviceAccountEmail, keyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) UpdateKeysRawWithBody(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeysRequestWithBody(ctx, c.Server, projectId, serviceAccountEmail, keyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) UpdateKeysRaw(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, body UpdateKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeysRequest(ctx, c.Server, projectId, serviceAccountEmail, keyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateTokenRequestWithFormdataBody calls the generic CreateToken builder with application/x-www-form-urlencoded body
func NewCreateTokenRequestWithFormdataBody(ctx context.Context, server string, body CreateTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCreateTokenRequestWithBody(ctx, server, "application/x-www-form-urlencoded", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(ctx context.Context, server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRequest generates requests for Get
func NewGetRequest(ctx context.Context, server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/service-accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRequest calls the generic Create builder with application/json body
func NewCreateRequest(ctx context.Context, server string, projectId string, body CreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRequestWithBody(ctx, server, projectId, "application/json", bodyReader)
}

// NewCreateRequestWithBody generates requests for Create with any type of body
func NewCreateRequestWithBody(ctx context.Context, server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/service-accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRequest generates requests for Delete
func NewDeleteRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapiTypes.Email) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/service-accounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccessTokensRequest generates requests for GetAccessTokens
func NewGetAccessTokensRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapiTypes.Email) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/service-accounts/%s/access-tokens", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAccessTokensRequest calls the generic CreateAccessTokens builder with application/json body
func NewCreateAccessTokensRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapiTypes.Email, body CreateAccessTokensJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAccessTokensRequestWithBody(ctx, server, projectId, serviceAccountEmail, "application/json", bodyReader)
}

// NewCreateAccessTokensRequestWithBody generates requests for CreateAccessTokens with any type of body
func NewCreateAccessTokensRequestWithBody(ctx context.Context, server string, projectId string, serviceAccountEmail openapiTypes.Email, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/service-accounts/%s/access-tokens", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAccessTokensRequest generates requests for DeleteAccessTokens
func NewDeleteAccessTokensRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapiTypes.Email, accessTokenId openapiTypes.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "accessTokenId", runtime.ParamLocationPath, accessTokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/service-accounts/%s/access-tokens/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceAccountJwksRequest generates requests for GetServiceAccountJwks
func NewGetServiceAccountJwksRequest(ctx context.Context, server string, serviceAccountEmail openapiTypes.Email) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/service-accounts/public/jwk/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeysRequest generates requests for GetKeys
func NewGetKeysRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapiTypes.Email) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2alpha1/projects/%s/service-accounts/%s/keys", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeysRequest calls the generic CreateKeys builder with application/json body
func NewCreateKeysRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapiTypes.Email, body CreateKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeysRequestWithBody(ctx, server, projectId, serviceAccountEmail, "application/json", bodyReader)
}

// NewCreateKeysRequestWithBody generates requests for CreateKeys with any type of body
func NewCreateKeysRequestWithBody(ctx context.Context, server string, projectId string, serviceAccountEmail openapiTypes.Email, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2alpha1/projects/%s/service-accounts/%s/keys", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeysRequest generates requests for DeleteKeys
func NewDeleteKeysRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2alpha1/projects/%s/service-accounts/%s/keys/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGeKeyRequest generates requests for GeKey
func NewGeKeyRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, params *GeKeyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2alpha1/projects/%s/service-accounts/%s/keys/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Format != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateKeysRequest calls the generic UpdateKeys builder with application/json body
func NewUpdateKeysRequest(ctx context.Context, server string, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, body UpdateKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateKeysRequestWithBody(ctx, server, projectId, serviceAccountEmail, keyId, "application/json", bodyReader)
}

// NewUpdateKeysRequestWithBody generates requests for UpdateKeys with any type of body
func NewUpdateKeysRequestWithBody(ctx context.Context, server string, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountEmail", runtime.ParamLocationPath, serviceAccountEmail)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2alpha1/projects/%s/service-accounts/%s/keys/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client[K]) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on rawClientInterface to offer response payloads
type ClientWithResponses[K contracts.ClientFlowConfig] struct {
	rawClientInterface
}

// NewClient creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClient[K contracts.ClientFlowConfig](server string, httpClient contracts.ClientInterface[K]) *ClientWithResponses[K] {
	return &ClientWithResponses[K]{NewRawClient(server, httpClient)}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface[K contracts.ClientFlowConfig] interface {
	// CreateToken request with any body
	CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithFormdataBody(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// Get request
	Get(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*GetResponse, error)

	// Create request with any body
	CreateWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResponse, error)

	Create(ctx context.Context, projectId string, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResponse, error)

	// Delete request
	Delete(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, reqEditors ...RequestEditorFn) (*DeleteResponse, error)

	// GetAccessTokens request
	GetAccessTokens(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, reqEditors ...RequestEditorFn) (*GetAccessTokensResponse, error)

	// CreateAccessTokens request with any body
	CreateAccessTokensWithBody(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessTokensResponse, error)

	CreateAccessTokens(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, body CreateAccessTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessTokensResponse, error)

	// DeleteAccessTokens request
	DeleteAccessTokens(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, accessTokenId openapiTypes.UUID, reqEditors ...RequestEditorFn) (*DeleteAccessTokensResponse, error)

	// GetServiceAccountJwks request
	GetServiceAccountJwks(ctx context.Context, serviceAccountEmail openapiTypes.Email, reqEditors ...RequestEditorFn) (*GetServiceAccountJwksResponse, error)

	// GetKeys request
	GetKeys(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, reqEditors ...RequestEditorFn) (*GetKeysResponse, error)

	// CreateKeys request with any body
	CreateKeysWithBody(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeysResponse, error)

	CreateKeys(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, body CreateKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeysResponse, error)

	// DeleteKeys request
	DeleteKeys(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, reqEditors ...RequestEditorFn) (*DeleteKeysResponse, error)

	// GeKey request
	GeKey(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, params *GeKeyParams, reqEditors ...RequestEditorFn) (*GeKeyResponse, error)

	// UpdateKeys request with any body
	UpdateKeysWithBody(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeysResponse, error)

	UpdateKeys(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, body UpdateKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeysResponse, error)
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponseBody
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetServiceAccountsResponseBodyV2
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *AuthError
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServiceAccountV2
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON409      *Error
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r CreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON404      *Error
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r DeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAccessTokensResponseBodyV2
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON404      *Error
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetAccessTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAccessTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AccessTokenV2
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON404      *Error
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r CreateAccessTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccessTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAccessTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r DeleteAccessTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAccessTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceAccountJwksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetJWKResponseBody
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetServiceAccountJwksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceAccountJwksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetServiceAccountsKeysResponseBody
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *AuthError
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServiceAccountKeyPrivateResponse
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON409      *Error
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r CreateKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *AuthError
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r DeleteKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GeKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccountKeyResponseWithKey
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *AuthError
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GeKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GeKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServiceAccountKeyPatchResponse
	JSON400      *Error
	JSON401      *AuthError
	JSON403      *Error
	JSON409      *Error
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r UpdateKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateTokenWithBody request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses[K]) CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenRawWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses[K]) CreateTokenWithFormdataBody(ctx context.Context, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithFormdataBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateTokenResponse(rsp)
}

// Get request returning *GetResponse
func (c *ClientWithResponses[K]) Get(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*GetResponse, error) {
	rsp, err := c.GetRaw(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetResponse(rsp)
}

// CreateWithBody request with arbitrary body returning *CreateResponse
func (c *ClientWithResponses[K]) CreateWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResponse, error) {
	rsp, err := c.CreateRawWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateResponse(rsp)
}

func (c *ClientWithResponses[K]) Create(ctx context.Context, projectId string, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResponse, error) {
	rsp, err := c.CreateRaw(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateResponse(rsp)
}

// Delete request returning *DeleteResponse
func (c *ClientWithResponses[K]) Delete(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, reqEditors ...RequestEditorFn) (*DeleteResponse, error) {
	rsp, err := c.DeleteRaw(ctx, projectId, serviceAccountEmail, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseDeleteResponse(rsp)
}

// GetAccessTokens request returning *GetAccessTokensResponse
func (c *ClientWithResponses[K]) GetAccessTokens(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, reqEditors ...RequestEditorFn) (*GetAccessTokensResponse, error) {
	rsp, err := c.GetAccessTokensRaw(ctx, projectId, serviceAccountEmail, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetAccessTokensResponse(rsp)
}

// CreateAccessTokensWithBody request with arbitrary body returning *CreateAccessTokensResponse
func (c *ClientWithResponses[K]) CreateAccessTokensWithBody(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessTokensResponse, error) {
	rsp, err := c.CreateAccessTokensRawWithBody(ctx, projectId, serviceAccountEmail, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateAccessTokensResponse(rsp)
}

func (c *ClientWithResponses[K]) CreateAccessTokens(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, body CreateAccessTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessTokensResponse, error) {
	rsp, err := c.CreateAccessTokensRaw(ctx, projectId, serviceAccountEmail, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateAccessTokensResponse(rsp)
}

// DeleteAccessTokens request returning *DeleteAccessTokensResponse
func (c *ClientWithResponses[K]) DeleteAccessTokens(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, accessTokenId openapiTypes.UUID, reqEditors ...RequestEditorFn) (*DeleteAccessTokensResponse, error) {
	rsp, err := c.DeleteAccessTokensRaw(ctx, projectId, serviceAccountEmail, accessTokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseDeleteAccessTokensResponse(rsp)
}

// GetServiceAccountJwks request returning *GetServiceAccountJwksResponse
func (c *ClientWithResponses[K]) GetServiceAccountJwks(ctx context.Context, serviceAccountEmail openapiTypes.Email, reqEditors ...RequestEditorFn) (*GetServiceAccountJwksResponse, error) {
	rsp, err := c.GetServiceAccountJwksRaw(ctx, serviceAccountEmail, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetServiceAccountJwksResponse(rsp)
}

// GetKeys request returning *GetKeysResponse
func (c *ClientWithResponses[K]) GetKeys(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, reqEditors ...RequestEditorFn) (*GetKeysResponse, error) {
	rsp, err := c.GetKeysRaw(ctx, projectId, serviceAccountEmail, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetKeysResponse(rsp)
}

// CreateKeysWithBody request with arbitrary body returning *CreateKeysResponse
func (c *ClientWithResponses[K]) CreateKeysWithBody(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeysResponse, error) {
	rsp, err := c.CreateKeysRawWithBody(ctx, projectId, serviceAccountEmail, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateKeysResponse(rsp)
}

func (c *ClientWithResponses[K]) CreateKeys(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, body CreateKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeysResponse, error) {
	rsp, err := c.CreateKeysRaw(ctx, projectId, serviceAccountEmail, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateKeysResponse(rsp)
}

// DeleteKeys request returning *DeleteKeysResponse
func (c *ClientWithResponses[K]) DeleteKeys(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, reqEditors ...RequestEditorFn) (*DeleteKeysResponse, error) {
	rsp, err := c.DeleteKeysRaw(ctx, projectId, serviceAccountEmail, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseDeleteKeysResponse(rsp)
}

// GeKey request returning *GeKeyResponse
func (c *ClientWithResponses[K]) GeKey(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, params *GeKeyParams, reqEditors ...RequestEditorFn) (*GeKeyResponse, error) {
	rsp, err := c.GeKeyRaw(ctx, projectId, serviceAccountEmail, keyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGeKeyResponse(rsp)
}

// UpdateKeysWithBody request with arbitrary body returning *UpdateKeysResponse
func (c *ClientWithResponses[K]) UpdateKeysWithBody(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeysResponse, error) {
	rsp, err := c.UpdateKeysRawWithBody(ctx, projectId, serviceAccountEmail, keyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseUpdateKeysResponse(rsp)
}

func (c *ClientWithResponses[K]) UpdateKeys(ctx context.Context, projectId string, serviceAccountEmail openapiTypes.Email, keyId openapiTypes.UUID, body UpdateKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeysResponse, error) {
	rsp, err := c.UpdateKeysRaw(ctx, projectId, serviceAccountEmail, keyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseUpdateKeysResponse(rsp)
}

// ParseCreateTokenResponse parses an HTTP response from a CreateToken call
func (c *ClientWithResponses[K]) ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseGetResponse parses an HTTP response from a Get call
func (c *ClientWithResponses[K]) ParseGetResponse(rsp *http.Response) (*GetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetServiceAccountsResponseBodyV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseCreateResponse parses an HTTP response from a Create call
func (c *ClientWithResponses[K]) ParseCreateResponse(rsp *http.Response) (*CreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServiceAccountV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON409 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseDeleteResponse parses an HTTP response from a Delete call
func (c *ClientWithResponses[K]) ParseDeleteResponse(rsp *http.Response) (*DeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON404 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseGetAccessTokensResponse parses an HTTP response from a GetAccessTokens call
func (c *ClientWithResponses[K]) ParseGetAccessTokensResponse(rsp *http.Response) (*GetAccessTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAccessTokensResponseBodyV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON404 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseCreateAccessTokensResponse parses an HTTP response from a CreateAccessTokens call
func (c *ClientWithResponses[K]) ParseCreateAccessTokensResponse(rsp *http.Response) (*CreateAccessTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAccessTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AccessTokenV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON404 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseDeleteAccessTokensResponse parses an HTTP response from a DeleteAccessTokens call
func (c *ClientWithResponses[K]) ParseDeleteAccessTokensResponse(rsp *http.Response) (*DeleteAccessTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAccessTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON409 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseGetServiceAccountJwksResponse parses an HTTP response from a GetServiceAccountJwks call
func (c *ClientWithResponses[K]) ParseGetServiceAccountJwksResponse(rsp *http.Response) (*GetServiceAccountJwksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceAccountJwksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetJWKResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseGetKeysResponse parses an HTTP response from a GetKeys call
func (c *ClientWithResponses[K]) ParseGetKeysResponse(rsp *http.Response) (*GetKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetServiceAccountsKeysResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseCreateKeysResponse parses an HTTP response from a CreateKeys call
func (c *ClientWithResponses[K]) ParseCreateKeysResponse(rsp *http.Response) (*CreateKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServiceAccountKeyPrivateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON409 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseDeleteKeysResponse parses an HTTP response from a DeleteKeys call
func (c *ClientWithResponses[K]) ParseDeleteKeysResponse(rsp *http.Response) (*DeleteKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseGeKeyResponse parses an HTTP response from a GeKey call
func (c *ClientWithResponses[K]) ParseGeKeyResponse(rsp *http.Response) (*GeKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GeKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccountKeyResponseWithKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseUpdateKeysResponse parses an HTTP response from a UpdateKeys call
func (c *ClientWithResponses[K]) ParseUpdateKeysResponse(rsp *http.Response) (*UpdateKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServiceAccountKeyPatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON409 = &dest

	}

	return response, validate.ResponseObject(response)
}
