// Package instances provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/do87/stackit-client-generator version v0.0.3 DO NOT EDIT.
package instances

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/pkg/errors"

	contracts "github.com/SchwarzIT/community-stackit-go-client/pkg/contracts"
	"github.com/SchwarzIT/community-stackit-go-client/pkg/helpers/runtime"
	openapiTypes "github.com/SchwarzIT/community-stackit-go-client/pkg/helpers/types"
	"github.com/SchwarzIT/community-stackit-go-client/pkg/validate"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for ListenerProtocol.
const (
	PROTOCOL_TCP         ListenerProtocol = "PROTOCOL_TCP"
	PROTOCOL_TCP_PROXY   ListenerProtocol = "PROTOCOL_TCP_PROXY"
	PROTOCOL_UDP         ListenerProtocol = "PROTOCOL_UDP"
	PROTOCOL_UNSPECIFIED ListenerProtocol = "PROTOCOL_UNSPECIFIED"
)

// Defines values for LoadBalancerStatus.
const (
	STATUS_ERROR       LoadBalancerStatus = "STATUS_ERROR"
	STATUS_PENDING     LoadBalancerStatus = "STATUS_PENDING"
	STATUS_READY       LoadBalancerStatus = "STATUS_READY"
	STATUS_TERMINATING LoadBalancerStatus = "STATUS_TERMINATING"
	STATUS_UNSPECIFIED LoadBalancerStatus = "STATUS_UNSPECIFIED"
)

// Defines values for LoadBalancerErrorType.
const (
	TYPE_FIP_NOT_CONFIGURED          LoadBalancerErrorType = "TYPE_FIP_NOT_CONFIGURED"
	TYPE_INTERNAL                    LoadBalancerErrorType = "TYPE_INTERNAL"
	TYPE_PORT_NOT_CONFIGURED         LoadBalancerErrorType = "TYPE_PORT_NOT_CONFIGURED"
	TYPE_QUOTA_SECGROUPRULE_EXCEEDED LoadBalancerErrorType = "TYPE_QUOTA_SECGROUPRULE_EXCEEDED"
	TYPE_QUOTA_SECGROUP_EXCEEDED     LoadBalancerErrorType = "TYPE_QUOTA_SECGROUP_EXCEEDED"
	TYPE_TARGET_NOT_ACTIVE           LoadBalancerErrorType = "TYPE_TARGET_NOT_ACTIVE"
	TYPE_UNSPECIFIED                 LoadBalancerErrorType = "TYPE_UNSPECIFIED"
)

// Defines values for NetworkRole.
const (
	ROLE_LISTENERS             NetworkRole = "ROLE_LISTENERS"
	ROLE_LISTENERS_AND_TARGETS NetworkRole = "ROLE_LISTENERS_AND_TARGETS"
	ROLE_TARGETS               NetworkRole = "ROLE_TARGETS"
	ROLE_UNSPECIFIED           NetworkRole = "ROLE_UNSPECIFIED"
)

// ActiveHealthCheck defines model for ActiveHealthCheck.
type ActiveHealthCheck struct {
	// HealthyThreshold Healthy threshold of the health checking
	HealthyThreshold *int `json:"healthyThreshold,omitempty"`

	// Interval Interval duration of health checking in seconds
	Interval *string `json:"interval,omitempty"`

	// IntervalJitter Interval duration threshold of the health checking in seconds
	IntervalJitter *string `json:"intervalJitter,omitempty"`

	// Timeout Active health checking timeout duration in seconds
	Timeout *string `json:"timeout,omitempty"`

	// UnhealthyThreshold Unhealthy threshold of the health checking
	UnhealthyThreshold *int `json:"unhealthyThreshold,omitempty"`
}

// DeleteLoadBalancerResponse Response for deleting a load balancer has an empty body if successful.
type DeleteLoadBalancerResponse = map[string]interface{}

// ListLoadBalancersResponse defines model for ListLoadBalancersResponse.
type ListLoadBalancersResponse struct {
	LoadBalancers *[]LoadBalancer `json:"loadBalancers,omitempty"`
}

// Listener defines model for Listener.
type Listener struct {
	DisplayName *string `json:"displayName,omitempty"`

	// Name Will be used to reference a listener and will replace display name in the future. Currently uses <protocol>-<port> as the name if no display name is given.
	Name *string `json:"name,omitempty"`

	// Port Port number where we listen for traffic
	Port *int `json:"port,omitempty"`

	// Protocol Protocol is the highest network protocol we understand to load balance. Currently only PROTOCOL_TCP and PROTOCOL_TCP_PROXY are supported.
	Protocol *ListenerProtocol `json:"protocol,omitempty"`

	// TargetPool Reference target pool by target pool name.
	TargetPool *string `json:"targetPool,omitempty"`
}

// ListenerProtocol Protocol is the highest network protocol we understand to load balance. Currently only PROTOCOL_TCP and PROTOCOL_TCP_PROXY are supported.
type ListenerProtocol string

// LoadBalancer defines model for LoadBalancer.
type LoadBalancer struct {
	Errors *[]LoadBalancerError `json:"errors,omitempty"`

	// ExternalAddress External load balancer IP address where this load balancer is exposed. Not changeable after creation.
	ExternalAddress *string `json:"externalAddress,omitempty"`

	// Listeners List of all listeners which will accept traffic. Limited to 20.
	Listeners *[]Listener `json:"listeners,omitempty"`

	// Name Load balancer name. Not changeable after creation.
	Name *string `json:"name,omitempty"`

	// Networks List of networks that listeners and targets reside in. Currently limited to one. Not changeable after creation.
	Networks *[]Network `json:"networks,omitempty"`

	// Options Defines any optional functionality you want to have enabled on your load balancer.
	Options *LoadBalancerOptions `json:"options,omitempty"`

	// PrivateAddress Transient private load balancer IP address that can change any time.
	PrivateAddress *string             `json:"privateAddress,omitempty"`
	Status         *LoadBalancerStatus `json:"status,omitempty"`

	// TargetPools List of all target pools which will be used in the load balancer. Limited to 20.
	TargetPools *[]TargetPool `json:"targetPools,omitempty"`

	// Version Load balancer resource version.
	// Must be empty or unset for creating load balancers, non-empty for updating load balancers. Semantics:
	// While retrieving load balancers, this is the current version of this load balancer resource that changes during updates of the load balancers. On updates this field specified the load balancer version you calculated your update for instead of the future version to enable concurrency safe updates. Update calls will then report the new version in their result as you would see with a load balancer retrieval call later. There exist no total order of the version, so you can only compare it for equality, but not for less/greater than another version. Since the creation of load balancer is always intended to create the first version of it, there should be no existing version. That's why this field must by empty of not present in that case.
	Version *string `json:"version,omitempty"`
}

// LoadBalancerStatus defines model for LoadBalancer.Status.
type LoadBalancerStatus string

// LoadBalancerError defines model for LoadBalancerError.
type LoadBalancerError struct {
	Description *string                `json:"description,omitempty"`
	Type        *LoadBalancerErrorType `json:"type,omitempty"`
}

// LoadBalancerErrorType defines model for LoadBalancerError.Type.
type LoadBalancerErrorType string

// LoadBalancerOptions Defines any optional functionality you want to have enabled on your load balancer.
type LoadBalancerOptions struct {
	// AccessControl Use this option to limit the IP ranges that can use the load balancer. Not changeable after creation.
	AccessControl    *LoadbalancerOptionAccessControl `json:"accessControl,omitempty"`
	EphemeralAddress *bool                            `json:"ephemeralAddress,omitempty"`

	// Observability We offer Load Balancer metrics observability via ARGUS or external solutions. Not changeable after creation.
	Observability *LoadbalancerOptionObservability `json:"observability,omitempty"`

	// PrivateNetworkOnly Load Balancer is accessible only via a private network ip address. Not changeable after creation.
	PrivateNetworkOnly *bool `json:"privateNetworkOnly,omitempty"`
}

// LoadbalancerOptionAccessControl Use this option to limit the IP ranges that can use the load balancer. Not changeable after creation.
type LoadbalancerOptionAccessControl struct {
	// AllowedSourceRanges Load Balancer is accessible only from an IP address in this range
	AllowedSourceRanges *[]string `json:"allowedSourceRanges,omitempty"`
}

// LoadbalancerOptionMetrics defines model for LoadbalancerOptionMetrics.
type LoadbalancerOptionMetrics struct {
	// CredentialsRef Credentials reference for metrics. Enables monitoring via remote write for the Load Balancer.
	CredentialsRef *string `json:"credentialsRef,omitempty"`

	// PushUrl The ARGUS/Prometheus remote write Push URL you want the metrics to be send to.
	PushUrl *string `json:"pushUrl,omitempty"`
}

// LoadbalancerOptionObservability We offer Load Balancer metrics observability via ARGUS or external solutions. Not changeable after creation.
type LoadbalancerOptionObservability struct {
	Metrics *LoadbalancerOptionMetrics `json:"metrics,omitempty"`
}

// Network defines model for Network.
type Network struct {
	// NetworkId Openstack network ID
	NetworkID *openapiTypes.UUID `json:"networkId,omitempty"`

	// Role The role defines how the load balancer is using the network. Currently only ROLE_LISTENERS_AND_TARGETS is supported.
	Role *NetworkRole `json:"role,omitempty"`
}

// NetworkRole The role defines how the load balancer is using the network. Currently only ROLE_LISTENERS_AND_TARGETS is supported.
type NetworkRole string

// Target defines model for Target.
type Target struct {
	// DisplayName Target name
	DisplayName *string `json:"displayName,omitempty"`

	// Ip Target IP
	Ip *string `json:"ip,omitempty"`
}

// TargetPool defines model for TargetPool.
type TargetPool struct {
	ActiveHealthCheck *ActiveHealthCheck `json:"activeHealthCheck,omitempty"`

	// Name Target pool name
	Name *string `json:"name,omitempty"`

	// TargetPort Identical port number where each target listens for traffic.
	TargetPort *int `json:"targetPort,omitempty"`

	// Targets List of all targets which will be used in the pool. Limited to 250.
	Targets *[]Target `json:"targets,omitempty"`
}

// CreateParams defines parameters for Create.
type CreateParams struct {
	XRequestID openapiTypes.UUID `json:"X-Request-ID"`
}

// CreateJSONRequestBody defines body for Create for application/json ContentType.
type CreateJSONRequestBody = LoadBalancer

// UpdateJSONRequestBody defines body for Update for application/json ContentType.
type UpdateJSONRequestBody = LoadBalancer

// ReplaceTargetPoolJSONRequestBody defines body for ReplaceTargetPool for application/json ContentType.
type ReplaceTargetPoolJSONRequestBody = TargetPool

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client contracts.BaseClientInterface
}

// NewRawClient Creates a new Client, with reasonable defaults
func NewRawClient(server string, httpClient contracts.BaseClientInterface) *Client {
	// create a client with sane default values
	client := Client{
		Server: server,
		Client: httpClient,
	}
	return &client
}

// The interface specification for the client above.
type rawClientInterface interface {
	// List request
	ListRaw(ctx context.Context, projectID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create request with any body
	CreateRawWithBody(ctx context.Context, projectID string, params *CreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRaw(ctx context.Context, projectID string, params *CreateParams, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Delete request
	DeleteRaw(ctx context.Context, projectID string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Get request
	GetRaw(ctx context.Context, projectID string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Update request with any body
	UpdateRawWithBody(ctx context.Context, projectID string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRaw(ctx context.Context, projectID string, name string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTargetPool request with any body
	ReplaceTargetPoolRawWithBody(ctx context.Context, projectID string, name string, targetPoolName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTargetPoolRaw(ctx context.Context, projectID string, name string, targetPoolName string, body ReplaceTargetPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListRaw(ctx context.Context, projectID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRequest(ctx, c.Server, projectID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRawWithBody(ctx context.Context, projectID string, params *CreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequestWithBody(ctx, c.Server, projectID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRaw(ctx context.Context, projectID string, params *CreateParams, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequest(ctx, c.Server, projectID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRaw(ctx context.Context, projectID string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRequest(ctx, c.Server, projectID, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRaw(ctx context.Context, projectID string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequest(ctx, c.Server, projectID, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRawWithBody(ctx context.Context, projectID string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequestWithBody(ctx, c.Server, projectID, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRaw(ctx context.Context, projectID string, name string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequest(ctx, c.Server, projectID, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTargetPoolRawWithBody(ctx context.Context, projectID string, name string, targetPoolName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTargetPoolRequestWithBody(ctx, c.Server, projectID, name, targetPoolName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTargetPoolRaw(ctx context.Context, projectID string, name string, targetPoolName string, body ReplaceTargetPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTargetPoolRequest(ctx, c.Server, projectID, name, targetPoolName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListRequest generates requests for List
func NewListRequest(ctx context.Context, server string, projectID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/load-balancers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRequest calls the generic Create builder with application/json body
func NewCreateRequest(ctx context.Context, server string, projectID string, params *CreateParams, body CreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRequestWithBody(ctx, server, projectID, params, "application/json", bodyReader)
}

// NewCreateRequestWithBody generates requests for Create with any type of body
func NewCreateRequestWithBody(ctx context.Context, server string, projectID string, params *CreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/load-balancers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-Request-ID", headerParam0)

	return req, nil
}

// NewDeleteRequest generates requests for Delete
func NewDeleteRequest(ctx context.Context, server string, projectID string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/load-balancers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRequest generates requests for Get
func NewGetRequest(ctx context.Context, server string, projectID string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/load-balancers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRequest calls the generic Update builder with application/json body
func NewUpdateRequest(ctx context.Context, server string, projectID string, name string, body UpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRequestWithBody(ctx, server, projectID, name, "application/json", bodyReader)
}

// NewUpdateRequestWithBody generates requests for Update with any type of body
func NewUpdateRequestWithBody(ctx context.Context, server string, projectID string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/load-balancers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTargetPoolRequest calls the generic ReplaceTargetPool builder with application/json body
func NewReplaceTargetPoolRequest(ctx context.Context, server string, projectID string, name string, targetPoolName string, body ReplaceTargetPoolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTargetPoolRequestWithBody(ctx, server, projectID, name, targetPoolName, "application/json", bodyReader)
}

// NewReplaceTargetPoolRequestWithBody generates requests for ReplaceTargetPool with any type of body
func NewReplaceTargetPoolRequestWithBody(ctx context.Context, server string, projectID string, name string, targetPoolName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "targetPoolName", runtime.ParamLocationPath, targetPoolName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/load-balancers/%s/target-pools/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on rawClientInterface to offer response payloads
type ClientWithResponses struct {
	rawClientInterface
}

// NewClient creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClient(server string, httpClient contracts.BaseClientInterface) *ClientWithResponses {
	return &ClientWithResponses{NewRawClient(server, httpClient)}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// List request
	List(ctx context.Context, projectID string, reqEditors ...RequestEditorFn) (*ListResponse, error)

	// Create request with any body
	CreateWithBody(ctx context.Context, projectID string, params *CreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResponse, error)

	Create(ctx context.Context, projectID string, params *CreateParams, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResponse, error)

	// Delete request
	Delete(ctx context.Context, projectID string, name string, reqEditors ...RequestEditorFn) (*DeleteResponse, error)

	// Get request
	Get(ctx context.Context, projectID string, name string, reqEditors ...RequestEditorFn) (*GetResponse, error)

	// Update request with any body
	UpdateWithBody(ctx context.Context, projectID string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResponse, error)

	Update(ctx context.Context, projectID string, name string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResponse, error)

	// ReplaceTargetPool request with any body
	ReplaceTargetPoolWithBody(ctx context.Context, projectID string, name string, targetPoolName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTargetPoolResponse, error)

	ReplaceTargetPool(ctx context.Context, projectID string, name string, targetPoolName string, body ReplaceTargetPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTargetPoolResponse, error)
}

type ListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListLoadBalancersResponse
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r ListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadBalancer
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r CreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteLoadBalancerResponse
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r DeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadBalancer
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadBalancer
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r UpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTargetPoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TargetPool
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r ReplaceTargetPoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTargetPoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// List request returning *ListResponse
func (c *ClientWithResponses) List(ctx context.Context, projectID string, reqEditors ...RequestEditorFn) (*ListResponse, error) {
	rsp, err := c.ListRaw(ctx, projectID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseListResponse(rsp)
}

// CreateWithBody request with arbitrary body returning *CreateResponse
func (c *ClientWithResponses) CreateWithBody(ctx context.Context, projectID string, params *CreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResponse, error) {
	rsp, err := c.CreateRawWithBody(ctx, projectID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateResponse(rsp)
}

func (c *ClientWithResponses) Create(ctx context.Context, projectID string, params *CreateParams, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResponse, error) {
	rsp, err := c.CreateRaw(ctx, projectID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateResponse(rsp)
}

// Delete request returning *DeleteResponse
func (c *ClientWithResponses) Delete(ctx context.Context, projectID string, name string, reqEditors ...RequestEditorFn) (*DeleteResponse, error) {
	rsp, err := c.DeleteRaw(ctx, projectID, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseDeleteResponse(rsp)
}

// Get request returning *GetResponse
func (c *ClientWithResponses) Get(ctx context.Context, projectID string, name string, reqEditors ...RequestEditorFn) (*GetResponse, error) {
	rsp, err := c.GetRaw(ctx, projectID, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetResponse(rsp)
}

// UpdateWithBody request with arbitrary body returning *UpdateResponse
func (c *ClientWithResponses) UpdateWithBody(ctx context.Context, projectID string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResponse, error) {
	rsp, err := c.UpdateRawWithBody(ctx, projectID, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseUpdateResponse(rsp)
}

func (c *ClientWithResponses) Update(ctx context.Context, projectID string, name string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResponse, error) {
	rsp, err := c.UpdateRaw(ctx, projectID, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseUpdateResponse(rsp)
}

// ReplaceTargetPoolWithBody request with arbitrary body returning *ReplaceTargetPoolResponse
func (c *ClientWithResponses) ReplaceTargetPoolWithBody(ctx context.Context, projectID string, name string, targetPoolName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTargetPoolResponse, error) {
	rsp, err := c.ReplaceTargetPoolRawWithBody(ctx, projectID, name, targetPoolName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseReplaceTargetPoolResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTargetPool(ctx context.Context, projectID string, name string, targetPoolName string, body ReplaceTargetPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTargetPoolResponse, error) {
	rsp, err := c.ReplaceTargetPoolRaw(ctx, projectID, name, targetPoolName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseReplaceTargetPoolResponse(rsp)
}

// ParseListResponse parses an HTTP response from a List call
func (c *ClientWithResponses) ParseListResponse(rsp *http.Response) (*ListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListLoadBalancersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseCreateResponse parses an HTTP response from a Create call
func (c *ClientWithResponses) ParseCreateResponse(rsp *http.Response) (*CreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadBalancer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseDeleteResponse parses an HTTP response from a Delete call
func (c *ClientWithResponses) ParseDeleteResponse(rsp *http.Response) (*DeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteLoadBalancerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseGetResponse parses an HTTP response from a Get call
func (c *ClientWithResponses) ParseGetResponse(rsp *http.Response) (*GetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadBalancer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseUpdateResponse parses an HTTP response from a Update call
func (c *ClientWithResponses) ParseUpdateResponse(rsp *http.Response) (*UpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadBalancer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseReplaceTargetPoolResponse parses an HTTP response from a ReplaceTargetPool call
func (c *ClientWithResponses) ParseReplaceTargetPoolResponse(rsp *http.Response) (*ReplaceTargetPoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTargetPoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TargetPool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	}

	return response, validate.ResponseObject(response)
}
