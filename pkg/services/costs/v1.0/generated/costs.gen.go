// Package costs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/do87/oapi-codegen version v0.5.1 DO NOT EDIT.
package costs

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/pkg/errors"

	common "github.com/SchwarzIT/community-stackit-go-client/internal/common"
	"github.com/SchwarzIT/community-stackit-go-client/pkg/validate"
	"github.com/do87/oapi-codegen/pkg/runtime"
	openapi_types "github.com/do87/oapi-codegen/pkg/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for GetCostsForAllProjectsInCustomerAccountParamsDepth.
const (
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_DEPTH_AUTO    GetCostsForAllProjectsInCustomerAccountParamsDepth = "auto"
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_DEPTH_PROJECT GetCostsForAllProjectsInCustomerAccountParamsDepth = "project"
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_DEPTH_SERVICE GetCostsForAllProjectsInCustomerAccountParamsDepth = "service"
)

// Defines values for GetCostsForAllProjectsInCustomerAccountParamsGranularity.
const (
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_GRANULARITY_DAILY   GetCostsForAllProjectsInCustomerAccountParamsGranularity = "daily"
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_GRANULARITY_MONTHLY GetCostsForAllProjectsInCustomerAccountParamsGranularity = "monthly"
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_GRANULARITY_NONE    GetCostsForAllProjectsInCustomerAccountParamsGranularity = "none"
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_GRANULARITY_WEEKLY  GetCostsForAllProjectsInCustomerAccountParamsGranularity = "weekly"
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_GRANULARITY_YEARLY  GetCostsForAllProjectsInCustomerAccountParamsGranularity = "yearly"
)

// Defines values for GetCostsForAllProjectsInCustomerAccountParamsAccept.
const (
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_ACCEPT_APPLICATION_JSON GetCostsForAllProjectsInCustomerAccountParamsAccept = "application/json"
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_ACCEPT_TEXT_CSV         GetCostsForAllProjectsInCustomerAccountParamsAccept = "text/csv"
)

// Defines values for GetCostsForAllProjectsInAllSubCustomerAccountsParamsDepth.
const (
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_DEPTH_AUTO    GetCostsForAllProjectsInAllSubCustomerAccountsParamsDepth = "auto"
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_DEPTH_PROJECT GetCostsForAllProjectsInAllSubCustomerAccountsParamsDepth = "project"
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_DEPTH_SERVICE GetCostsForAllProjectsInAllSubCustomerAccountsParamsDepth = "service"
)

// Defines values for GetCostsForAllProjectsInAllSubCustomerAccountsParamsGranularity.
const (
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_GRANULARITY_DAILY   GetCostsForAllProjectsInAllSubCustomerAccountsParamsGranularity = "daily"
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_GRANULARITY_MONTHLY GetCostsForAllProjectsInAllSubCustomerAccountsParamsGranularity = "monthly"
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_GRANULARITY_NONE    GetCostsForAllProjectsInAllSubCustomerAccountsParamsGranularity = "none"
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_GRANULARITY_WEEKLY  GetCostsForAllProjectsInAllSubCustomerAccountsParamsGranularity = "weekly"
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_GRANULARITY_YEARLY  GetCostsForAllProjectsInAllSubCustomerAccountsParamsGranularity = "yearly"
)

// Defines values for GetCostsForAllProjectsInAllSubCustomerAccountsParamsAccept.
const (
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_ACCEPT_APPLICATION_JSON GetCostsForAllProjectsInAllSubCustomerAccountsParamsAccept = "application/json"
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_ACCEPT_TEXT_CSV         GetCostsForAllProjectsInAllSubCustomerAccountsParamsAccept = "text/csv"
)

// Defines values for GetProjectCostsParamsDepth.
const (
	AUTO    GetProjectCostsParamsDepth = "auto"
	PROJECT GetProjectCostsParamsDepth = "project"
	SERVICE GetProjectCostsParamsDepth = "service"
)

// Defines values for GetProjectCostsParamsGranularity.
const (
	GET_PROJECT_COSTS_PARAMS_GRANULARITY_DAILY   GetProjectCostsParamsGranularity = "daily"
	GET_PROJECT_COSTS_PARAMS_GRANULARITY_MONTHLY GetProjectCostsParamsGranularity = "monthly"
	GET_PROJECT_COSTS_PARAMS_GRANULARITY_NONE    GetProjectCostsParamsGranularity = "none"
	GET_PROJECT_COSTS_PARAMS_GRANULARITY_WEEKLY  GetProjectCostsParamsGranularity = "weekly"
	GET_PROJECT_COSTS_PARAMS_GRANULARITY_YEARLY  GetProjectCostsParamsGranularity = "yearly"
)

// Defines values for GetProjectCostsParamsAccept.
const (
	GET_PROJECT_COSTS_PARAMS_ACCEPT_APPLICATION_JSON GetProjectCostsParamsAccept = "application/json"
	GET_PROJECT_COSTS_PARAMS_ACCEPT_TEXT_CSV         GetProjectCostsParamsAccept = "text/csv"
)

// Defines values for GetForecastCustomerAccountParamsGranularity.
const (
	GET_FORECAST_CUSTOMER_ACCOUNT_PARAMS_GRANULARITY_DAILY   GetForecastCustomerAccountParamsGranularity = "daily"
	GET_FORECAST_CUSTOMER_ACCOUNT_PARAMS_GRANULARITY_MONTHLY GetForecastCustomerAccountParamsGranularity = "monthly"
	GET_FORECAST_CUSTOMER_ACCOUNT_PARAMS_GRANULARITY_NONE    GetForecastCustomerAccountParamsGranularity = "none"
	GET_FORECAST_CUSTOMER_ACCOUNT_PARAMS_GRANULARITY_WEEKLY  GetForecastCustomerAccountParamsGranularity = "weekly"
)

// Defines values for GetForecastCustomerAccountParamsAccept.
const (
	GET_FORECAST_CUSTOMER_ACCOUNT_PARAMS_ACCEPT_APPLICATION_JSON GetForecastCustomerAccountParamsAccept = "application/json"
	GET_FORECAST_CUSTOMER_ACCOUNT_PARAMS_ACCEPT_TEXT_CSV         GetForecastCustomerAccountParamsAccept = "text/csv"
)

// GetCostsForAllProjectsInCustomerAccountParams defines parameters for GetCostsForAllProjectsInCustomerAccount.
type GetCostsForAllProjectsInCustomerAccountParams struct {
	// From Start date (including)
	From openapi_types.Date `form:"from" json:"from"`

	// To End date (including)
	To openapi_types.Date `form:"to" json:"to"`

	// Depth Depth of desired cost information. "project" provides costs grouped by project, without services. "service" provides costs separated on service level.
	Depth *GetCostsForAllProjectsInCustomerAccountParamsDepth `form:"depth,omitempty" json:"depth,omitempty"`

	// Granularity Define granularity of costs – Default is "none" which does NOT include detailed report data.
	//
	// If "monthly", "weekly" or "yearly" is requested, the "from" parameter SHOULD be the first day and the "to" parameter SHOULD be the last day of that time period.
	// If not, they are normalized accordingly.
	//
	// If "daily" is requested, the date range defined by "from" and "to" MUST NOT be longer than 92 days.
	Granularity *GetCostsForAllProjectsInCustomerAccountParamsGranularity `form:"granularity,omitempty" json:"granularity,omitempty"`

	// IncludeZeroCosts Whether costs of 0 should be included in the response
	IncludeZeroCosts *bool `form:"includeZeroCosts,omitempty" json:"includeZeroCosts,omitempty"`

	// Accept Desired content type
	Accept *GetCostsForAllProjectsInCustomerAccountParamsAccept `json:"Accept,omitempty"`
}

// GetCostsForAllProjectsInCustomerAccountParamsDepth defines parameters for GetCostsForAllProjectsInCustomerAccount.
type GetCostsForAllProjectsInCustomerAccountParamsDepth string

// GetCostsForAllProjectsInCustomerAccountParamsGranularity defines parameters for GetCostsForAllProjectsInCustomerAccount.
type GetCostsForAllProjectsInCustomerAccountParamsGranularity string

// GetCostsForAllProjectsInCustomerAccountParamsAccept defines parameters for GetCostsForAllProjectsInCustomerAccount.
type GetCostsForAllProjectsInCustomerAccountParamsAccept string

// GetCostsForAllProjectsInAllSubCustomerAccountsParams defines parameters for GetCostsForAllProjectsInAllSubCustomerAccounts.
type GetCostsForAllProjectsInAllSubCustomerAccountsParams struct {
	// From Start date (including)
	From openapi_types.Date `form:"from" json:"from"`

	// To End date (including)
	To openapi_types.Date `form:"to" json:"to"`

	// Depth Depth of desired cost information. "project" provides costs grouped by project, without services. "service" provides costs separated on service level.
	Depth *GetCostsForAllProjectsInAllSubCustomerAccountsParamsDepth `form:"depth,omitempty" json:"depth,omitempty"`

	// Granularity Define granularity of costs – Default is "none" which does NOT include detailed report data.
	//
	// If "monthly", "weekly" or "yearly" is requested, the "from" parameter SHOULD be the first day and the "to" parameter SHOULD be the last day of that time period.
	// If not, they are normalized accordingly.
	//
	// If "daily" is requested, the date range defined by "from" and "to" MUST NOT be longer than 92 days.
	Granularity *GetCostsForAllProjectsInAllSubCustomerAccountsParamsGranularity `form:"granularity,omitempty" json:"granularity,omitempty"`

	// IncludeZeroCosts Whether costs of 0 should be included in the response
	IncludeZeroCosts *bool `form:"includeZeroCosts,omitempty" json:"includeZeroCosts,omitempty"`

	// Accept Desired content type
	Accept *GetCostsForAllProjectsInAllSubCustomerAccountsParamsAccept `json:"Accept,omitempty"`
}

// GetCostsForAllProjectsInAllSubCustomerAccountsParamsDepth defines parameters for GetCostsForAllProjectsInAllSubCustomerAccounts.
type GetCostsForAllProjectsInAllSubCustomerAccountsParamsDepth string

// GetCostsForAllProjectsInAllSubCustomerAccountsParamsGranularity defines parameters for GetCostsForAllProjectsInAllSubCustomerAccounts.
type GetCostsForAllProjectsInAllSubCustomerAccountsParamsGranularity string

// GetCostsForAllProjectsInAllSubCustomerAccountsParamsAccept defines parameters for GetCostsForAllProjectsInAllSubCustomerAccounts.
type GetCostsForAllProjectsInAllSubCustomerAccountsParamsAccept string

// GetProjectCostsParams defines parameters for GetProjectCosts.
type GetProjectCostsParams struct {
	// From Start date (including)
	From openapi_types.Date `form:"from" json:"from"`

	// To End date (including)
	To openapi_types.Date `form:"to" json:"to"`

	// Depth Depth of desired cost information. "project" provides costs grouped by project, without services. "service" provides costs separated on service level.
	Depth *GetProjectCostsParamsDepth `form:"depth,omitempty" json:"depth,omitempty"`

	// Granularity Define granularity of costs – Default is "none" which does NOT include detailed report data.
	//
	// If "monthly", "weekly" or "yearly" is requested, the "from" parameter SHOULD be the first day and the "to" parameter SHOULD be the last day of that time period.
	// If not, they are normalized accordingly.
	//
	// If "daily" is requested, the date range defined by "from" and "to" MUST NOT be longer than 92 days.
	Granularity *GetProjectCostsParamsGranularity `form:"granularity,omitempty" json:"granularity,omitempty"`

	// IncludeZeroCosts Whether costs of 0 should be included in the response
	IncludeZeroCosts *bool `form:"includeZeroCosts,omitempty" json:"includeZeroCosts,omitempty"`

	// Accept Desired content type
	Accept *GetProjectCostsParamsAccept `json:"Accept,omitempty"`
}

// GetProjectCostsParamsDepth defines parameters for GetProjectCosts.
type GetProjectCostsParamsDepth string

// GetProjectCostsParamsGranularity defines parameters for GetProjectCosts.
type GetProjectCostsParamsGranularity string

// GetProjectCostsParamsAccept defines parameters for GetProjectCosts.
type GetProjectCostsParamsAccept string

// GetForecastCustomerAccountParams defines parameters for GetForecastCustomerAccount.
type GetForecastCustomerAccountParams struct {
	// From Start date (including)
	From openapi_types.Date `form:"from" json:"from"`

	// To End date (including), maximum 3 months in the future
	To openapi_types.Date `form:"to" json:"to"`

	// Granularity Define granularity of costs – Default is "none" which does NOT include detailed report data.
	//
	// If "monthly" or "weekly" is requested, the "from" parameter SHOULD be the first day and the "to" parameter SHOULD be the last day of that time period.
	// If not, they are normalized accordingly.
	//
	// If "daily" is requested, the date range defined by "from" and "to" MUST NOT be longer than 92 days.
	Granularity *GetForecastCustomerAccountParamsGranularity `form:"granularity,omitempty" json:"granularity,omitempty"`

	// Accept Desired content type
	Accept *GetForecastCustomerAccountParamsAccept `json:"Accept,omitempty"`
}

// GetForecastCustomerAccountParamsGranularity defines parameters for GetForecastCustomerAccount.
type GetForecastCustomerAccountParamsGranularity string

// GetForecastCustomerAccountParamsAccept defines parameters for GetForecastCustomerAccount.
type GetForecastCustomerAccountParamsAccept string

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client common.Client
}

// Creates a new Client, with reasonable defaults
func NewClient(server string, httpClient common.Client) *Client {
	// create a client with sane default values
	client := Client{
		Server: server,
		Client: httpClient,
	}
	return &client
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetCostsForAllProjectsInCustomerAccount request
	GetCostsForAllProjectsInCustomerAccount(ctx context.Context, customerAccountId openapi_types.UUID, params *GetCostsForAllProjectsInCustomerAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCostsForAllProjectsInAllSubCustomerAccounts request
	GetCostsForAllProjectsInAllSubCustomerAccounts(ctx context.Context, customerAccountId openapi_types.UUID, params *GetCostsForAllProjectsInAllSubCustomerAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectCosts request
	GetProjectCosts(ctx context.Context, customerAccountId openapi_types.UUID, projectId openapi_types.UUID, params *GetProjectCostsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForecastCustomerAccount request
	GetForecastCustomerAccount(ctx context.Context, customerAccountId openapi_types.UUID, params *GetForecastCustomerAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetCostsForAllProjectsInCustomerAccount(ctx context.Context, customerAccountId openapi_types.UUID, params *GetCostsForAllProjectsInCustomerAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCostsForAllProjectsInCustomerAccountRequest(ctx, c.Server, customerAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCostsForAllProjectsInAllSubCustomerAccounts(ctx context.Context, customerAccountId openapi_types.UUID, params *GetCostsForAllProjectsInAllSubCustomerAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCostsForAllProjectsInAllSubCustomerAccountsRequest(ctx, c.Server, customerAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectCosts(ctx context.Context, customerAccountId openapi_types.UUID, projectId openapi_types.UUID, params *GetProjectCostsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectCostsRequest(ctx, c.Server, customerAccountId, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetForecastCustomerAccount(ctx context.Context, customerAccountId openapi_types.UUID, params *GetForecastCustomerAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForecastCustomerAccountRequest(ctx, c.Server, customerAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetCostsForAllProjectsInCustomerAccountRequest generates requests for GetCostsForAllProjectsInCustomerAccount
func NewGetCostsForAllProjectsInCustomerAccountRequest(ctx context.Context, server string, customerAccountId openapi_types.UUID, params *GetCostsForAllProjectsInCustomerAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerAccountId", runtime.ParamLocationPath, customerAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/costs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Depth != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Granularity != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "granularity", runtime.ParamLocationQuery, *params.Granularity); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeZeroCosts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeZeroCosts", runtime.ParamLocationQuery, *params.IncludeZeroCosts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Accept != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam0)
	}

	return req, nil
}

// NewGetCostsForAllProjectsInAllSubCustomerAccountsRequest generates requests for GetCostsForAllProjectsInAllSubCustomerAccounts
func NewGetCostsForAllProjectsInAllSubCustomerAccountsRequest(ctx context.Context, server string, customerAccountId openapi_types.UUID, params *GetCostsForAllProjectsInAllSubCustomerAccountsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerAccountId", runtime.ParamLocationPath, customerAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/costs/%s/customers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Depth != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Granularity != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "granularity", runtime.ParamLocationQuery, *params.Granularity); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeZeroCosts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeZeroCosts", runtime.ParamLocationQuery, *params.IncludeZeroCosts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Accept != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam0)
	}

	return req, nil
}

// NewGetProjectCostsRequest generates requests for GetProjectCosts
func NewGetProjectCostsRequest(ctx context.Context, server string, customerAccountId openapi_types.UUID, projectId openapi_types.UUID, params *GetProjectCostsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerAccountId", runtime.ParamLocationPath, customerAccountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/costs/%s/projects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Depth != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Granularity != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "granularity", runtime.ParamLocationQuery, *params.Granularity); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeZeroCosts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeZeroCosts", runtime.ParamLocationQuery, *params.IncludeZeroCosts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Accept != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam0)
	}

	return req, nil
}

// NewGetForecastCustomerAccountRequest generates requests for GetForecastCustomerAccount
func NewGetForecastCustomerAccountRequest(ctx context.Context, server string, customerAccountId openapi_types.UUID, params *GetForecastCustomerAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerAccountId", runtime.ParamLocationPath, customerAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/forecast/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Granularity != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "granularity", runtime.ParamLocationQuery, *params.Granularity); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Accept != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam0)
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, httpClient common.Client) *ClientWithResponses {
	return &ClientWithResponses{NewClient(server, httpClient)}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetCostsForAllProjectsInCustomerAccount request
	GetCostsForAllProjectsInCustomerAccountWithResponse(ctx context.Context, customerAccountId openapi_types.UUID, params *GetCostsForAllProjectsInCustomerAccountParams, reqEditors ...RequestEditorFn) (*GetCostsForAllProjectsInCustomerAccountResponse, error)

	// GetCostsForAllProjectsInAllSubCustomerAccounts request
	GetCostsForAllProjectsInAllSubCustomerAccountsWithResponse(ctx context.Context, customerAccountId openapi_types.UUID, params *GetCostsForAllProjectsInAllSubCustomerAccountsParams, reqEditors ...RequestEditorFn) (*GetCostsForAllProjectsInAllSubCustomerAccountsResponse, error)

	// GetProjectCosts request
	GetProjectCostsWithResponse(ctx context.Context, customerAccountId openapi_types.UUID, projectId openapi_types.UUID, params *GetProjectCostsParams, reqEditors ...RequestEditorFn) (*GetProjectCostsResponse, error)

	// GetForecastCustomerAccount request
	GetForecastCustomerAccountWithResponse(ctx context.Context, customerAccountId openapi_types.UUID, params *GetForecastCustomerAccountParams, reqEditors ...RequestEditorFn) (*GetForecastCustomerAccountResponse, error)
}

type GetCostsForAllProjectsInCustomerAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		CustomerAccountID openapi_types.UUID `json:"customerAccountId"`
		ProjectID         openapi_types.UUID `json:"projectId"`
		ProjectName       string             `json:"projectName"`

		// ReportData Detailed project costs which are ONLY included if granularity is provided AND depth is "project"
		ReportData *[]struct {
			// Charge Charge, value in cents
			Charge float64 `json:"charge"`

			// Discount Discount, value in cents
			Discount float64 `json:"discount"`

			// Quantity Quantity
			Quantity int32 `json:"quantity"`

			// TimePeriod Time period according to desired granularity
			TimePeriod struct {
				End   *openapi_types.Date `json:"end,omitempty"`
				Start *openapi_types.Date `json:"start,omitempty"`
			} `json:"timePeriod"`
		} `json:"reportData,omitempty"`

		// Services Total discount for all services and the whole requested date range (value in cents). Please see "depth" parameter for more details.
		Services *[]struct {
			// ReportData Detailed service costs which are ONLY included if granularity is provided
			ReportData *[]struct {
				// Charge Charge, value in cents
				Charge float64 `json:"charge"`

				// Discount Discount, value in cents
				Discount float64 `json:"discount"`

				// Quantity Quantity
				Quantity int32 `json:"quantity"`

				// TimePeriod Time period according to desired granularity
				TimePeriod struct {
					End   *openapi_types.Date `json:"end,omitempty"`
					Start *openapi_types.Date `json:"start,omitempty"`
				} `json:"timePeriod"`
			} `json:"reportData,omitempty"`

			// ServiceCategoryName Service category name
			ServiceCategoryName string `json:"serviceCategoryName"`

			// ServiceName Name of the service
			ServiceName string `json:"serviceName"`

			// Sku Service key
			Sku string `json:"sku"`

			// TotalCharge Total charge for the whole requested date range (value in cents)
			TotalCharge float64 `json:"totalCharge"`

			// TotalDiscount Total discount for the whole requested date range (value in cents)
			TotalDiscount float64 `json:"totalDiscount"`

			// TotalQuantity Total quantity
			TotalQuantity int32 `json:"totalQuantity"`

			// UnitLabel Label for unit
			UnitLabel string `json:"unitLabel"`
		} `json:"services,omitempty"`

		// TotalCharge Total charge for all services and the whole requested date range (value in cents)
		TotalCharge float64 `json:"totalCharge"`

		// TotalDiscount Total discount for all services and the whole requested date range (value in cents)
		TotalDiscount float64 `json:"totalDiscount"`
	}
	JSONDefault *struct {
		Code    string  `json:"code"`
		Message *string `json:"message,omitempty"`
	}
	HasError error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetCostsForAllProjectsInCustomerAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCostsForAllProjectsInCustomerAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCostsForAllProjectsInAllSubCustomerAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		CustomerAccountID openapi_types.UUID `json:"customerAccountId"`
		ProjectID         openapi_types.UUID `json:"projectId"`
		ProjectName       string             `json:"projectName"`

		// ReportData Detailed project costs which are ONLY included if granularity is provided AND depth is "project"
		ReportData *[]struct {
			// Charge Charge, value in cents
			Charge float64 `json:"charge"`

			// Discount Discount, value in cents
			Discount float64 `json:"discount"`

			// Quantity Quantity
			Quantity int32 `json:"quantity"`

			// TimePeriod Time period according to desired granularity
			TimePeriod struct {
				End   *openapi_types.Date `json:"end,omitempty"`
				Start *openapi_types.Date `json:"start,omitempty"`
			} `json:"timePeriod"`
		} `json:"reportData,omitempty"`

		// Services Total discount for all services and the whole requested date range (value in cents). Please see "depth" parameter for more details.
		Services *[]struct {
			// ReportData Detailed service costs which are ONLY included if granularity is provided
			ReportData *[]struct {
				// Charge Charge, value in cents
				Charge float64 `json:"charge"`

				// Discount Discount, value in cents
				Discount float64 `json:"discount"`

				// Quantity Quantity
				Quantity int32 `json:"quantity"`

				// TimePeriod Time period according to desired granularity
				TimePeriod struct {
					End   *openapi_types.Date `json:"end,omitempty"`
					Start *openapi_types.Date `json:"start,omitempty"`
				} `json:"timePeriod"`
			} `json:"reportData,omitempty"`

			// ServiceCategoryName Service category name
			ServiceCategoryName string `json:"serviceCategoryName"`

			// ServiceName Name of the service
			ServiceName string `json:"serviceName"`

			// Sku Service key
			Sku string `json:"sku"`

			// TotalCharge Total charge for the whole requested date range (value in cents)
			TotalCharge float64 `json:"totalCharge"`

			// TotalDiscount Total discount for the whole requested date range (value in cents)
			TotalDiscount float64 `json:"totalDiscount"`

			// TotalQuantity Total quantity
			TotalQuantity int32 `json:"totalQuantity"`

			// UnitLabel Label for unit
			UnitLabel string `json:"unitLabel"`
		} `json:"services,omitempty"`

		// TotalCharge Total charge for all services and the whole requested date range (value in cents)
		TotalCharge float64 `json:"totalCharge"`

		// TotalDiscount Total discount for all services and the whole requested date range (value in cents)
		TotalDiscount float64 `json:"totalDiscount"`
	}
	JSONDefault *struct {
		Code    string  `json:"code"`
		Message *string `json:"message,omitempty"`
	}
	HasError error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetCostsForAllProjectsInAllSubCustomerAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCostsForAllProjectsInAllSubCustomerAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectCostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CustomerAccountID openapi_types.UUID `json:"customerAccountId"`
		ProjectID         openapi_types.UUID `json:"projectId"`
		ProjectName       string             `json:"projectName"`

		// ReportData Detailed project costs which are ONLY included if granularity is provided AND depth is "project"
		ReportData *[]struct {
			// Charge Charge, value in cents
			Charge float64 `json:"charge"`

			// Discount Discount, value in cents
			Discount float64 `json:"discount"`

			// Quantity Quantity
			Quantity int32 `json:"quantity"`

			// TimePeriod Time period according to desired granularity
			TimePeriod struct {
				End   *openapi_types.Date `json:"end,omitempty"`
				Start *openapi_types.Date `json:"start,omitempty"`
			} `json:"timePeriod"`
		} `json:"reportData,omitempty"`

		// Services Total discount for all services and the whole requested date range (value in cents). Please see "depth" parameter for more details.
		Services *[]struct {
			// ReportData Detailed service costs which are ONLY included if granularity is provided
			ReportData *[]struct {
				// Charge Charge, value in cents
				Charge float64 `json:"charge"`

				// Discount Discount, value in cents
				Discount float64 `json:"discount"`

				// Quantity Quantity
				Quantity int32 `json:"quantity"`

				// TimePeriod Time period according to desired granularity
				TimePeriod struct {
					End   *openapi_types.Date `json:"end,omitempty"`
					Start *openapi_types.Date `json:"start,omitempty"`
				} `json:"timePeriod"`
			} `json:"reportData,omitempty"`

			// ServiceCategoryName Service category name
			ServiceCategoryName string `json:"serviceCategoryName"`

			// ServiceName Name of the service
			ServiceName string `json:"serviceName"`

			// Sku Service key
			Sku string `json:"sku"`

			// TotalCharge Total charge for the whole requested date range (value in cents)
			TotalCharge float64 `json:"totalCharge"`

			// TotalDiscount Total discount for the whole requested date range (value in cents)
			TotalDiscount float64 `json:"totalDiscount"`

			// TotalQuantity Total quantity
			TotalQuantity int32 `json:"totalQuantity"`

			// UnitLabel Label for unit
			UnitLabel string `json:"unitLabel"`
		} `json:"services,omitempty"`

		// TotalCharge Total charge for all services and the whole requested date range (value in cents)
		TotalCharge float64 `json:"totalCharge"`

		// TotalDiscount Total discount for all services and the whole requested date range (value in cents)
		TotalDiscount float64 `json:"totalDiscount"`
	}
	JSONDefault *struct {
		Code    string  `json:"code"`
		Message *string `json:"message,omitempty"`
	}
	HasError error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetProjectCostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectCostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForecastCustomerAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		CustomerAccountID openapi_types.UUID `json:"customerAccountId"`
		ProjectID         openapi_types.UUID `json:"projectId"`
		ProjectName       string             `json:"projectName"`

		// ReportData Detailed forcasted project costs which are ONLY included if granularity is provided AND depth is "project"
		ReportData *[]struct {
			// Charge Forecasted charge, value in cents
			Charge float64 `json:"charge"`

			// TimePeriod Time period according to desired granularity
			TimePeriod struct {
				End   *openapi_types.Date `json:"end,omitempty"`
				Start *openapi_types.Date `json:"start,omitempty"`
			} `json:"timePeriod"`
		} `json:"reportData,omitempty"`

		// TotalCharge Total forecasted charge for all services and the whole requested date range (value in cents)
		TotalCharge float64 `json:"totalCharge"`
	}
	JSONDefault *struct {
		Code    string  `json:"code"`
		Message *string `json:"message,omitempty"`
	}
	HasError error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetForecastCustomerAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForecastCustomerAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetCostsForAllProjectsInCustomerAccountWithResponse request returning *GetCostsForAllProjectsInCustomerAccountResponse
func (c *ClientWithResponses) GetCostsForAllProjectsInCustomerAccountWithResponse(ctx context.Context, customerAccountId openapi_types.UUID, params *GetCostsForAllProjectsInCustomerAccountParams, reqEditors ...RequestEditorFn) (*GetCostsForAllProjectsInCustomerAccountResponse, error) {
	rsp, err := c.GetCostsForAllProjectsInCustomerAccount(ctx, customerAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetCostsForAllProjectsInCustomerAccountResponse(rsp)
}

// GetCostsForAllProjectsInAllSubCustomerAccountsWithResponse request returning *GetCostsForAllProjectsInAllSubCustomerAccountsResponse
func (c *ClientWithResponses) GetCostsForAllProjectsInAllSubCustomerAccountsWithResponse(ctx context.Context, customerAccountId openapi_types.UUID, params *GetCostsForAllProjectsInAllSubCustomerAccountsParams, reqEditors ...RequestEditorFn) (*GetCostsForAllProjectsInAllSubCustomerAccountsResponse, error) {
	rsp, err := c.GetCostsForAllProjectsInAllSubCustomerAccounts(ctx, customerAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetCostsForAllProjectsInAllSubCustomerAccountsResponse(rsp)
}

// GetProjectCostsWithResponse request returning *GetProjectCostsResponse
func (c *ClientWithResponses) GetProjectCostsWithResponse(ctx context.Context, customerAccountId openapi_types.UUID, projectId openapi_types.UUID, params *GetProjectCostsParams, reqEditors ...RequestEditorFn) (*GetProjectCostsResponse, error) {
	rsp, err := c.GetProjectCosts(ctx, customerAccountId, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetProjectCostsResponse(rsp)
}

// GetForecastCustomerAccountWithResponse request returning *GetForecastCustomerAccountResponse
func (c *ClientWithResponses) GetForecastCustomerAccountWithResponse(ctx context.Context, customerAccountId openapi_types.UUID, params *GetForecastCustomerAccountParams, reqEditors ...RequestEditorFn) (*GetForecastCustomerAccountResponse, error) {
	rsp, err := c.GetForecastCustomerAccount(ctx, customerAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetForecastCustomerAccountResponse(rsp)
}

// ParseGetCostsForAllProjectsInCustomerAccountResponse parses an HTTP response from a GetCostsForAllProjectsInCustomerAccountWithResponse call
func (c *ClientWithResponses) ParseGetCostsForAllProjectsInCustomerAccountResponse(rsp *http.Response) (*GetCostsForAllProjectsInCustomerAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCostsForAllProjectsInCustomerAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			CustomerAccountID openapi_types.UUID `json:"customerAccountId"`
			ProjectID         openapi_types.UUID `json:"projectId"`
			ProjectName       string             `json:"projectName"`

			// ReportData Detailed project costs which are ONLY included if granularity is provided AND depth is "project"
			ReportData *[]struct {
				// Charge Charge, value in cents
				Charge float64 `json:"charge"`

				// Discount Discount, value in cents
				Discount float64 `json:"discount"`

				// Quantity Quantity
				Quantity int32 `json:"quantity"`

				// TimePeriod Time period according to desired granularity
				TimePeriod struct {
					End   *openapi_types.Date `json:"end,omitempty"`
					Start *openapi_types.Date `json:"start,omitempty"`
				} `json:"timePeriod"`
			} `json:"reportData,omitempty"`

			// Services Total discount for all services and the whole requested date range (value in cents). Please see "depth" parameter for more details.
			Services *[]struct {
				// ReportData Detailed service costs which are ONLY included if granularity is provided
				ReportData *[]struct {
					// Charge Charge, value in cents
					Charge float64 `json:"charge"`

					// Discount Discount, value in cents
					Discount float64 `json:"discount"`

					// Quantity Quantity
					Quantity int32 `json:"quantity"`

					// TimePeriod Time period according to desired granularity
					TimePeriod struct {
						End   *openapi_types.Date `json:"end,omitempty"`
						Start *openapi_types.Date `json:"start,omitempty"`
					} `json:"timePeriod"`
				} `json:"reportData,omitempty"`

				// ServiceCategoryName Service category name
				ServiceCategoryName string `json:"serviceCategoryName"`

				// ServiceName Name of the service
				ServiceName string `json:"serviceName"`

				// Sku Service key
				Sku string `json:"sku"`

				// TotalCharge Total charge for the whole requested date range (value in cents)
				TotalCharge float64 `json:"totalCharge"`

				// TotalDiscount Total discount for the whole requested date range (value in cents)
				TotalDiscount float64 `json:"totalDiscount"`

				// TotalQuantity Total quantity
				TotalQuantity int32 `json:"totalQuantity"`

				// UnitLabel Label for unit
				UnitLabel string `json:"unitLabel"`
			} `json:"services,omitempty"`

			// TotalCharge Total charge for all services and the whole requested date range (value in cents)
			TotalCharge float64 `json:"totalCharge"`

			// TotalDiscount Total discount for all services and the whole requested date range (value in cents)
			TotalDiscount float64 `json:"totalDiscount"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    string  `json:"code"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetCostsForAllProjectsInAllSubCustomerAccountsResponse parses an HTTP response from a GetCostsForAllProjectsInAllSubCustomerAccountsWithResponse call
func (c *ClientWithResponses) ParseGetCostsForAllProjectsInAllSubCustomerAccountsResponse(rsp *http.Response) (*GetCostsForAllProjectsInAllSubCustomerAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCostsForAllProjectsInAllSubCustomerAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			CustomerAccountID openapi_types.UUID `json:"customerAccountId"`
			ProjectID         openapi_types.UUID `json:"projectId"`
			ProjectName       string             `json:"projectName"`

			// ReportData Detailed project costs which are ONLY included if granularity is provided AND depth is "project"
			ReportData *[]struct {
				// Charge Charge, value in cents
				Charge float64 `json:"charge"`

				// Discount Discount, value in cents
				Discount float64 `json:"discount"`

				// Quantity Quantity
				Quantity int32 `json:"quantity"`

				// TimePeriod Time period according to desired granularity
				TimePeriod struct {
					End   *openapi_types.Date `json:"end,omitempty"`
					Start *openapi_types.Date `json:"start,omitempty"`
				} `json:"timePeriod"`
			} `json:"reportData,omitempty"`

			// Services Total discount for all services and the whole requested date range (value in cents). Please see "depth" parameter for more details.
			Services *[]struct {
				// ReportData Detailed service costs which are ONLY included if granularity is provided
				ReportData *[]struct {
					// Charge Charge, value in cents
					Charge float64 `json:"charge"`

					// Discount Discount, value in cents
					Discount float64 `json:"discount"`

					// Quantity Quantity
					Quantity int32 `json:"quantity"`

					// TimePeriod Time period according to desired granularity
					TimePeriod struct {
						End   *openapi_types.Date `json:"end,omitempty"`
						Start *openapi_types.Date `json:"start,omitempty"`
					} `json:"timePeriod"`
				} `json:"reportData,omitempty"`

				// ServiceCategoryName Service category name
				ServiceCategoryName string `json:"serviceCategoryName"`

				// ServiceName Name of the service
				ServiceName string `json:"serviceName"`

				// Sku Service key
				Sku string `json:"sku"`

				// TotalCharge Total charge for the whole requested date range (value in cents)
				TotalCharge float64 `json:"totalCharge"`

				// TotalDiscount Total discount for the whole requested date range (value in cents)
				TotalDiscount float64 `json:"totalDiscount"`

				// TotalQuantity Total quantity
				TotalQuantity int32 `json:"totalQuantity"`

				// UnitLabel Label for unit
				UnitLabel string `json:"unitLabel"`
			} `json:"services,omitempty"`

			// TotalCharge Total charge for all services and the whole requested date range (value in cents)
			TotalCharge float64 `json:"totalCharge"`

			// TotalDiscount Total discount for all services and the whole requested date range (value in cents)
			TotalDiscount float64 `json:"totalDiscount"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    string  `json:"code"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetProjectCostsResponse parses an HTTP response from a GetProjectCostsWithResponse call
func (c *ClientWithResponses) ParseGetProjectCostsResponse(rsp *http.Response) (*GetProjectCostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectCostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CustomerAccountID openapi_types.UUID `json:"customerAccountId"`
			ProjectID         openapi_types.UUID `json:"projectId"`
			ProjectName       string             `json:"projectName"`

			// ReportData Detailed project costs which are ONLY included if granularity is provided AND depth is "project"
			ReportData *[]struct {
				// Charge Charge, value in cents
				Charge float64 `json:"charge"`

				// Discount Discount, value in cents
				Discount float64 `json:"discount"`

				// Quantity Quantity
				Quantity int32 `json:"quantity"`

				// TimePeriod Time period according to desired granularity
				TimePeriod struct {
					End   *openapi_types.Date `json:"end,omitempty"`
					Start *openapi_types.Date `json:"start,omitempty"`
				} `json:"timePeriod"`
			} `json:"reportData,omitempty"`

			// Services Total discount for all services and the whole requested date range (value in cents). Please see "depth" parameter for more details.
			Services *[]struct {
				// ReportData Detailed service costs which are ONLY included if granularity is provided
				ReportData *[]struct {
					// Charge Charge, value in cents
					Charge float64 `json:"charge"`

					// Discount Discount, value in cents
					Discount float64 `json:"discount"`

					// Quantity Quantity
					Quantity int32 `json:"quantity"`

					// TimePeriod Time period according to desired granularity
					TimePeriod struct {
						End   *openapi_types.Date `json:"end,omitempty"`
						Start *openapi_types.Date `json:"start,omitempty"`
					} `json:"timePeriod"`
				} `json:"reportData,omitempty"`

				// ServiceCategoryName Service category name
				ServiceCategoryName string `json:"serviceCategoryName"`

				// ServiceName Name of the service
				ServiceName string `json:"serviceName"`

				// Sku Service key
				Sku string `json:"sku"`

				// TotalCharge Total charge for the whole requested date range (value in cents)
				TotalCharge float64 `json:"totalCharge"`

				// TotalDiscount Total discount for the whole requested date range (value in cents)
				TotalDiscount float64 `json:"totalDiscount"`

				// TotalQuantity Total quantity
				TotalQuantity int32 `json:"totalQuantity"`

				// UnitLabel Label for unit
				UnitLabel string `json:"unitLabel"`
			} `json:"services,omitempty"`

			// TotalCharge Total charge for all services and the whole requested date range (value in cents)
			TotalCharge float64 `json:"totalCharge"`

			// TotalDiscount Total discount for all services and the whole requested date range (value in cents)
			TotalDiscount float64 `json:"totalDiscount"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    string  `json:"code"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSONDefault = &dest

	case rsp.StatusCode == 200:
	// Content-type (text/csv) unsupported

	case true:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetForecastCustomerAccountResponse parses an HTTP response from a GetForecastCustomerAccountWithResponse call
func (c *ClientWithResponses) ParseGetForecastCustomerAccountResponse(rsp *http.Response) (*GetForecastCustomerAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForecastCustomerAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			CustomerAccountID openapi_types.UUID `json:"customerAccountId"`
			ProjectID         openapi_types.UUID `json:"projectId"`
			ProjectName       string             `json:"projectName"`

			// ReportData Detailed forcasted project costs which are ONLY included if granularity is provided AND depth is "project"
			ReportData *[]struct {
				// Charge Forecasted charge, value in cents
				Charge float64 `json:"charge"`

				// TimePeriod Time period according to desired granularity
				TimePeriod struct {
					End   *openapi_types.Date `json:"end,omitempty"`
					Start *openapi_types.Date `json:"start,omitempty"`
				} `json:"timePeriod"`
			} `json:"reportData,omitempty"`

			// TotalCharge Total forecasted charge for all services and the whole requested date range (value in cents)
			TotalCharge float64 `json:"totalCharge"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    string  `json:"code"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
