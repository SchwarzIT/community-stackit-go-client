// Package costs provides primitives to interact with the openapi HTTP API.
//
// Code generated by dev.azure.com/schwarzit/schwarzit.odj.core/_git/stackit-client-generator.git version v1.0.23 DO NOT EDIT.
package costs

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/pkg/errors"

	contracts "github.com/SchwarzIT/community-stackit-go-client/internal/contracts"
	"github.com/SchwarzIT/community-stackit-go-client/internal/helpers/runtime"
	openapiTypes "github.com/SchwarzIT/community-stackit-go-client/internal/helpers/types"
	"github.com/SchwarzIT/community-stackit-go-client/pkg/validate"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for GetCostsForAllProjectsInCustomerAccountParamsDepth.
const (
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_DEPTH_AUTO    GetCostsForAllProjectsInCustomerAccountParamsDepth = "auto"
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_DEPTH_PROJECT GetCostsForAllProjectsInCustomerAccountParamsDepth = "project"
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_DEPTH_SERVICE GetCostsForAllProjectsInCustomerAccountParamsDepth = "service"
)

// Defines values for GetCostsForAllProjectsInCustomerAccountParamsGranularity.
const (
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_GRANULARITY_DAILY   GetCostsForAllProjectsInCustomerAccountParamsGranularity = "daily"
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_GRANULARITY_MONTHLY GetCostsForAllProjectsInCustomerAccountParamsGranularity = "monthly"
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_GRANULARITY_NONE    GetCostsForAllProjectsInCustomerAccountParamsGranularity = "none"
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_GRANULARITY_WEEKLY  GetCostsForAllProjectsInCustomerAccountParamsGranularity = "weekly"
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_GRANULARITY_YEARLY  GetCostsForAllProjectsInCustomerAccountParamsGranularity = "yearly"
)

// Defines values for GetCostsForAllProjectsInCustomerAccountParamsAccept.
const (
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_ACCEPT_APPLICATION_JSON GetCostsForAllProjectsInCustomerAccountParamsAccept = "application/json"
	GET_COSTS_FOR_ALL_PROJECTS_IN_CUSTOMER_ACCOUNT_PARAMS_ACCEPT_TEXT_CSV         GetCostsForAllProjectsInCustomerAccountParamsAccept = "text/csv"
)

// Defines values for GetCostsForAllProjectsInAllSubCustomerAccountsParamsDepth.
const (
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_DEPTH_AUTO    GetCostsForAllProjectsInAllSubCustomerAccountsParamsDepth = "auto"
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_DEPTH_PROJECT GetCostsForAllProjectsInAllSubCustomerAccountsParamsDepth = "project"
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_DEPTH_SERVICE GetCostsForAllProjectsInAllSubCustomerAccountsParamsDepth = "service"
)

// Defines values for GetCostsForAllProjectsInAllSubCustomerAccountsParamsGranularity.
const (
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_GRANULARITY_DAILY   GetCostsForAllProjectsInAllSubCustomerAccountsParamsGranularity = "daily"
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_GRANULARITY_MONTHLY GetCostsForAllProjectsInAllSubCustomerAccountsParamsGranularity = "monthly"
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_GRANULARITY_NONE    GetCostsForAllProjectsInAllSubCustomerAccountsParamsGranularity = "none"
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_GRANULARITY_WEEKLY  GetCostsForAllProjectsInAllSubCustomerAccountsParamsGranularity = "weekly"
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_GRANULARITY_YEARLY  GetCostsForAllProjectsInAllSubCustomerAccountsParamsGranularity = "yearly"
)

// Defines values for GetCostsForAllProjectsInAllSubCustomerAccountsParamsAccept.
const (
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_ACCEPT_APPLICATION_JSON GetCostsForAllProjectsInAllSubCustomerAccountsParamsAccept = "application/json"
	GET_COSTS_FOR_ALL_PROJECTS_IN_ALL_SUB_CUSTOMER_ACCOUNTS_PARAMS_ACCEPT_TEXT_CSV         GetCostsForAllProjectsInAllSubCustomerAccountsParamsAccept = "text/csv"
)

// Defines values for GetProjectCostsParamsDepth.
const (
	AUTO    GetProjectCostsParamsDepth = "auto"
	PROJECT GetProjectCostsParamsDepth = "project"
	SERVICE GetProjectCostsParamsDepth = "service"
)

// Defines values for GetProjectCostsParamsGranularity.
const (
	GET_PROJECT_COSTS_PARAMS_GRANULARITY_DAILY   GetProjectCostsParamsGranularity = "daily"
	GET_PROJECT_COSTS_PARAMS_GRANULARITY_MONTHLY GetProjectCostsParamsGranularity = "monthly"
	GET_PROJECT_COSTS_PARAMS_GRANULARITY_NONE    GetProjectCostsParamsGranularity = "none"
	GET_PROJECT_COSTS_PARAMS_GRANULARITY_WEEKLY  GetProjectCostsParamsGranularity = "weekly"
	GET_PROJECT_COSTS_PARAMS_GRANULARITY_YEARLY  GetProjectCostsParamsGranularity = "yearly"
)

// Defines values for GetProjectCostsParamsAccept.
const (
	GET_PROJECT_COSTS_PARAMS_ACCEPT_APPLICATION_JSON GetProjectCostsParamsAccept = "application/json"
	GET_PROJECT_COSTS_PARAMS_ACCEPT_TEXT_CSV         GetProjectCostsParamsAccept = "text/csv"
)

// Defines values for GetForecastCustomerAccountParamsGranularity.
const (
	GET_FORECAST_CUSTOMER_ACCOUNT_PARAMS_GRANULARITY_DAILY   GetForecastCustomerAccountParamsGranularity = "daily"
	GET_FORECAST_CUSTOMER_ACCOUNT_PARAMS_GRANULARITY_MONTHLY GetForecastCustomerAccountParamsGranularity = "monthly"
	GET_FORECAST_CUSTOMER_ACCOUNT_PARAMS_GRANULARITY_NONE    GetForecastCustomerAccountParamsGranularity = "none"
	GET_FORECAST_CUSTOMER_ACCOUNT_PARAMS_GRANULARITY_WEEKLY  GetForecastCustomerAccountParamsGranularity = "weekly"
)

// Defines values for GetForecastCustomerAccountParamsAccept.
const (
	GET_FORECAST_CUSTOMER_ACCOUNT_PARAMS_ACCEPT_APPLICATION_JSON GetForecastCustomerAccountParamsAccept = "application/json"
	GET_FORECAST_CUSTOMER_ACCOUNT_PARAMS_ACCEPT_TEXT_CSV         GetForecastCustomerAccountParamsAccept = "text/csv"
)

// GetCostsForAllProjectsInCustomerAccountParams defines parameters for GetCostsForAllProjectsInCustomerAccount.
type GetCostsForAllProjectsInCustomerAccountParams struct {
	// From Start date (including)
	From openapiTypes.Date `form:"from" json:"from"`

	// To End date (including)
	To openapiTypes.Date `form:"to" json:"to"`

	// Depth Depth of desired cost information. "project" provides costs grouped by project, without services. "service" provides costs separated on service level.
	Depth *GetCostsForAllProjectsInCustomerAccountParamsDepth `form:"depth,omitempty" json:"depth,omitempty"`

	// Granularity Define granularity of costs – Default is "none" which does NOT include detailed report data.
	//
	// If "monthly", "weekly" or "yearly" is requested, the "from" parameter SHOULD be the first day and the "to" parameter SHOULD be the last day of that time period.
	// If not, they are normalized accordingly.
	//
	// If "daily" is requested, the date range defined by "from" and "to" MUST NOT be longer than 92 days.
	Granularity *GetCostsForAllProjectsInCustomerAccountParamsGranularity `form:"granularity,omitempty" json:"granularity,omitempty"`

	// IncludeZeroCosts Whether costs of 0 should be included in the response
	IncludeZeroCosts *bool `form:"includeZeroCosts,omitempty" json:"includeZeroCosts,omitempty"`

	// Accept Desired content type
	Accept *GetCostsForAllProjectsInCustomerAccountParamsAccept `json:"Accept,omitempty"`
}

// GetCostsForAllProjectsInCustomerAccountParamsDepth defines parameters for GetCostsForAllProjectsInCustomerAccount.
type GetCostsForAllProjectsInCustomerAccountParamsDepth string

// GetCostsForAllProjectsInCustomerAccountParamsGranularity defines parameters for GetCostsForAllProjectsInCustomerAccount.
type GetCostsForAllProjectsInCustomerAccountParamsGranularity string

// GetCostsForAllProjectsInCustomerAccountParamsAccept defines parameters for GetCostsForAllProjectsInCustomerAccount.
type GetCostsForAllProjectsInCustomerAccountParamsAccept string

// GetCostsForAllProjectsInAllSubCustomerAccountsParams defines parameters for GetCostsForAllProjectsInAllSubCustomerAccounts.
type GetCostsForAllProjectsInAllSubCustomerAccountsParams struct {
	// From Start date (including)
	From openapiTypes.Date `form:"from" json:"from"`

	// To End date (including)
	To openapiTypes.Date `form:"to" json:"to"`

	// Depth Depth of desired cost information. "project" provides costs grouped by project, without services. "service" provides costs separated on service level.
	Depth *GetCostsForAllProjectsInAllSubCustomerAccountsParamsDepth `form:"depth,omitempty" json:"depth,omitempty"`

	// Granularity Define granularity of costs – Default is "none" which does NOT include detailed report data.
	//
	// If "monthly", "weekly" or "yearly" is requested, the "from" parameter SHOULD be the first day and the "to" parameter SHOULD be the last day of that time period.
	// If not, they are normalized accordingly.
	//
	// If "daily" is requested, the date range defined by "from" and "to" MUST NOT be longer than 92 days.
	Granularity *GetCostsForAllProjectsInAllSubCustomerAccountsParamsGranularity `form:"granularity,omitempty" json:"granularity,omitempty"`

	// IncludeZeroCosts Whether costs of 0 should be included in the response
	IncludeZeroCosts *bool `form:"includeZeroCosts,omitempty" json:"includeZeroCosts,omitempty"`

	// Accept Desired content type
	Accept *GetCostsForAllProjectsInAllSubCustomerAccountsParamsAccept `json:"Accept,omitempty"`
}

// GetCostsForAllProjectsInAllSubCustomerAccountsParamsDepth defines parameters for GetCostsForAllProjectsInAllSubCustomerAccounts.
type GetCostsForAllProjectsInAllSubCustomerAccountsParamsDepth string

// GetCostsForAllProjectsInAllSubCustomerAccountsParamsGranularity defines parameters for GetCostsForAllProjectsInAllSubCustomerAccounts.
type GetCostsForAllProjectsInAllSubCustomerAccountsParamsGranularity string

// GetCostsForAllProjectsInAllSubCustomerAccountsParamsAccept defines parameters for GetCostsForAllProjectsInAllSubCustomerAccounts.
type GetCostsForAllProjectsInAllSubCustomerAccountsParamsAccept string

// GetProjectCostsParams defines parameters for GetProjectCosts.
type GetProjectCostsParams struct {
	// From Start date (including)
	From openapiTypes.Date `form:"from" json:"from"`

	// To End date (including)
	To openapiTypes.Date `form:"to" json:"to"`

	// Depth Depth of desired cost information. "project" provides costs grouped by project, without services. "service" provides costs separated on service level.
	Depth *GetProjectCostsParamsDepth `form:"depth,omitempty" json:"depth,omitempty"`

	// Granularity Define granularity of costs – Default is "none" which does NOT include detailed report data.
	//
	// If "monthly", "weekly" or "yearly" is requested, the "from" parameter SHOULD be the first day and the "to" parameter SHOULD be the last day of that time period.
	// If not, they are normalized accordingly.
	//
	// If "daily" is requested, the date range defined by "from" and "to" MUST NOT be longer than 92 days.
	Granularity *GetProjectCostsParamsGranularity `form:"granularity,omitempty" json:"granularity,omitempty"`

	// IncludeZeroCosts Whether costs of 0 should be included in the response
	IncludeZeroCosts *bool `form:"includeZeroCosts,omitempty" json:"includeZeroCosts,omitempty"`

	// Accept Desired content type
	Accept *GetProjectCostsParamsAccept `json:"Accept,omitempty"`
}

// GetProjectCostsParamsDepth defines parameters for GetProjectCosts.
type GetProjectCostsParamsDepth string

// GetProjectCostsParamsGranularity defines parameters for GetProjectCosts.
type GetProjectCostsParamsGranularity string

// GetProjectCostsParamsAccept defines parameters for GetProjectCosts.
type GetProjectCostsParamsAccept string

// GetForecastCustomerAccountParams defines parameters for GetForecastCustomerAccount.
type GetForecastCustomerAccountParams struct {
	// From Start date (including)
	From openapiTypes.Date `form:"from" json:"from"`

	// To End date (including), maximum 3 months in the future
	To openapiTypes.Date `form:"to" json:"to"`

	// Granularity Define granularity of costs – Default is "none" which does NOT include detailed report data.
	//
	// If "monthly" or "weekly" is requested, the "from" parameter SHOULD be the first day and the "to" parameter SHOULD be the last day of that time period.
	// If not, they are normalized accordingly.
	//
	// If "daily" is requested, the date range defined by "from" and "to" MUST NOT be longer than 92 days.
	Granularity *GetForecastCustomerAccountParamsGranularity `form:"granularity,omitempty" json:"granularity,omitempty"`

	// Accept Desired content type
	Accept *GetForecastCustomerAccountParamsAccept `json:"Accept,omitempty"`
}

// GetForecastCustomerAccountParamsGranularity defines parameters for GetForecastCustomerAccount.
type GetForecastCustomerAccountParamsGranularity string

// GetForecastCustomerAccountParamsAccept defines parameters for GetForecastCustomerAccount.
type GetForecastCustomerAccountParamsAccept string

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Client which conforms to the OpenAPI3 specification for this service.
type Client[K contracts.ClientFlowConfig] struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client contracts.ClientInterface[K]

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption[K contracts.ClientFlowConfig] func(*Client[K]) error

// NewRawClient creates a new Client, with reasonable defaults
func NewRawClient[K contracts.ClientFlowConfig](server string, opts ...ClientOption[K]) (*Client[K], error) {
	// create a client with sane default values
	client := Client[K]{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient[K contracts.ClientFlowConfig](doer contracts.ClientInterface[K]) ClientOption[K] {
	return func(c *Client[K]) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn[K contracts.ClientFlowConfig](fn RequestEditorFn) ClientOption[K] {
	return func(c *Client[K]) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type rawClientInterface interface {
	// GetCostsForAllProjectsInCustomerAccount request
	GetCostsForAllProjectsInCustomerAccountRaw(ctx context.Context, customerAccountId openapiTypes.UUID, params *GetCostsForAllProjectsInCustomerAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCostsForAllProjectsInAllSubCustomerAccounts request
	GetCostsForAllProjectsInAllSubCustomerAccountsRaw(ctx context.Context, customerAccountId openapiTypes.UUID, params *GetCostsForAllProjectsInAllSubCustomerAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectCosts request
	GetProjectCostsRaw(ctx context.Context, customerAccountId openapiTypes.UUID, projectId openapiTypes.UUID, params *GetProjectCostsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetForecastCustomerAccount request
	GetForecastCustomerAccountRaw(ctx context.Context, customerAccountId openapiTypes.UUID, params *GetForecastCustomerAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client[K]) GetCostsForAllProjectsInCustomerAccountRaw(ctx context.Context, customerAccountId openapiTypes.UUID, params *GetCostsForAllProjectsInCustomerAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCostsForAllProjectsInCustomerAccountRequest(ctx, c.Server, customerAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) GetCostsForAllProjectsInAllSubCustomerAccountsRaw(ctx context.Context, customerAccountId openapiTypes.UUID, params *GetCostsForAllProjectsInAllSubCustomerAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCostsForAllProjectsInAllSubCustomerAccountsRequest(ctx, c.Server, customerAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) GetProjectCostsRaw(ctx context.Context, customerAccountId openapiTypes.UUID, projectId openapiTypes.UUID, params *GetProjectCostsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectCostsRequest(ctx, c.Server, customerAccountId, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client[K]) GetForecastCustomerAccountRaw(ctx context.Context, customerAccountId openapiTypes.UUID, params *GetForecastCustomerAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetForecastCustomerAccountRequest(ctx, c.Server, customerAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetCostsForAllProjectsInCustomerAccountRequest generates requests for GetCostsForAllProjectsInCustomerAccount
func NewGetCostsForAllProjectsInCustomerAccountRequest(ctx context.Context, server string, customerAccountId openapiTypes.UUID, params *GetCostsForAllProjectsInCustomerAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerAccountId", runtime.ParamLocationPath, customerAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/costs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Depth != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Granularity != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "granularity", runtime.ParamLocationQuery, *params.Granularity); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeZeroCosts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeZeroCosts", runtime.ParamLocationQuery, *params.IncludeZeroCosts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Accept != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam0)
	}

	return req, nil
}

// NewGetCostsForAllProjectsInAllSubCustomerAccountsRequest generates requests for GetCostsForAllProjectsInAllSubCustomerAccounts
func NewGetCostsForAllProjectsInAllSubCustomerAccountsRequest(ctx context.Context, server string, customerAccountId openapiTypes.UUID, params *GetCostsForAllProjectsInAllSubCustomerAccountsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerAccountId", runtime.ParamLocationPath, customerAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/costs/%s/customers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Depth != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Granularity != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "granularity", runtime.ParamLocationQuery, *params.Granularity); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeZeroCosts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeZeroCosts", runtime.ParamLocationQuery, *params.IncludeZeroCosts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Accept != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam0)
	}

	return req, nil
}

// NewGetProjectCostsRequest generates requests for GetProjectCosts
func NewGetProjectCostsRequest(ctx context.Context, server string, customerAccountId openapiTypes.UUID, projectId openapiTypes.UUID, params *GetProjectCostsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerAccountId", runtime.ParamLocationPath, customerAccountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/costs/%s/projects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Depth != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Granularity != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "granularity", runtime.ParamLocationQuery, *params.Granularity); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeZeroCosts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeZeroCosts", runtime.ParamLocationQuery, *params.IncludeZeroCosts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Accept != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam0)
	}

	return req, nil
}

// NewGetForecastCustomerAccountRequest generates requests for GetForecastCustomerAccount
func NewGetForecastCustomerAccountRequest(ctx context.Context, server string, customerAccountId openapiTypes.UUID, params *GetForecastCustomerAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customerAccountId", runtime.ParamLocationPath, customerAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/forecast/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Granularity != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "granularity", runtime.ParamLocationQuery, *params.Granularity); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Accept != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam0)
	}

	return req, nil
}

func (c *Client[K]) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses[K contracts.ClientFlowConfig] struct {
	rawClientInterface
}

// NewClient creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClient[K contracts.ClientFlowConfig](server string, opts ...ClientOption[K]) (*ClientWithResponses[K], error) {
	client, err := NewRawClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses[K]{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL[K contracts.ClientFlowConfig](baseURL string) ClientOption[K] {
	return func(c *Client[K]) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetCostsForAllProjectsInCustomerAccount request
	GetCostsForAllProjectsInCustomerAccount(ctx context.Context, customerAccountId openapiTypes.UUID, params *GetCostsForAllProjectsInCustomerAccountParams, reqEditors ...RequestEditorFn) (*GetCostsForAllProjectsInCustomerAccountResponse, error)

	// GetCostsForAllProjectsInAllSubCustomerAccounts request
	GetCostsForAllProjectsInAllSubCustomerAccounts(ctx context.Context, customerAccountId openapiTypes.UUID, params *GetCostsForAllProjectsInAllSubCustomerAccountsParams, reqEditors ...RequestEditorFn) (*GetCostsForAllProjectsInAllSubCustomerAccountsResponse, error)

	// GetProjectCosts request
	GetProjectCosts(ctx context.Context, customerAccountId openapiTypes.UUID, projectId openapiTypes.UUID, params *GetProjectCostsParams, reqEditors ...RequestEditorFn) (*GetProjectCostsResponse, error)

	// GetForecastCustomerAccount request
	GetForecastCustomerAccount(ctx context.Context, customerAccountId openapiTypes.UUID, params *GetForecastCustomerAccountParams, reqEditors ...RequestEditorFn) (*GetForecastCustomerAccountResponse, error)
}

type GetCostsForAllProjectsInCustomerAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		CustomerAccountID openapiTypes.UUID `json:"customerAccountId"`
		ProjectID         openapiTypes.UUID `json:"projectId"`
		ProjectName       string            `json:"projectName"`

		// ReportData Detailed project costs which are ONLY included if granularity is provided AND depth is "project"
		ReportData *[]struct {
			// Charge Charge, value in cents
			Charge float64 `json:"charge"`

			// Discount Discount, value in cents
			Discount float64 `json:"discount"`

			// Quantity Quantity
			Quantity int32 `json:"quantity"`

			// TimePeriod Time period according to desired granularity
			TimePeriod struct {
				End   *openapiTypes.Date `json:"end,omitempty"`
				Start *openapiTypes.Date `json:"start,omitempty"`
			} `json:"timePeriod"`
		} `json:"reportData,omitempty"`

		// Services Total discount for all services and the whole requested date range (value in cents). Please see "depth" parameter for more details.
		Services *[]struct {
			// ReportData Detailed service costs which are ONLY included if granularity is provided
			ReportData *[]struct {
				// Charge Charge, value in cents
				Charge float64 `json:"charge"`

				// Discount Discount, value in cents
				Discount float64 `json:"discount"`

				// Quantity Quantity
				Quantity int32 `json:"quantity"`

				// TimePeriod Time period according to desired granularity
				TimePeriod struct {
					End   *openapiTypes.Date `json:"end,omitempty"`
					Start *openapiTypes.Date `json:"start,omitempty"`
				} `json:"timePeriod"`
			} `json:"reportData,omitempty"`

			// ServiceCategoryName Service category name
			ServiceCategoryName string `json:"serviceCategoryName"`

			// ServiceName Name of the service
			ServiceName string `json:"serviceName"`

			// Sku Service key
			Sku string `json:"sku"`

			// TotalCharge Total charge for the whole requested date range (value in cents)
			TotalCharge float64 `json:"totalCharge"`

			// TotalDiscount Total discount for the whole requested date range (value in cents)
			TotalDiscount float64 `json:"totalDiscount"`

			// TotalQuantity Total quantity
			TotalQuantity int32 `json:"totalQuantity"`

			// UnitLabel Label for unit
			UnitLabel string `json:"unitLabel"`
		} `json:"services,omitempty"`

		// TotalCharge Total charge for all services and the whole requested date range (value in cents)
		TotalCharge float64 `json:"totalCharge"`

		// TotalDiscount Total discount for all services and the whole requested date range (value in cents)
		TotalDiscount float64 `json:"totalDiscount"`
	}
	JSONDefault *struct {
		Code    string  `json:"code"`
		Message *string `json:"message,omitempty"`
	}
	Error error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetCostsForAllProjectsInCustomerAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCostsForAllProjectsInCustomerAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCostsForAllProjectsInAllSubCustomerAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		CustomerAccountID openapiTypes.UUID `json:"customerAccountId"`
		ProjectID         openapiTypes.UUID `json:"projectId"`
		ProjectName       string            `json:"projectName"`

		// ReportData Detailed project costs which are ONLY included if granularity is provided AND depth is "project"
		ReportData *[]struct {
			// Charge Charge, value in cents
			Charge float64 `json:"charge"`

			// Discount Discount, value in cents
			Discount float64 `json:"discount"`

			// Quantity Quantity
			Quantity int32 `json:"quantity"`

			// TimePeriod Time period according to desired granularity
			TimePeriod struct {
				End   *openapiTypes.Date `json:"end,omitempty"`
				Start *openapiTypes.Date `json:"start,omitempty"`
			} `json:"timePeriod"`
		} `json:"reportData,omitempty"`

		// Services Total discount for all services and the whole requested date range (value in cents). Please see "depth" parameter for more details.
		Services *[]struct {
			// ReportData Detailed service costs which are ONLY included if granularity is provided
			ReportData *[]struct {
				// Charge Charge, value in cents
				Charge float64 `json:"charge"`

				// Discount Discount, value in cents
				Discount float64 `json:"discount"`

				// Quantity Quantity
				Quantity int32 `json:"quantity"`

				// TimePeriod Time period according to desired granularity
				TimePeriod struct {
					End   *openapiTypes.Date `json:"end,omitempty"`
					Start *openapiTypes.Date `json:"start,omitempty"`
				} `json:"timePeriod"`
			} `json:"reportData,omitempty"`

			// ServiceCategoryName Service category name
			ServiceCategoryName string `json:"serviceCategoryName"`

			// ServiceName Name of the service
			ServiceName string `json:"serviceName"`

			// Sku Service key
			Sku string `json:"sku"`

			// TotalCharge Total charge for the whole requested date range (value in cents)
			TotalCharge float64 `json:"totalCharge"`

			// TotalDiscount Total discount for the whole requested date range (value in cents)
			TotalDiscount float64 `json:"totalDiscount"`

			// TotalQuantity Total quantity
			TotalQuantity int32 `json:"totalQuantity"`

			// UnitLabel Label for unit
			UnitLabel string `json:"unitLabel"`
		} `json:"services,omitempty"`

		// TotalCharge Total charge for all services and the whole requested date range (value in cents)
		TotalCharge float64 `json:"totalCharge"`

		// TotalDiscount Total discount for all services and the whole requested date range (value in cents)
		TotalDiscount float64 `json:"totalDiscount"`
	}
	JSONDefault *struct {
		Code    string  `json:"code"`
		Message *string `json:"message,omitempty"`
	}
	Error error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetCostsForAllProjectsInAllSubCustomerAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCostsForAllProjectsInAllSubCustomerAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectCostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CustomerAccountID openapiTypes.UUID `json:"customerAccountId"`
		ProjectID         openapiTypes.UUID `json:"projectId"`
		ProjectName       string            `json:"projectName"`

		// ReportData Detailed project costs which are ONLY included if granularity is provided AND depth is "project"
		ReportData *[]struct {
			// Charge Charge, value in cents
			Charge float64 `json:"charge"`

			// Discount Discount, value in cents
			Discount float64 `json:"discount"`

			// Quantity Quantity
			Quantity int32 `json:"quantity"`

			// TimePeriod Time period according to desired granularity
			TimePeriod struct {
				End   *openapiTypes.Date `json:"end,omitempty"`
				Start *openapiTypes.Date `json:"start,omitempty"`
			} `json:"timePeriod"`
		} `json:"reportData,omitempty"`

		// Services Total discount for all services and the whole requested date range (value in cents). Please see "depth" parameter for more details.
		Services *[]struct {
			// ReportData Detailed service costs which are ONLY included if granularity is provided
			ReportData *[]struct {
				// Charge Charge, value in cents
				Charge float64 `json:"charge"`

				// Discount Discount, value in cents
				Discount float64 `json:"discount"`

				// Quantity Quantity
				Quantity int32 `json:"quantity"`

				// TimePeriod Time period according to desired granularity
				TimePeriod struct {
					End   *openapiTypes.Date `json:"end,omitempty"`
					Start *openapiTypes.Date `json:"start,omitempty"`
				} `json:"timePeriod"`
			} `json:"reportData,omitempty"`

			// ServiceCategoryName Service category name
			ServiceCategoryName string `json:"serviceCategoryName"`

			// ServiceName Name of the service
			ServiceName string `json:"serviceName"`

			// Sku Service key
			Sku string `json:"sku"`

			// TotalCharge Total charge for the whole requested date range (value in cents)
			TotalCharge float64 `json:"totalCharge"`

			// TotalDiscount Total discount for the whole requested date range (value in cents)
			TotalDiscount float64 `json:"totalDiscount"`

			// TotalQuantity Total quantity
			TotalQuantity int32 `json:"totalQuantity"`

			// UnitLabel Label for unit
			UnitLabel string `json:"unitLabel"`
		} `json:"services,omitempty"`

		// TotalCharge Total charge for all services and the whole requested date range (value in cents)
		TotalCharge float64 `json:"totalCharge"`

		// TotalDiscount Total discount for all services and the whole requested date range (value in cents)
		TotalDiscount float64 `json:"totalDiscount"`
	}
	JSONDefault *struct {
		Code    string  `json:"code"`
		Message *string `json:"message,omitempty"`
	}
	Error error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetProjectCostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectCostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetForecastCustomerAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		CustomerAccountID openapiTypes.UUID `json:"customerAccountId"`
		ProjectID         openapiTypes.UUID `json:"projectId"`
		ProjectName       string            `json:"projectName"`

		// ReportData Detailed forcasted project costs which are ONLY included if granularity is provided AND depth is "project"
		ReportData *[]struct {
			// Charge Forecasted charge, value in cents
			Charge float64 `json:"charge"`

			// TimePeriod Time period according to desired granularity
			TimePeriod struct {
				End   *openapiTypes.Date `json:"end,omitempty"`
				Start *openapiTypes.Date `json:"start,omitempty"`
			} `json:"timePeriod"`
		} `json:"reportData,omitempty"`

		// TotalCharge Total forecasted charge for all services and the whole requested date range (value in cents)
		TotalCharge float64 `json:"totalCharge"`
	}
	JSONDefault *struct {
		Code    string  `json:"code"`
		Message *string `json:"message,omitempty"`
	}
	Error error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetForecastCustomerAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetForecastCustomerAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetCostsForAllProjectsInCustomerAccount request returning *GetCostsForAllProjectsInCustomerAccountResponse
func (c *ClientWithResponses[K]) GetCostsForAllProjectsInCustomerAccount(ctx context.Context, customerAccountId openapiTypes.UUID, params *GetCostsForAllProjectsInCustomerAccountParams, reqEditors ...RequestEditorFn) (*GetCostsForAllProjectsInCustomerAccountResponse, error) {
	rsp, err := c.GetCostsForAllProjectsInCustomerAccountRaw(ctx, customerAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetCostsForAllProjectsInCustomerAccountResponse(rsp)
}

// GetCostsForAllProjectsInAllSubCustomerAccounts request returning *GetCostsForAllProjectsInAllSubCustomerAccountsResponse
func (c *ClientWithResponses[K]) GetCostsForAllProjectsInAllSubCustomerAccounts(ctx context.Context, customerAccountId openapiTypes.UUID, params *GetCostsForAllProjectsInAllSubCustomerAccountsParams, reqEditors ...RequestEditorFn) (*GetCostsForAllProjectsInAllSubCustomerAccountsResponse, error) {
	rsp, err := c.GetCostsForAllProjectsInAllSubCustomerAccountsRaw(ctx, customerAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetCostsForAllProjectsInAllSubCustomerAccountsResponse(rsp)
}

// GetProjectCosts request returning *GetProjectCostsResponse
func (c *ClientWithResponses[K]) GetProjectCosts(ctx context.Context, customerAccountId openapiTypes.UUID, projectId openapiTypes.UUID, params *GetProjectCostsParams, reqEditors ...RequestEditorFn) (*GetProjectCostsResponse, error) {
	rsp, err := c.GetProjectCostsRaw(ctx, customerAccountId, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetProjectCostsResponse(rsp)
}

// GetForecastCustomerAccount request returning *GetForecastCustomerAccountResponse
func (c *ClientWithResponses[K]) GetForecastCustomerAccount(ctx context.Context, customerAccountId openapiTypes.UUID, params *GetForecastCustomerAccountParams, reqEditors ...RequestEditorFn) (*GetForecastCustomerAccountResponse, error) {
	rsp, err := c.GetForecastCustomerAccountRaw(ctx, customerAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetForecastCustomerAccountResponse(rsp)
}

// ParseGetCostsForAllProjectsInCustomerAccountResponse parses an HTTP response from a GetCostsForAllProjectsInCustomerAccount call
func (c *ClientWithResponses[K]) ParseGetCostsForAllProjectsInCustomerAccountResponse(rsp *http.Response) (*GetCostsForAllProjectsInCustomerAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCostsForAllProjectsInCustomerAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			CustomerAccountID openapiTypes.UUID `json:"customerAccountId"`
			ProjectID         openapiTypes.UUID `json:"projectId"`
			ProjectName       string            `json:"projectName"`

			// ReportData Detailed project costs which are ONLY included if granularity is provided AND depth is "project"
			ReportData *[]struct {
				// Charge Charge, value in cents
				Charge float64 `json:"charge"`

				// Discount Discount, value in cents
				Discount float64 `json:"discount"`

				// Quantity Quantity
				Quantity int32 `json:"quantity"`

				// TimePeriod Time period according to desired granularity
				TimePeriod struct {
					End   *openapiTypes.Date `json:"end,omitempty"`
					Start *openapiTypes.Date `json:"start,omitempty"`
				} `json:"timePeriod"`
			} `json:"reportData,omitempty"`

			// Services Total discount for all services and the whole requested date range (value in cents). Please see "depth" parameter for more details.
			Services *[]struct {
				// ReportData Detailed service costs which are ONLY included if granularity is provided
				ReportData *[]struct {
					// Charge Charge, value in cents
					Charge float64 `json:"charge"`

					// Discount Discount, value in cents
					Discount float64 `json:"discount"`

					// Quantity Quantity
					Quantity int32 `json:"quantity"`

					// TimePeriod Time period according to desired granularity
					TimePeriod struct {
						End   *openapiTypes.Date `json:"end,omitempty"`
						Start *openapiTypes.Date `json:"start,omitempty"`
					} `json:"timePeriod"`
				} `json:"reportData,omitempty"`

				// ServiceCategoryName Service category name
				ServiceCategoryName string `json:"serviceCategoryName"`

				// ServiceName Name of the service
				ServiceName string `json:"serviceName"`

				// Sku Service key
				Sku string `json:"sku"`

				// TotalCharge Total charge for the whole requested date range (value in cents)
				TotalCharge float64 `json:"totalCharge"`

				// TotalDiscount Total discount for the whole requested date range (value in cents)
				TotalDiscount float64 `json:"totalDiscount"`

				// TotalQuantity Total quantity
				TotalQuantity int32 `json:"totalQuantity"`

				// UnitLabel Label for unit
				UnitLabel string `json:"unitLabel"`
			} `json:"services,omitempty"`

			// TotalCharge Total charge for all services and the whole requested date range (value in cents)
			TotalCharge float64 `json:"totalCharge"`

			// TotalDiscount Total discount for all services and the whole requested date range (value in cents)
			TotalDiscount float64 `json:"totalDiscount"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    string  `json:"code"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, validate.ResponseObject(response)
}

// ParseGetCostsForAllProjectsInAllSubCustomerAccountsResponse parses an HTTP response from a GetCostsForAllProjectsInAllSubCustomerAccounts call
func (c *ClientWithResponses[K]) ParseGetCostsForAllProjectsInAllSubCustomerAccountsResponse(rsp *http.Response) (*GetCostsForAllProjectsInAllSubCustomerAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCostsForAllProjectsInAllSubCustomerAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			CustomerAccountID openapiTypes.UUID `json:"customerAccountId"`
			ProjectID         openapiTypes.UUID `json:"projectId"`
			ProjectName       string            `json:"projectName"`

			// ReportData Detailed project costs which are ONLY included if granularity is provided AND depth is "project"
			ReportData *[]struct {
				// Charge Charge, value in cents
				Charge float64 `json:"charge"`

				// Discount Discount, value in cents
				Discount float64 `json:"discount"`

				// Quantity Quantity
				Quantity int32 `json:"quantity"`

				// TimePeriod Time period according to desired granularity
				TimePeriod struct {
					End   *openapiTypes.Date `json:"end,omitempty"`
					Start *openapiTypes.Date `json:"start,omitempty"`
				} `json:"timePeriod"`
			} `json:"reportData,omitempty"`

			// Services Total discount for all services and the whole requested date range (value in cents). Please see "depth" parameter for more details.
			Services *[]struct {
				// ReportData Detailed service costs which are ONLY included if granularity is provided
				ReportData *[]struct {
					// Charge Charge, value in cents
					Charge float64 `json:"charge"`

					// Discount Discount, value in cents
					Discount float64 `json:"discount"`

					// Quantity Quantity
					Quantity int32 `json:"quantity"`

					// TimePeriod Time period according to desired granularity
					TimePeriod struct {
						End   *openapiTypes.Date `json:"end,omitempty"`
						Start *openapiTypes.Date `json:"start,omitempty"`
					} `json:"timePeriod"`
				} `json:"reportData,omitempty"`

				// ServiceCategoryName Service category name
				ServiceCategoryName string `json:"serviceCategoryName"`

				// ServiceName Name of the service
				ServiceName string `json:"serviceName"`

				// Sku Service key
				Sku string `json:"sku"`

				// TotalCharge Total charge for the whole requested date range (value in cents)
				TotalCharge float64 `json:"totalCharge"`

				// TotalDiscount Total discount for the whole requested date range (value in cents)
				TotalDiscount float64 `json:"totalDiscount"`

				// TotalQuantity Total quantity
				TotalQuantity int32 `json:"totalQuantity"`

				// UnitLabel Label for unit
				UnitLabel string `json:"unitLabel"`
			} `json:"services,omitempty"`

			// TotalCharge Total charge for all services and the whole requested date range (value in cents)
			TotalCharge float64 `json:"totalCharge"`

			// TotalDiscount Total discount for all services and the whole requested date range (value in cents)
			TotalDiscount float64 `json:"totalDiscount"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    string  `json:"code"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, validate.ResponseObject(response)
}

// ParseGetProjectCostsResponse parses an HTTP response from a GetProjectCosts call
func (c *ClientWithResponses[K]) ParseGetProjectCostsResponse(rsp *http.Response) (*GetProjectCostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectCostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CustomerAccountID openapiTypes.UUID `json:"customerAccountId"`
			ProjectID         openapiTypes.UUID `json:"projectId"`
			ProjectName       string            `json:"projectName"`

			// ReportData Detailed project costs which are ONLY included if granularity is provided AND depth is "project"
			ReportData *[]struct {
				// Charge Charge, value in cents
				Charge float64 `json:"charge"`

				// Discount Discount, value in cents
				Discount float64 `json:"discount"`

				// Quantity Quantity
				Quantity int32 `json:"quantity"`

				// TimePeriod Time period according to desired granularity
				TimePeriod struct {
					End   *openapiTypes.Date `json:"end,omitempty"`
					Start *openapiTypes.Date `json:"start,omitempty"`
				} `json:"timePeriod"`
			} `json:"reportData,omitempty"`

			// Services Total discount for all services and the whole requested date range (value in cents). Please see "depth" parameter for more details.
			Services *[]struct {
				// ReportData Detailed service costs which are ONLY included if granularity is provided
				ReportData *[]struct {
					// Charge Charge, value in cents
					Charge float64 `json:"charge"`

					// Discount Discount, value in cents
					Discount float64 `json:"discount"`

					// Quantity Quantity
					Quantity int32 `json:"quantity"`

					// TimePeriod Time period according to desired granularity
					TimePeriod struct {
						End   *openapiTypes.Date `json:"end,omitempty"`
						Start *openapiTypes.Date `json:"start,omitempty"`
					} `json:"timePeriod"`
				} `json:"reportData,omitempty"`

				// ServiceCategoryName Service category name
				ServiceCategoryName string `json:"serviceCategoryName"`

				// ServiceName Name of the service
				ServiceName string `json:"serviceName"`

				// Sku Service key
				Sku string `json:"sku"`

				// TotalCharge Total charge for the whole requested date range (value in cents)
				TotalCharge float64 `json:"totalCharge"`

				// TotalDiscount Total discount for the whole requested date range (value in cents)
				TotalDiscount float64 `json:"totalDiscount"`

				// TotalQuantity Total quantity
				TotalQuantity int32 `json:"totalQuantity"`

				// UnitLabel Label for unit
				UnitLabel string `json:"unitLabel"`
			} `json:"services,omitempty"`

			// TotalCharge Total charge for all services and the whole requested date range (value in cents)
			TotalCharge float64 `json:"totalCharge"`

			// TotalDiscount Total discount for all services and the whole requested date range (value in cents)
			TotalDiscount float64 `json:"totalDiscount"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    string  `json:"code"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSONDefault = &dest

	case rsp.StatusCode == 200:
	// Content-type (text/csv) unsupported

	case true:
		// Content-type (text/csv) unsupported

	}

	return response, validate.ResponseObject(response)
}

// ParseGetForecastCustomerAccountResponse parses an HTTP response from a GetForecastCustomerAccount call
func (c *ClientWithResponses[K]) ParseGetForecastCustomerAccountResponse(rsp *http.Response) (*GetForecastCustomerAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetForecastCustomerAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			CustomerAccountID openapiTypes.UUID `json:"customerAccountId"`
			ProjectID         openapiTypes.UUID `json:"projectId"`
			ProjectName       string            `json:"projectName"`

			// ReportData Detailed forcasted project costs which are ONLY included if granularity is provided AND depth is "project"
			ReportData *[]struct {
				// Charge Forecasted charge, value in cents
				Charge float64 `json:"charge"`

				// TimePeriod Time period according to desired granularity
				TimePeriod struct {
					End   *openapiTypes.Date `json:"end,omitempty"`
					Start *openapiTypes.Date `json:"start,omitempty"`
				} `json:"timePeriod"`
			} `json:"reportData,omitempty"`

			// TotalCharge Total forecasted charge for all services and the whole requested date range (value in cents)
			TotalCharge float64 `json:"totalCharge"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			Code    string  `json:"code"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSONDefault = &dest

	}

	return response, validate.ResponseObject(response)
}
