// Package alertconfig provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/do87/oapi-codegen version v0.4.0 DO NOT EDIT.
package alertconfig

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	common "github.com/SchwarzIT/community-stackit-go-client/internal/common"
	"github.com/SchwarzIT/community-stackit-go-client/pkg/validate"
	"github.com/do87/oapi-codegen/pkg/runtime"
	openapi_types "github.com/do87/oapi-codegen/pkg/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Alert defines model for Alert.
type Alert struct {
	Global       *Global         `json:"global,omitempty"`
	InhibitRules *[]InhibitRules `json:"inhibitRules,omitempty"`
	Receivers    []Receivers     `json:"receivers"`
	Route        Route           `json:"route"`
}

// EmailConfig defines model for EmailConfig.
type EmailConfig struct {
	AuthIdentity *openapi_types.Email `json:"authIdentity,omitempty"`
	AuthPassword *string              `json:"authPassword,omitempty"`
	AuthUsername *string              `json:"authUsername,omitempty"`
	From         *openapi_types.Email `json:"from,omitempty"`
	SendResolved *bool                `json:"sendResolved,omitempty"`
	Smarthost    *string              `json:"smarthost,omitempty"`
	To           openapi_types.Email  `json:"to"`
}

// Error defines model for Error.
type Error struct {
	Errors  *[]map[string]string `json:"errors,omitempty"`
	Message string               `json:"message"`
}

// GetAlert defines model for GetAlert.
type GetAlert struct {
	Data    Alert  `json:"data"`
	Message string `json:"message"`
}

// Global defines model for Global.
type Global struct {
	OpsgenieAPIKey   *string              `json:"opsgenieApiKey,omitempty"`
	OpsgenieAPIURL   *string              `json:"opsgenieApiUrl,omitempty"`
	ResolveTimeout   *string              `json:"resolveTimeout,omitempty"`
	SmtpAuthIdentity *openapi_types.Email `json:"smtpAuthIdentity,omitempty"`
	SmtpAuthPassword *string              `json:"smtpAuthPassword,omitempty"`
	SmtpAuthUsername *string              `json:"smtpAuthUsername,omitempty"`
	SmtpFrom         *openapi_types.Email `json:"smtpFrom,omitempty"`
	SmtpSmarthost    *string              `json:"smtpSmarthost,omitempty"`
}

// InhibitRules defines model for InhibitRules.
type InhibitRules struct {
	Equal          *[]string          `json:"equal,omitempty"`
	SourceMatch    *map[string]string `json:"sourceMatch,omitempty"`
	SourceMatchRe  *map[string]string `json:"sourceMatchRe,omitempty"`
	SourceMatchers *[]string          `json:"sourceMatchers,omitempty"`
	TargetMatch    *map[string]string `json:"targetMatch,omitempty"`
	TargetMatchRe  *map[string]string `json:"targetMatchRe,omitempty"`
	TargetMatchers *[]string          `json:"targetMatchers,omitempty"`
}

// Message defines model for Message.
type Message struct {
	Message string `json:"message"`
}

// OpsgenieConfig defines model for OpsgenieConfig.
type OpsgenieConfig struct {
	APIKey       *string `json:"apiKey,omitempty"`
	APIURL       *string `json:"apiUrl,omitempty"`
	Priority     *string `json:"priority,omitempty"`
	SendResolved *bool   `json:"sendResolved,omitempty"`
	Tags         *string `json:"tags,omitempty"`
}

// PermissionDenied defines model for PermissionDenied.
type PermissionDenied struct {
	Detail string `json:"detail"`
}

// PutAlert defines model for PutAlert.
type PutAlert struct {
	Data    Alert  `json:"data"`
	Message string `json:"message"`
}

// Receivers defines model for Receivers.
type Receivers struct {
	EmailConfigs    *[]EmailConfig    `json:"emailConfigs,omitempty"`
	Name            string            `json:"name"`
	OpsgenieConfigs *[]OpsgenieConfig `json:"opsgenieConfigs,omitempty"`
	WebHookConfigs  *[]WebHook        `json:"webHookConfigs,omitempty"`
}

// ReceiversResponse defines model for ReceiversResponse.
type ReceiversResponse struct {
	Data    []Receivers `json:"data"`
	Message string      `json:"message"`
}

// ReceiversResponseSerializerSingle defines model for ReceiversResponseSerializerSingle.
type ReceiversResponseSerializerSingle struct {
	Data    Receivers `json:"data"`
	Message string    `json:"message"`
}

// Route defines model for Route.
type Route struct {
	Continue       *bool               `json:"continue,omitempty"`
	GroupBy        *[]string           `json:"groupBy,omitempty"`
	GroupInterval  *string             `json:"groupInterval,omitempty"`
	GroupWait      *string             `json:"groupWait,omitempty"`
	Match          *map[string]string  `json:"match,omitempty"`
	MatchRe        *map[string]string  `json:"matchRe,omitempty"`
	Receiver       string              `json:"receiver"`
	RepeatInterval *string             `json:"repeatInterval,omitempty"`
	Routes         *[]RouteSerializer2 `json:"routes,omitempty"`
}

// RouteResponse defines model for RouteResponse.
type RouteResponse struct {
	Data    Route  `json:"data"`
	Message string `json:"message"`
}

// RouteSerializer2 defines model for RouteSerializer2.
type RouteSerializer2 struct {
	Continue       *bool                `json:"continue,omitempty"`
	GroupBy        *[]string            `json:"groupBy,omitempty"`
	GroupInterval  *string              `json:"groupInterval,omitempty"`
	GroupWait      *string              `json:"groupWait,omitempty"`
	Match          *map[string]string   `json:"match,omitempty"`
	MatchRe        *map[string]string   `json:"matchRe,omitempty"`
	Matchers       *[]string            `json:"matchers,omitempty"`
	Receiver       string               `json:"receiver"`
	RepeatInterval *string              `json:"repeatInterval,omitempty"`
	Routes         *[]map[string]string `json:"routes,omitempty"`
}

// WebHook defines model for WebHook.
type WebHook struct {
	MsTeams      *bool  `json:"msTeams,omitempty"`
	SendResolved *bool  `json:"sendResolved,omitempty"`
	URL          string `json:"url"`
}

// UpdateJSONBody defines parameters for Update.
type UpdateJSONBody struct {
	// Global Global config. If nothing passed the default argus config will be used.
	Global *struct {
		// OpsgenieApiKey Opsgenie api key
		// `Additional Validators:`
		// * should only include the characters: a-zA-Z0-9-
		OpsgenieAPIKey *string `json:"opsgenieApiKey,omitempty"`

		// OpsgenieApiUrl Opsgenie api url
		// `Additional Validators:`
		// * must be a syntactically valid url address
		OpsgenieAPIURL *string `json:"opsgenieApiUrl,omitempty"`

		// ResolveTimeout ResolveTimeout is the default value used by alertmanager if the alert does not include EndsAt, after this time passes it can declare the alert as resolved if it has not been updated. This has no impact on alerts from Prometheus, as they always include EndsAt.
		// `Additional Validators:`
		// * must be a valid time format
		ResolveTimeout *string `json:"resolveTimeout,omitempty"`

		// SmtpAuthIdentity Auth identity.
		// `Additional Validators:`
		// * must be a syntactically valid email address
		SmtpAuthIdentity *string `json:"smtpAuthIdentity,omitempty"`

		// SmtpAuthPassword SMTP Auth using LOGIN and PLAIN.
		SmtpAuthPassword *string `json:"smtpAuthPassword,omitempty"`

		// SmtpAuthUsername SMTP Auth using CRAM-MD5, LOGIN and PLAIN. If empty, Alertmanager doesn't authenticate to the SMTP server.
		SmtpAuthUsername *string `json:"smtpAuthUsername,omitempty"`

		// SmtpFrom The default SMTP From header field.
		// `Additional Validators:`
		// * must be a syntactically valid email address
		SmtpFrom *string `json:"smtpFrom,omitempty"`

		// SmtpSmarthost The default SMTP smarthost used for sending emails, including port number. Port number usually is 25, or 587 for SMTP over TLS (sometimes referred to as STARTTLS). Example: smtp.example.org:587
		// `Additional Validators:`
		// * should only include the characters: a-zA-Z0-9_./@&?:-
		SmtpSmarthost *string `json:"smtpSmarthost,omitempty"`
	} `json:"global,omitempty"`

	// InhibitRules A list of inhibition rules.
	InhibitRules *struct {
		// Equal Labels that must have an equal value in the source and target alert for the inhibition to take effect.
		// `Additional Validators:`
		// * should only include the characters: a-zA-Z0-9_./@&?:-
		Equal *[]string `json:"equal,omitempty"`

		// SourceMatch map of key:value. Matchers for which one or more alerts have to exist for the inhibition to take effect.
		// `Additional Validators:`
		// * should not contain more than 5 keys
		// * each key and value should not have more than 200 characters
		// * each key and value should only include the characters: a-zA-Z0-9_./@&?:-
		SourceMatch *map[string]interface{} `json:"sourceMatch,omitempty"`

		// SourceMatchRe map of key:value. Regex match
		// `Additional Validators:`
		// * should not contain more than 5 keys
		// * each key and value should not have more than 200 characters
		SourceMatchRe *map[string]interface{} `json:"sourceMatchRe,omitempty"`

		// TargetMatch map of key:value. Matchers that have to be fulfilled in the alerts to be muted.
		// `Additional Validators:`
		// * should not contain more than 5 keys
		// * each key and value should not have more than 200 characters
		// * each key and value should only include the characters: a-zA-Z0-9_./@&?:-
		TargetMatch *map[string]interface{} `json:"targetMatch,omitempty"`

		// TargetMatchRe map of key:value. Matchers that have to be fulfilled in the alerts to be muted. Regex.
		// `Additional Validators:`
		// * should not contain more than 5 keys
		// * each key and value should not have more than 200 characters
		TargetMatchRe *map[string]interface{} `json:"targetMatchRe,omitempty"`
	} `json:"inhibitRules,omitempty"`

	// Receivers A list of notification receivers.
	Receivers []struct {
		// EmailConfigs Email configurations
		EmailConfigs *[]struct {
			// AuthIdentity SMTP authentication information.
			// `Additional Validators:`
			// * must be a syntactically valid email address
			AuthIdentity *string `json:"authIdentity,omitempty"`

			// AuthPassword SMTP authentication information.
			AuthPassword *string `json:"authPassword,omitempty"`

			// AuthUsername SMTP authentication information.
			AuthUsername *string `json:"authUsername,omitempty"`

			// From The sender address.
			// `Additional Validators:`
			// * must be a syntactically valid email address
			From *string `json:"from,omitempty"`

			// Smarthost The SMTP host through which emails are sent.
			// `Additional Validators:`
			// * should only include the characters: a-zA-Z0-9_./@&?:-
			Smarthost *string `json:"smarthost,omitempty"`

			// To The email address to send notifications to.
			// `Additional Validators:`
			// * must be a syntactically valid email address
			To *string `json:"to,omitempty"`
		} `json:"emailConfigs,omitempty"`

		// Name `Additional Validators:`
		// * must be unique
		// * should only include the characters: a-zA-Z0-9-
		Name string `json:"name"`

		// OpsgenieConfigs Configuration for ops genie.
		OpsgenieConfigs *[]struct {
			// ApiKey The API key to use when talking to the OpsGenie API.
			// `Additional Validators:`
			// * should only include the characters: a-zA-Z0-9-
			APIKey *string `json:"apiKey,omitempty"`

			// ApiUrl The host to send OpsGenie API requests to.
			// `Additional Validators:`
			// * must be a syntactically valid url address
			APIURL *string `json:"apiUrl,omitempty"`

			// Tags Comma separated list of tags attached to the notifications.
			Tags *string `json:"tags,omitempty"`
		} `json:"opsgenieConfigs,omitempty"`
		WebHookConfigs *[]struct {
			// MsTeams Microsoft Teams webhooks require special handling. If you set this property to true, it is treated as such
			MsTeams *bool `json:"msTeams,omitempty"`

			// Url The endpoint to send HTTP POST requests to.
			// `Additional Validators:`
			// * must be a syntactically valid url address
			URL *string `json:"url,omitempty"`
		} `json:"webHookConfigs,omitempty"`
	} `json:"receivers"`

	// Route The root node of the routing tree.
	Route struct {
		// GroupBy The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels use the special value '...' as the sole label name, for example: group_by: ['...']. This effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what you want, unless you have a very low alert volume or your upstream notification system performs its own grouping.
		GroupBy *[]string `json:"groupBy,omitempty"`

		// GroupInterval How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.)
		// `Additional Validators:`
		// * must be a valid time format
		GroupInterval *string `json:"groupInterval,omitempty"`

		// GroupWait How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.)
		// `Additional Validators:`
		// * must be a valid time format
		GroupWait *string `json:"groupWait,omitempty"`

		// Match map of key:value. A set of equality matchers an alert has to fulfill to match the node.
		// `Additional Validators:`
		// * should not contain more than 5 keys
		// * each key and value should not be longer than 200 characters
		// * key and values should only include the characters: a-zA-Z0-9_./@&?:-
		Match *map[string]interface{} `json:"match,omitempty"`

		// MatchRe map of key:value. A set of regex-matchers an alert has to fulfill to match the node.
		// `Additional Validators:`
		// * should not contain more than 5 keys
		// * each key and value should not be longer than 200 characters
		MatchRe *map[string]interface{} `json:"matchRe,omitempty"`

		// Matchers A list of matchers that an alert has to fulfill to match the node. A matcher is a string with a syntax inspired by PromQL and OpenMetrics. The syntax of a matcher consists of three tokens:
		// * A valid Prometheus label name.
		// * One of =, !=, =~, or !~. = means equals, != means that the strings are not equal, =~ is used for equality of regex expressions and !~ is used for un-equality of regex expressions. They have the same meaning as known from PromQL selectors.
		// * A UTF-8 string, which may be enclosed in double quotes. Before or after each token, there may be any amount of whitespace.
		// `Additional Validators:`
		// * should not contain more than 5 keys
		// * each key and value should not be longer than 200 characters
		Matchers *[]string `json:"matchers,omitempty"`

		// Receiver Receiver that should be one item of receivers
		// `Additional Validators:`
		// * must be a in name of receivers
		Receiver string `json:"receiver"`

		// RepeatInterval How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).
		// `Additional Validators:`
		// * must be a valid time format
		RepeatInterval *string `json:"repeatInterval,omitempty"`

		// Routes Zero or more child routes.
		Routes *[]struct {
			GroupBy *[]string `json:"groupBy,omitempty"`

			// GroupInterval As in one level above
			GroupInterval *string `json:"groupInterval,omitempty"`

			// GroupWait As in one level above
			GroupWait *string `json:"groupWait,omitempty"`

			// Match As in one level above
			Match *map[string]interface{} `json:"match,omitempty"`

			// MatchRe As in one level above
			MatchRe *map[string]interface{} `json:"matchRe,omitempty"`

			// Receiver As in one level above
			Receiver *string `json:"receiver,omitempty"`

			// RepeatInterval As in one level above
			RepeatInterval *string `json:"repeatInterval,omitempty"`

			// Routes Another child routes
			Routes *[]map[string]interface{} `json:"routes,omitempty"`
		} `json:"routes,omitempty"`
	} `json:"route"`
}

// ReceiversCreateJSONBody defines parameters for ReceiversCreate.
type ReceiversCreateJSONBody struct {
	// EmailConfigs Email configurations
	EmailConfigs *[]struct {
		// AuthIdentity SMTP authentication information.
		// `Additional Validators:`
		// * must be a syntactically valid email address
		AuthIdentity *string `json:"authIdentity,omitempty"`

		// AuthPassword SMTP authentication information.
		AuthPassword *string `json:"authPassword,omitempty"`

		// AuthUsername SMTP authentication information.
		AuthUsername *string `json:"authUsername,omitempty"`

		// From The sender address.
		// `Additional Validators:`
		// * must be a syntactically valid email address
		From *string `json:"from,omitempty"`

		// Smarthost The SMTP host through which emails are sent.
		// `Additional Validators:`
		// * should only include the characters: a-zA-Z0-9_./@&?:-
		Smarthost *string `json:"smarthost,omitempty"`

		// To The email address to send notifications to.
		// `Additional Validators:`
		// * must be a syntactically valid email address
		To *string `json:"to,omitempty"`
	} `json:"emailConfigs,omitempty"`

	// Name `Additional Validators:`
	// * must be unique
	// * should only include the characters: a-zA-Z0-9-
	Name string `json:"name"`

	// OpsgenieConfigs Configuration for ops genie.
	OpsgenieConfigs *[]struct {
		// ApiKey The API key to use when talking to the OpsGenie API.
		// `Additional Validators:`
		// * should only include the characters: a-zA-Z0-9-
		APIKey *string `json:"apiKey,omitempty"`

		// ApiUrl The host to send OpsGenie API requests to.
		// `Additional Validators:`
		// * must be a syntactically valid url address
		APIURL *string `json:"apiUrl,omitempty"`

		// Tags Comma separated list of tags attached to the notifications.
		Tags *string `json:"tags,omitempty"`
	} `json:"opsgenieConfigs,omitempty"`
	WebHookConfigs *[]struct {
		// MsTeams Microsoft Teams webhooks require special handling. If you set this property to true, it is treated as such
		MsTeams *bool `json:"msTeams,omitempty"`

		// Url The endpoint to send HTTP POST requests to.
		// `Additional Validators:`
		// * must be a syntactically valid url address
		URL *string `json:"url,omitempty"`
	} `json:"webHookConfigs,omitempty"`
}

// ReceiversUpdateJSONBody defines parameters for ReceiversUpdate.
type ReceiversUpdateJSONBody struct {
	// EmailConfigs Email configurations
	EmailConfigs *[]struct {
		// AuthIdentity SMTP authentication information.
		// `Additional Validators:`
		// * must be a syntactically valid email address
		AuthIdentity *string `json:"authIdentity,omitempty"`

		// AuthPassword SMTP authentication information.
		AuthPassword *string `json:"authPassword,omitempty"`

		// AuthUsername SMTP authentication information.
		AuthUsername *string `json:"authUsername,omitempty"`

		// From The sender address.
		// `Additional Validators:`
		// * must be a syntactically valid email address
		From *string `json:"from,omitempty"`

		// Smarthost The SMTP host through which emails are sent.
		// `Additional Validators:`
		// * should only include the characters: a-zA-Z0-9_./@&?:-
		Smarthost *string `json:"smarthost,omitempty"`

		// To The email address to send notifications to.
		// `Additional Validators:`
		// * must be a syntactically valid email address
		To *string `json:"to,omitempty"`
	} `json:"emailConfigs,omitempty"`

	// Name `Additional Validators:`
	// * must be unique
	// * should only include the characters: a-zA-Z0-9-
	Name string `json:"name"`

	// OpsgenieConfigs Configuration for ops genie.
	OpsgenieConfigs *[]struct {
		// ApiKey The API key to use when talking to the OpsGenie API.
		// `Additional Validators:`
		// * should only include the characters: a-zA-Z0-9-
		APIKey *string `json:"apiKey,omitempty"`

		// ApiUrl The host to send OpsGenie API requests to.
		// `Additional Validators:`
		// * must be a syntactically valid url address
		APIURL *string `json:"apiUrl,omitempty"`

		// Tags Comma separated list of tags attached to the notifications.
		Tags *string `json:"tags,omitempty"`
	} `json:"opsgenieConfigs,omitempty"`
	WebHookConfigs *[]struct {
		// MsTeams Microsoft Teams webhooks require special handling. If you set this property to true, it is treated as such
		MsTeams *bool `json:"msTeams,omitempty"`

		// Url The endpoint to send HTTP POST requests to.
		// `Additional Validators:`
		// * must be a syntactically valid url address
		URL *string `json:"url,omitempty"`
	} `json:"webHookConfigs,omitempty"`
}

// RoutesCreateJSONBody defines parameters for RoutesCreate.
type RoutesCreateJSONBody struct {
	// GroupBy The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels use the special value '...' as the sole label name, for example: group_by: ['...']. This effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what you want, unless you have a very low alert volume or your upstream notification system performs its own grouping.
	GroupBy *[]string `json:"groupBy,omitempty"`

	// GroupInterval How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.)
	// `Additional Validators:`
	// * must be a valid time format
	GroupInterval *string `json:"groupInterval,omitempty"`

	// GroupWait How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.)
	// `Additional Validators:`
	// * must be a valid time format
	GroupWait *string `json:"groupWait,omitempty"`

	// Match map of key:value. A set of equality matchers an alert has to fulfill to match the node.
	// `Additional Validators:`
	// * should not contain more than 5 keys
	// * each key and value should not be longer than 200 characters
	// * key and values should only include the characters: a-zA-Z0-9_./@&?:-
	Match *map[string]interface{} `json:"match,omitempty"`

	// MatchRe map of key:value. A set of regex-matchers an alert has to fulfill to match the node.
	// `Additional Validators:`
	// * should not contain more than 5 keys
	// * each key and value should not be longer than 200 characters
	MatchRe *map[string]interface{} `json:"matchRe,omitempty"`

	// Matchers A list of matchers that an alert has to fulfill to match the node. A matcher is a string with a syntax inspired by PromQL and OpenMetrics. The syntax of a matcher consists of three tokens:
	// * A valid Prometheus label name.
	// * One of =, !=, =~, or !~. = means equals, != means that the strings are not equal, =~ is used for equality of regex expressions and !~ is used for un-equality of regex expressions. They have the same meaning as known from PromQL selectors.
	// * A UTF-8 string, which may be enclosed in double quotes. Before or after each token, there may be any amount of whitespace.
	// `Additional Validators:`
	// * should not contain more than 5 keys
	// * each key and value should not be longer than 200 characters
	Matchers *[]string `json:"matchers,omitempty"`

	// Receiver Receiver that should be one item of receivers
	// `Additional Validators:`
	// * must be a in name of receivers
	Receiver string `json:"receiver"`

	// RepeatInterval How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).
	// `Additional Validators:`
	// * must be a valid time format
	RepeatInterval *string `json:"repeatInterval,omitempty"`

	// Routes Zero or more child routes.
	Routes *[]struct {
		GroupBy *[]string `json:"groupBy,omitempty"`

		// GroupInterval As in one level above
		GroupInterval *string `json:"groupInterval,omitempty"`

		// GroupWait As in one level above
		GroupWait *string `json:"groupWait,omitempty"`

		// Match As in one level above
		Match *map[string]interface{} `json:"match,omitempty"`

		// MatchRe As in one level above
		MatchRe *map[string]interface{} `json:"matchRe,omitempty"`

		// Receiver As in one level above
		Receiver *string `json:"receiver,omitempty"`

		// RepeatInterval As in one level above
		RepeatInterval *string `json:"repeatInterval,omitempty"`

		// Routes Another child routes
		Routes *[]map[string]interface{} `json:"routes,omitempty"`
	} `json:"routes,omitempty"`
}

// RoutesUpdateJSONBody defines parameters for RoutesUpdate.
type RoutesUpdateJSONBody struct {
	// GroupBy The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels use the special value '...' as the sole label name, for example: group_by: ['...']. This effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what you want, unless you have a very low alert volume or your upstream notification system performs its own grouping.
	GroupBy *[]string `json:"groupBy,omitempty"`

	// GroupInterval How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.)
	// `Additional Validators:`
	// * must be a valid time format
	GroupInterval *string `json:"groupInterval,omitempty"`

	// GroupWait How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.)
	// `Additional Validators:`
	// * must be a valid time format
	GroupWait *string `json:"groupWait,omitempty"`

	// Match map of key:value. A set of equality matchers an alert has to fulfill to match the node.
	// `Additional Validators:`
	// * should not contain more than 5 keys
	// * each key and value should not be longer than 200 characters
	// * key and values should only include the characters: a-zA-Z0-9_./@&?:-
	Match *map[string]interface{} `json:"match,omitempty"`

	// MatchRe map of key:value. A set of regex-matchers an alert has to fulfill to match the node.
	// `Additional Validators:`
	// * should not contain more than 5 keys
	// * each key and value should not be longer than 200 characters
	MatchRe *map[string]interface{} `json:"matchRe,omitempty"`

	// Matchers A list of matchers that an alert has to fulfill to match the node. A matcher is a string with a syntax inspired by PromQL and OpenMetrics. The syntax of a matcher consists of three tokens:
	// * A valid Prometheus label name.
	// * One of =, !=, =~, or !~. = means equals, != means that the strings are not equal, =~ is used for equality of regex expressions and !~ is used for un-equality of regex expressions. They have the same meaning as known from PromQL selectors.
	// * A UTF-8 string, which may be enclosed in double quotes. Before or after each token, there may be any amount of whitespace.
	// `Additional Validators:`
	// * should not contain more than 5 keys
	// * each key and value should not be longer than 200 characters
	Matchers *[]string `json:"matchers,omitempty"`

	// Receiver Receiver that should be one item of receivers
	// `Additional Validators:`
	// * must be a in name of receivers
	Receiver string `json:"receiver"`

	// RepeatInterval How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).
	// `Additional Validators:`
	// * must be a valid time format
	RepeatInterval *string `json:"repeatInterval,omitempty"`

	// Routes Zero or more child routes.
	Routes *[]struct {
		GroupBy *[]string `json:"groupBy,omitempty"`

		// GroupInterval As in one level above
		GroupInterval *string `json:"groupInterval,omitempty"`

		// GroupWait As in one level above
		GroupWait *string `json:"groupWait,omitempty"`

		// Match As in one level above
		Match *map[string]interface{} `json:"match,omitempty"`

		// MatchRe As in one level above
		MatchRe *map[string]interface{} `json:"matchRe,omitempty"`

		// Receiver As in one level above
		Receiver *string `json:"receiver,omitempty"`

		// RepeatInterval As in one level above
		RepeatInterval *string `json:"repeatInterval,omitempty"`

		// Routes Another child routes
		Routes *[]map[string]interface{} `json:"routes,omitempty"`
	} `json:"routes,omitempty"`
}

// UpdateJSONRequestBody defines body for Update for application/json ContentType.
type UpdateJSONRequestBody UpdateJSONBody

// ReceiversCreateJSONRequestBody defines body for ReceiversCreate for application/json ContentType.
type ReceiversCreateJSONRequestBody ReceiversCreateJSONBody

// ReceiversUpdateJSONRequestBody defines body for ReceiversUpdate for application/json ContentType.
type ReceiversUpdateJSONRequestBody ReceiversUpdateJSONBody

// RoutesCreateJSONRequestBody defines body for RoutesCreate for application/json ContentType.
type RoutesCreateJSONRequestBody RoutesCreateJSONBody

// RoutesUpdateJSONRequestBody defines body for RoutesUpdate for application/json ContentType.
type RoutesUpdateJSONRequestBody RoutesUpdateJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client common.Client
}

// Creates a new Client, with reasonable defaults
func NewClient(server string, httpClient common.Client) *Client {
	// create a client with sane default values
	client := Client{
		Server: server,
		Client: httpClient,
	}
	return &client
}

// The interface specification for the client above.
type ClientInterface interface {
	// List request
	List(ctx context.Context, projectID string, instanceID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Update request with any body
	UpdateWithBody(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Update(ctx context.Context, projectID string, instanceID string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReceiversList request
	ReceiversList(ctx context.Context, projectID string, instanceID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReceiversCreate request with any body
	ReceiversCreateWithBody(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReceiversCreate(ctx context.Context, projectID string, instanceID string, body ReceiversCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReceiversDelete request
	ReceiversDelete(ctx context.Context, projectID string, instanceID string, receiver string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReceiversRead request
	ReceiversRead(ctx context.Context, projectID string, instanceID string, receiver string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReceiversUpdate request with any body
	ReceiversUpdateWithBody(ctx context.Context, projectID string, instanceID string, receiver string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReceiversUpdate(ctx context.Context, projectID string, instanceID string, receiver string, body ReceiversUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RoutesList request
	RoutesList(ctx context.Context, projectID string, instanceID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RoutesCreate request with any body
	RoutesCreateWithBody(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RoutesCreate(ctx context.Context, projectID string, instanceID string, body RoutesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RoutesDelete request
	RoutesDelete(ctx context.Context, projectID string, instanceID string, receiver string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RoutesRead request
	RoutesRead(ctx context.Context, projectID string, instanceID string, receiver string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RoutesUpdate request with any body
	RoutesUpdateWithBody(ctx context.Context, projectID string, instanceID string, receiver string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RoutesUpdate(ctx context.Context, projectID string, instanceID string, receiver string, body RoutesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) List(ctx context.Context, projectID string, instanceID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRequest(ctx, c.Server, projectID, instanceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWithBody(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequestWithBody(ctx, c.Server, projectID, instanceID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Update(ctx context.Context, projectID string, instanceID string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequest(ctx, c.Server, projectID, instanceID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiversList(ctx context.Context, projectID string, instanceID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiversListRequest(ctx, c.Server, projectID, instanceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiversCreateWithBody(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiversCreateRequestWithBody(ctx, c.Server, projectID, instanceID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiversCreate(ctx context.Context, projectID string, instanceID string, body ReceiversCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiversCreateRequest(ctx, c.Server, projectID, instanceID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiversDelete(ctx context.Context, projectID string, instanceID string, receiver string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiversDeleteRequest(ctx, c.Server, projectID, instanceID, receiver)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiversRead(ctx context.Context, projectID string, instanceID string, receiver string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiversReadRequest(ctx, c.Server, projectID, instanceID, receiver)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiversUpdateWithBody(ctx context.Context, projectID string, instanceID string, receiver string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiversUpdateRequestWithBody(ctx, c.Server, projectID, instanceID, receiver, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiversUpdate(ctx context.Context, projectID string, instanceID string, receiver string, body ReceiversUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiversUpdateRequest(ctx, c.Server, projectID, instanceID, receiver, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RoutesList(ctx context.Context, projectID string, instanceID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRoutesListRequest(ctx, c.Server, projectID, instanceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RoutesCreateWithBody(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRoutesCreateRequestWithBody(ctx, c.Server, projectID, instanceID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RoutesCreate(ctx context.Context, projectID string, instanceID string, body RoutesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRoutesCreateRequest(ctx, c.Server, projectID, instanceID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RoutesDelete(ctx context.Context, projectID string, instanceID string, receiver string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRoutesDeleteRequest(ctx, c.Server, projectID, instanceID, receiver)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RoutesRead(ctx context.Context, projectID string, instanceID string, receiver string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRoutesReadRequest(ctx, c.Server, projectID, instanceID, receiver)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RoutesUpdateWithBody(ctx context.Context, projectID string, instanceID string, receiver string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRoutesUpdateRequestWithBody(ctx, c.Server, projectID, instanceID, receiver, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RoutesUpdate(ctx context.Context, projectID string, instanceID string, receiver string, body RoutesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRoutesUpdateRequest(ctx, c.Server, projectID, instanceID, receiver, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListRequest generates requests for List
func NewListRequest(ctx context.Context, server string, projectID string, instanceID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRequest calls the generic Update builder with application/json body
func NewUpdateRequest(ctx context.Context, server string, projectID string, instanceID string, body UpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRequestWithBody(ctx, server, projectID, instanceID, "application/json", bodyReader)
}

// NewUpdateRequestWithBody generates requests for Update with any type of body
func NewUpdateRequestWithBody(ctx context.Context, server string, projectID string, instanceID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReceiversListRequest generates requests for ReceiversList
func NewReceiversListRequest(ctx context.Context, server string, projectID string, instanceID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/receivers", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReceiversCreateRequest calls the generic ReceiversCreate builder with application/json body
func NewReceiversCreateRequest(ctx context.Context, server string, projectID string, instanceID string, body ReceiversCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReceiversCreateRequestWithBody(ctx, server, projectID, instanceID, "application/json", bodyReader)
}

// NewReceiversCreateRequestWithBody generates requests for ReceiversCreate with any type of body
func NewReceiversCreateRequestWithBody(ctx context.Context, server string, projectID string, instanceID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/receivers", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReceiversDeleteRequest generates requests for ReceiversDelete
func NewReceiversDeleteRequest(ctx context.Context, server string, projectID string, instanceID string, receiver string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "receiver", runtime.ParamLocationPath, receiver)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/receivers/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReceiversReadRequest generates requests for ReceiversRead
func NewReceiversReadRequest(ctx context.Context, server string, projectID string, instanceID string, receiver string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "receiver", runtime.ParamLocationPath, receiver)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/receivers/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReceiversUpdateRequest calls the generic ReceiversUpdate builder with application/json body
func NewReceiversUpdateRequest(ctx context.Context, server string, projectID string, instanceID string, receiver string, body ReceiversUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReceiversUpdateRequestWithBody(ctx, server, projectID, instanceID, receiver, "application/json", bodyReader)
}

// NewReceiversUpdateRequestWithBody generates requests for ReceiversUpdate with any type of body
func NewReceiversUpdateRequestWithBody(ctx context.Context, server string, projectID string, instanceID string, receiver string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "receiver", runtime.ParamLocationPath, receiver)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/receivers/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRoutesListRequest generates requests for RoutesList
func NewRoutesListRequest(ctx context.Context, server string, projectID string, instanceID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/routes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRoutesCreateRequest calls the generic RoutesCreate builder with application/json body
func NewRoutesCreateRequest(ctx context.Context, server string, projectID string, instanceID string, body RoutesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRoutesCreateRequestWithBody(ctx, server, projectID, instanceID, "application/json", bodyReader)
}

// NewRoutesCreateRequestWithBody generates requests for RoutesCreate with any type of body
func NewRoutesCreateRequestWithBody(ctx context.Context, server string, projectID string, instanceID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/routes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRoutesDeleteRequest generates requests for RoutesDelete
func NewRoutesDeleteRequest(ctx context.Context, server string, projectID string, instanceID string, receiver string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "receiver", runtime.ParamLocationPath, receiver)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/routes/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRoutesReadRequest generates requests for RoutesRead
func NewRoutesReadRequest(ctx context.Context, server string, projectID string, instanceID string, receiver string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "receiver", runtime.ParamLocationPath, receiver)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/routes/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRoutesUpdateRequest calls the generic RoutesUpdate builder with application/json body
func NewRoutesUpdateRequest(ctx context.Context, server string, projectID string, instanceID string, receiver string, body RoutesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRoutesUpdateRequestWithBody(ctx, server, projectID, instanceID, receiver, "application/json", bodyReader)
}

// NewRoutesUpdateRequestWithBody generates requests for RoutesUpdate with any type of body
func NewRoutesUpdateRequestWithBody(ctx context.Context, server string, projectID string, instanceID string, receiver string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "receiver", runtime.ParamLocationPath, receiver)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/routes/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, httpClient common.Client) *ClientWithResponses {
	return &ClientWithResponses{NewClient(server, httpClient)}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// List request
	ListWithResponse(ctx context.Context, projectID string, instanceID string, reqEditors ...RequestEditorFn) (*ListResponse, error)

	// Update request with any body
	UpdateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResponse, error)

	UpdateWithResponse(ctx context.Context, projectID string, instanceID string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResponse, error)

	// ReceiversList request
	ReceiversListWithResponse(ctx context.Context, projectID string, instanceID string, reqEditors ...RequestEditorFn) (*ReceiversListResponse, error)

	// ReceiversCreate request with any body
	ReceiversCreateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiversCreateResponse, error)

	ReceiversCreateWithResponse(ctx context.Context, projectID string, instanceID string, body ReceiversCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReceiversCreateResponse, error)

	// ReceiversDelete request
	ReceiversDeleteWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, reqEditors ...RequestEditorFn) (*ReceiversDeleteResponse, error)

	// ReceiversRead request
	ReceiversReadWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, reqEditors ...RequestEditorFn) (*ReceiversReadResponse, error)

	// ReceiversUpdate request with any body
	ReceiversUpdateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiversUpdateResponse, error)

	ReceiversUpdateWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, body ReceiversUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReceiversUpdateResponse, error)

	// RoutesList request
	RoutesListWithResponse(ctx context.Context, projectID string, instanceID string, reqEditors ...RequestEditorFn) (*RoutesListResponse, error)

	// RoutesCreate request with any body
	RoutesCreateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RoutesCreateResponse, error)

	RoutesCreateWithResponse(ctx context.Context, projectID string, instanceID string, body RoutesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*RoutesCreateResponse, error)

	// RoutesDelete request
	RoutesDeleteWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, reqEditors ...RequestEditorFn) (*RoutesDeleteResponse, error)

	// RoutesRead request
	RoutesReadWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, reqEditors ...RequestEditorFn) (*RoutesReadResponse, error)

	// RoutesUpdate request with any body
	RoutesUpdateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RoutesUpdateResponse, error)

	RoutesUpdateWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, body RoutesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*RoutesUpdateResponse, error)
}

type ListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAlert
	JSON403      *PermissionDenied
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r ListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *PutAlert
	JSON400      *Error
	JSON403      *PermissionDenied
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r UpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReceiversListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReceiversResponse
	JSON403      *PermissionDenied
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r ReceiversListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReceiversListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReceiversCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ReceiversResponse
	JSON400      *Error
	JSON403      *PermissionDenied
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r ReceiversCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReceiversCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReceiversDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ReceiversResponse
	JSON403      *PermissionDenied
	JSON404      *Message
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r ReceiversDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReceiversDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReceiversReadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReceiversResponseSerializerSingle
	JSON403      *PermissionDenied
	JSON404      *Message
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r ReceiversReadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReceiversReadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReceiversUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ReceiversResponse
	JSON400      *Error
	JSON403      *PermissionDenied
	JSON404      *Message
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r ReceiversUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReceiversUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RoutesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RouteResponse
	JSON403      *PermissionDenied
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r RoutesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RoutesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RoutesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RouteResponse
	JSON400      *Error
	JSON403      *PermissionDenied
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r RoutesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RoutesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RoutesDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RouteResponse
	JSON403      *PermissionDenied
	JSON404      *Message
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r RoutesDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RoutesDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RoutesReadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RouteResponse
	JSON403      *PermissionDenied
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r RoutesReadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RoutesReadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RoutesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RouteResponse
	JSON400      *Error
	JSON403      *PermissionDenied
	JSON404      *Message
	HasError     error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r RoutesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RoutesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListWithResponse request returning *ListResponse
func (c *ClientWithResponses) ListWithResponse(ctx context.Context, projectID string, instanceID string, reqEditors ...RequestEditorFn) (*ListResponse, error) {
	rsp, err := c.List(ctx, projectID, instanceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseListResponse(rsp)
}

// UpdateWithBodyWithResponse request with arbitrary body returning *UpdateResponse
func (c *ClientWithResponses) UpdateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResponse, error) {
	rsp, err := c.UpdateWithBody(ctx, projectID, instanceID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseUpdateResponse(rsp)
}

func (c *ClientWithResponses) UpdateWithResponse(ctx context.Context, projectID string, instanceID string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResponse, error) {
	rsp, err := c.Update(ctx, projectID, instanceID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseUpdateResponse(rsp)
}

// ReceiversListWithResponse request returning *ReceiversListResponse
func (c *ClientWithResponses) ReceiversListWithResponse(ctx context.Context, projectID string, instanceID string, reqEditors ...RequestEditorFn) (*ReceiversListResponse, error) {
	rsp, err := c.ReceiversList(ctx, projectID, instanceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseReceiversListResponse(rsp)
}

// ReceiversCreateWithBodyWithResponse request with arbitrary body returning *ReceiversCreateResponse
func (c *ClientWithResponses) ReceiversCreateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiversCreateResponse, error) {
	rsp, err := c.ReceiversCreateWithBody(ctx, projectID, instanceID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseReceiversCreateResponse(rsp)
}

func (c *ClientWithResponses) ReceiversCreateWithResponse(ctx context.Context, projectID string, instanceID string, body ReceiversCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReceiversCreateResponse, error) {
	rsp, err := c.ReceiversCreate(ctx, projectID, instanceID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseReceiversCreateResponse(rsp)
}

// ReceiversDeleteWithResponse request returning *ReceiversDeleteResponse
func (c *ClientWithResponses) ReceiversDeleteWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, reqEditors ...RequestEditorFn) (*ReceiversDeleteResponse, error) {
	rsp, err := c.ReceiversDelete(ctx, projectID, instanceID, receiver, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseReceiversDeleteResponse(rsp)
}

// ReceiversReadWithResponse request returning *ReceiversReadResponse
func (c *ClientWithResponses) ReceiversReadWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, reqEditors ...RequestEditorFn) (*ReceiversReadResponse, error) {
	rsp, err := c.ReceiversRead(ctx, projectID, instanceID, receiver, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseReceiversReadResponse(rsp)
}

// ReceiversUpdateWithBodyWithResponse request with arbitrary body returning *ReceiversUpdateResponse
func (c *ClientWithResponses) ReceiversUpdateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiversUpdateResponse, error) {
	rsp, err := c.ReceiversUpdateWithBody(ctx, projectID, instanceID, receiver, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseReceiversUpdateResponse(rsp)
}

func (c *ClientWithResponses) ReceiversUpdateWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, body ReceiversUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReceiversUpdateResponse, error) {
	rsp, err := c.ReceiversUpdate(ctx, projectID, instanceID, receiver, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseReceiversUpdateResponse(rsp)
}

// RoutesListWithResponse request returning *RoutesListResponse
func (c *ClientWithResponses) RoutesListWithResponse(ctx context.Context, projectID string, instanceID string, reqEditors ...RequestEditorFn) (*RoutesListResponse, error) {
	rsp, err := c.RoutesList(ctx, projectID, instanceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseRoutesListResponse(rsp)
}

// RoutesCreateWithBodyWithResponse request with arbitrary body returning *RoutesCreateResponse
func (c *ClientWithResponses) RoutesCreateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RoutesCreateResponse, error) {
	rsp, err := c.RoutesCreateWithBody(ctx, projectID, instanceID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseRoutesCreateResponse(rsp)
}

func (c *ClientWithResponses) RoutesCreateWithResponse(ctx context.Context, projectID string, instanceID string, body RoutesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*RoutesCreateResponse, error) {
	rsp, err := c.RoutesCreate(ctx, projectID, instanceID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseRoutesCreateResponse(rsp)
}

// RoutesDeleteWithResponse request returning *RoutesDeleteResponse
func (c *ClientWithResponses) RoutesDeleteWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, reqEditors ...RequestEditorFn) (*RoutesDeleteResponse, error) {
	rsp, err := c.RoutesDelete(ctx, projectID, instanceID, receiver, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseRoutesDeleteResponse(rsp)
}

// RoutesReadWithResponse request returning *RoutesReadResponse
func (c *ClientWithResponses) RoutesReadWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, reqEditors ...RequestEditorFn) (*RoutesReadResponse, error) {
	rsp, err := c.RoutesRead(ctx, projectID, instanceID, receiver, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseRoutesReadResponse(rsp)
}

// RoutesUpdateWithBodyWithResponse request with arbitrary body returning *RoutesUpdateResponse
func (c *ClientWithResponses) RoutesUpdateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RoutesUpdateResponse, error) {
	rsp, err := c.RoutesUpdateWithBody(ctx, projectID, instanceID, receiver, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseRoutesUpdateResponse(rsp)
}

func (c *ClientWithResponses) RoutesUpdateWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, body RoutesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*RoutesUpdateResponse, error) {
	rsp, err := c.RoutesUpdate(ctx, projectID, instanceID, receiver, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseRoutesUpdateResponse(rsp)
}

// ParseListResponse parses an HTTP response from a ListWithResponse call
func (c *ClientWithResponses) ParseListResponse(rsp *http.Response) (*ListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAlert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdateResponse parses an HTTP response from a UpdateWithResponse call
func (c *ClientWithResponses) ParseUpdateResponse(rsp *http.Response) (*UpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PutAlert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseReceiversListResponse parses an HTTP response from a ReceiversListWithResponse call
func (c *ClientWithResponses) ParseReceiversListResponse(rsp *http.Response) (*ReceiversListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReceiversListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReceiversResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseReceiversCreateResponse parses an HTTP response from a ReceiversCreateWithResponse call
func (c *ClientWithResponses) ParseReceiversCreateResponse(rsp *http.Response) (*ReceiversCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReceiversCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ReceiversResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseReceiversDeleteResponse parses an HTTP response from a ReceiversDeleteWithResponse call
func (c *ClientWithResponses) ParseReceiversDeleteResponse(rsp *http.Response) (*ReceiversDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReceiversDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ReceiversResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReceiversReadResponse parses an HTTP response from a ReceiversReadWithResponse call
func (c *ClientWithResponses) ParseReceiversReadResponse(rsp *http.Response) (*ReceiversReadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReceiversReadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReceiversResponseSerializerSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReceiversUpdateResponse parses an HTTP response from a ReceiversUpdateWithResponse call
func (c *ClientWithResponses) ParseReceiversUpdateResponse(rsp *http.Response) (*ReceiversUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReceiversUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ReceiversResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRoutesListResponse parses an HTTP response from a RoutesListWithResponse call
func (c *ClientWithResponses) ParseRoutesListResponse(rsp *http.Response) (*RoutesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RoutesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RouteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseRoutesCreateResponse parses an HTTP response from a RoutesCreateWithResponse call
func (c *ClientWithResponses) ParseRoutesCreateResponse(rsp *http.Response) (*RoutesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RoutesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RouteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseRoutesDeleteResponse parses an HTTP response from a RoutesDeleteWithResponse call
func (c *ClientWithResponses) ParseRoutesDeleteResponse(rsp *http.Response) (*RoutesDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RoutesDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RouteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRoutesReadResponse parses an HTTP response from a RoutesReadWithResponse call
func (c *ClientWithResponses) ParseRoutesReadResponse(rsp *http.Response) (*RoutesReadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RoutesReadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RouteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseRoutesUpdateResponse parses an HTTP response from a RoutesUpdateWithResponse call
func (c *ClientWithResponses) ParseRoutesUpdateResponse(rsp *http.Response) (*RoutesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RoutesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.HasError = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RouteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
