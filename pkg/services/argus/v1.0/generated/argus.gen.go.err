error formatting Go code // Package alert config provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/do87/oapi-codegen version v0.4.0 DO NOT EDIT.
package alert config

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"encoding/xml"
	"errors"
	"fmt"
	"gopkg.in/yaml.v2"
	"io"
	"os"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/do87/oapi-codegen/pkg/runtime"
	openapi_types "github.com/do87/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/labstack/echo/v4"
	"github.com/gin-gonic/gin"
	"github.com/gorilla/mux"
	"github.com/SchwarzIT/community-stackit-go-client/pkg/validate"
	common "github.com/SchwarzIT/community-stackit-go-client/internal/common"
)

const (
BearerAuthScopes = "bearerAuth.Scopes"

)





// Alert defines model for Alert.
type Alert  struct {
    Global *Global`json:"global,omitempty"`
    InhibitRules *[]InhibitRules`json:"inhibitRules,omitempty"`
    Receivers []Receivers`json:"receivers"`
    Route Route`json:"route"`
}

// EmailConfig defines model for EmailConfig.
type EmailConfig  struct {
    AuthIdentity *openapi_types.Email`json:"authIdentity,omitempty"`
    AuthPassword *string`json:"authPassword,omitempty"`
    AuthUsername *string`json:"authUsername,omitempty"`
    From *openapi_types.Email`json:"from,omitempty"`
    SendResolved *bool`json:"sendResolved,omitempty"`
    Smarthost *string`json:"smarthost,omitempty"`
    To openapi_types.Email`json:"to"`
}

// Error defines model for Error.
type Error  struct {
    Errors *[]map[string]string`json:"errors,omitempty"`
    Message string`json:"message"`
}

// GetAlert defines model for GetAlert.
type GetAlert  struct {
    Data Alert`json:"data"`
    Message string`json:"message"`
}

// Global defines model for Global.
type Global  struct {
    OpsgenieApiKey *string`json:"opsgenieApiKey,omitempty"`
    OpsgenieApiUrl *string`json:"opsgenieApiUrl,omitempty"`
    ResolveTimeout *string`json:"resolveTimeout,omitempty"`
    SmtpAuthIdentity *openapi_types.Email`json:"smtpAuthIdentity,omitempty"`
    SmtpAuthPassword *string`json:"smtpAuthPassword,omitempty"`
    SmtpAuthUsername *string`json:"smtpAuthUsername,omitempty"`
    SmtpFrom *openapi_types.Email`json:"smtpFrom,omitempty"`
    SmtpSmarthost *string`json:"smtpSmarthost,omitempty"`
}

// InhibitRules defines model for InhibitRules.
type InhibitRules  struct {
    Equal *[]string`json:"equal,omitempty"`
    SourceMatch *map[string]string`json:"sourceMatch,omitempty"`
    SourceMatchRe *map[string]string`json:"sourceMatchRe,omitempty"`
    SourceMatchers *[]string`json:"sourceMatchers,omitempty"`
    TargetMatch *map[string]string`json:"targetMatch,omitempty"`
    TargetMatchRe *map[string]string`json:"targetMatchRe,omitempty"`
    TargetMatchers *[]string`json:"targetMatchers,omitempty"`
}

// Message defines model for Message.
type Message  struct {
    Message string`json:"message"`
}

// OpsgenieConfig defines model for OpsgenieConfig.
type OpsgenieConfig  struct {
    ApiKey *string`json:"apiKey,omitempty"`
    ApiUrl *string`json:"apiUrl,omitempty"`
    Priority *string`json:"priority,omitempty"`
    SendResolved *bool`json:"sendResolved,omitempty"`
    Tags *string`json:"tags,omitempty"`
}

// PermissionDenied defines model for PermissionDenied.
type PermissionDenied  struct {
    Detail string`json:"detail"`
}

// PutAlert defines model for PutAlert.
type PutAlert  struct {
    Data Alert`json:"data"`
    Message string`json:"message"`
}

// Receivers defines model for Receivers.
type Receivers  struct {
    EmailConfigs *[]EmailConfig`json:"emailConfigs,omitempty"`
    Name string`json:"name"`
    OpsgenieConfigs *[]OpsgenieConfig`json:"opsgenieConfigs,omitempty"`
    WebHookConfigs *[]WebHook`json:"webHookConfigs,omitempty"`
}

// ReceiversResponse defines model for ReceiversResponse.
type ReceiversResponse  struct {
    Data []Receivers`json:"data"`
    Message string`json:"message"`
}

// ReceiversResponseSerializerSingle defines model for ReceiversResponseSerializerSingle.
type ReceiversResponseSerializerSingle  struct {
    Data Receivers`json:"data"`
    Message string`json:"message"`
}

// Route defines model for Route.
type Route  struct {
    Continue *bool`json:"continue,omitempty"`
    GroupBy *[]string`json:"groupBy,omitempty"`
    GroupInterval *string`json:"groupInterval,omitempty"`
    GroupWait *string`json:"groupWait,omitempty"`
    Match *map[string]string`json:"match,omitempty"`
    MatchRe *map[string]string`json:"matchRe,omitempty"`
    Receiver string`json:"receiver"`
    RepeatInterval *string`json:"repeatInterval,omitempty"`
    Routes *[]RouteSerializer2`json:"routes,omitempty"`
}

// RouteResponse defines model for RouteResponse.
type RouteResponse  struct {
    Data Route`json:"data"`
    Message string`json:"message"`
}

// RouteSerializer2 defines model for RouteSerializer2.
type RouteSerializer2  struct {
    Continue *bool`json:"continue,omitempty"`
    GroupBy *[]string`json:"groupBy,omitempty"`
    GroupInterval *string`json:"groupInterval,omitempty"`
    GroupWait *string`json:"groupWait,omitempty"`
    Match *map[string]string`json:"match,omitempty"`
    MatchRe *map[string]string`json:"matchRe,omitempty"`
    Matchers *[]string`json:"matchers,omitempty"`
    Receiver string`json:"receiver"`
    RepeatInterval *string`json:"repeatInterval,omitempty"`
    Routes *[]map[string]string`json:"routes,omitempty"`
}

// WebHook defines model for WebHook.
type WebHook  struct {
    MsTeams *bool`json:"msTeams,omitempty"`
    SendResolved *bool`json:"sendResolved,omitempty"`
    Url string`json:"url"`
}



// V1ProjectsInstancesAlertconfigsListParams defines parameters for V1ProjectsInstancesAlertconfigsList.
type V1ProjectsInstancesAlertconfigsListParams  struct {
// Authorization Accepts technical credentials and api gateway access.
    Authorization string`json:"Authorization"`
}



// V1ProjectsInstancesAlertconfigsUpdateJSONBody defines parameters for V1ProjectsInstancesAlertconfigsUpdate.
type V1ProjectsInstancesAlertconfigsUpdateJSONBody  struct {
// Global Global config. If nothing passed the default argus config will be used.
    Global *struct {
// OpsgenieApiKey Opsgenie api key
// `Additional Validators:`
// * should only include the characters: a-zA-Z0-9-
    OpsgenieApiKey *string`json:"opsgenieApiKey,omitempty"`

// OpsgenieApiUrl Opsgenie api url
// `Additional Validators:`
// * must be a syntactically valid url address
    OpsgenieApiUrl *string`json:"opsgenieApiUrl,omitempty"`

// ResolveTimeout ResolveTimeout is the default value used by alertmanager if the alert does not include EndsAt, after this time passes it can declare the alert as resolved if it has not been updated. This has no impact on alerts from Prometheus, as they always include EndsAt. 
// `Additional Validators:`
// * must be a valid time format
    ResolveTimeout *string`json:"resolveTimeout,omitempty"`

// SmtpAuthIdentity Auth identity.
// `Additional Validators:`
// * must be a syntactically valid email address
    SmtpAuthIdentity *string`json:"smtpAuthIdentity,omitempty"`

// SmtpAuthPassword SMTP Auth using LOGIN and PLAIN.
    SmtpAuthPassword *string`json:"smtpAuthPassword,omitempty"`

// SmtpAuthUsername SMTP Auth using CRAM-MD5, LOGIN and PLAIN. If empty, Alertmanager doesn't authenticate to the SMTP server.
    SmtpAuthUsername *string`json:"smtpAuthUsername,omitempty"`

// SmtpFrom The default SMTP From header field. 
// `Additional Validators:`
// * must be a syntactically valid email address
    SmtpFrom *string`json:"smtpFrom,omitempty"`

// SmtpSmarthost The default SMTP smarthost used for sending emails, including port number. Port number usually is 25, or 587 for SMTP over TLS (sometimes referred to as STARTTLS). Example: smtp.example.org:587 
// `Additional Validators:`
// * should only include the characters: a-zA-Z0-9_./@&?:-
    SmtpSmarthost *string`json:"smtpSmarthost,omitempty"`
}`json:"global,omitempty"`

// InhibitRules A list of inhibition rules.
    InhibitRules *struct {
// Equal Labels that must have an equal value in the source and target alert for the inhibition to take effect.
// `Additional Validators:`
// * should only include the characters: a-zA-Z0-9_./@&?:-
    Equal *[]string`json:"equal,omitempty"`

// SourceMatch map of key:value. Matchers for which one or more alerts have to exist for the inhibition to take effect.
// `Additional Validators:`
// * should not contain more than 5 keys
// * each key and value should not have more than 200 characters
// * each key and value should only include the characters: a-zA-Z0-9_./@&?:-
    SourceMatch *map[string]interface{}`json:"sourceMatch,omitempty"`

// SourceMatchRe map of key:value. Regex match
// `Additional Validators:`
// * should not contain more than 5 keys
// * each key and value should not have more than 200 characters
    SourceMatchRe *map[string]interface{}`json:"sourceMatchRe,omitempty"`

// TargetMatch map of key:value. Matchers that have to be fulfilled in the alerts to be muted.
// `Additional Validators:`
// * should not contain more than 5 keys
// * each key and value should not have more than 200 characters
// * each key and value should only include the characters: a-zA-Z0-9_./@&?:-
    TargetMatch *map[string]interface{}`json:"targetMatch,omitempty"`

// TargetMatchRe map of key:value. Matchers that have to be fulfilled in the alerts to be muted. Regex.
// `Additional Validators:`
// * should not contain more than 5 keys
// * each key and value should not have more than 200 characters
    TargetMatchRe *map[string]interface{}`json:"targetMatchRe,omitempty"`
}`json:"inhibitRules,omitempty"`

// Receivers A list of notification receivers.
    Receivers []struct {
// EmailConfigs Email configurations
    EmailConfigs *[]struct {
// AuthIdentity SMTP authentication information.
// `Additional Validators:`
// * must be a syntactically valid email address
    AuthIdentity *string`json:"authIdentity,omitempty"`

// AuthPassword SMTP authentication information.
    AuthPassword *string`json:"authPassword,omitempty"`

// AuthUsername SMTP authentication information.
    AuthUsername *string`json:"authUsername,omitempty"`

// From The sender address.
// `Additional Validators:`
// * must be a syntactically valid email address
    From *string`json:"from,omitempty"`

// Smarthost The SMTP host through which emails are sent.
// `Additional Validators:`
// * should only include the characters: a-zA-Z0-9_./@&?:-
    Smarthost *string`json:"smarthost,omitempty"`

// To The email address to send notifications to.
// `Additional Validators:`
// * must be a syntactically valid email address
    To *string`json:"to,omitempty"`
}`json:"emailConfigs,omitempty"`

// Name `Additional Validators:`
// * must be unique
// * should only include the characters: a-zA-Z0-9-
    Name string`json:"name"`

// OpsgenieConfigs Configuration for ops genie.
    OpsgenieConfigs *[]struct {
// ApiKey The API key to use when talking to the OpsGenie API.
// `Additional Validators:`
// * should only include the characters: a-zA-Z0-9-
    ApiKey *string`json:"apiKey,omitempty"`

// ApiUrl The host to send OpsGenie API requests to.
// `Additional Validators:`
// * must be a syntactically valid url address
    ApiUrl *string`json:"apiUrl,omitempty"`

// Tags Comma separated list of tags attached to the notifications.
    Tags *string`json:"tags,omitempty"`
}`json:"opsgenieConfigs,omitempty"`
    WebHookConfigs *[]struct {
// MsTeams Microsoft Teams webhooks require special handling. If you set this property to true, it is treated as such
    MsTeams *bool`json:"msTeams,omitempty"`

// Url The endpoint to send HTTP POST requests to.
// `Additional Validators:`
// * must be a syntactically valid url address
    Url *string`json:"url,omitempty"`
}`json:"webHookConfigs,omitempty"`
}`json:"receivers"`

// Route The root node of the routing tree.
    Route struct {
// GroupBy The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels use the special value '...' as the sole label name, for example: group_by: ['...']. This effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what you want, unless you have a very low alert volume or your upstream notification system performs its own grouping.
    GroupBy *[]string`json:"groupBy,omitempty"`

// GroupInterval How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.)
// `Additional Validators:`
// * must be a valid time format
    GroupInterval *string`json:"groupInterval,omitempty"`

// GroupWait How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.)
// `Additional Validators:`
// * must be a valid time format
    GroupWait *string`json:"groupWait,omitempty"`

// Match map of key:value. A set of equality matchers an alert has to fulfill to match the node. 
// `Additional Validators:`
// * should not contain more than 5 keys
// * each key and value should not be longer than 200 characters
// * key and values should only include the characters: a-zA-Z0-9_./@&?:-
    Match *map[string]interface{}`json:"match,omitempty"`

// MatchRe map of key:value. A set of regex-matchers an alert has to fulfill to match the node. 
// `Additional Validators:`
// * should not contain more than 5 keys
// * each key and value should not be longer than 200 characters
    MatchRe *map[string]interface{}`json:"matchRe,omitempty"`

// Matchers A list of matchers that an alert has to fulfill to match the node. A matcher is a string with a syntax inspired by PromQL and OpenMetrics. The syntax of a matcher consists of three tokens:
// * A valid Prometheus label name.
// * One of =, !=, =~, or !~. = means equals, != means that the strings are not equal, =~ is used for equality of regex expressions and !~ is used for un-equality of regex expressions. They have the same meaning as known from PromQL selectors.
// * A UTF-8 string, which may be enclosed in double quotes. Before or after each token, there may be any amount of whitespace.
// `Additional Validators:`
// * should not contain more than 5 keys
// * each key and value should not be longer than 200 characters
    Matchers *[]string`json:"matchers,omitempty"`

// Receiver Receiver that should be one item of receivers
// `Additional Validators:`
// * must be a in name of receivers
    Receiver string`json:"receiver"`

// RepeatInterval How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).
// `Additional Validators:`
// * must be a valid time format
    RepeatInterval *string`json:"repeatInterval,omitempty"`

// Routes Zero or more child routes.
    Routes *[]struct {
    GroupBy *[]string`json:"groupBy,omitempty"`

// GroupInterval As in one level above
    GroupInterval *string`json:"groupInterval,omitempty"`

// GroupWait As in one level above
    GroupWait *string`json:"groupWait,omitempty"`

// Match As in one level above
    Match *map[string]interface{}`json:"match,omitempty"`

// MatchRe As in one level above
    MatchRe *map[string]interface{}`json:"matchRe,omitempty"`

// Receiver As in one level above
    Receiver *string`json:"receiver,omitempty"`

// RepeatInterval As in one level above
    RepeatInterval *string`json:"repeatInterval,omitempty"`

// Routes Another child routes
    Routes *[]map[string]interface{}`json:"routes,omitempty"`
}`json:"routes,omitempty"`
}`json:"route"`
}

// V1ProjectsInstancesAlertconfigsUpdateParams defines parameters for V1ProjectsInstancesAlertconfigsUpdate.
type V1ProjectsInstancesAlertconfigsUpdateParams  struct {
// Authorization Accepts technical credentials and api gateway access.
    Authorization string`json:"Authorization"`
}



// V1ProjectsInstancesAlertconfigsReceiversListParams defines parameters for V1ProjectsInstancesAlertconfigsReceiversList.
type V1ProjectsInstancesAlertconfigsReceiversListParams  struct {
// Authorization Accepts technical credentials and api gateway access.
    Authorization string`json:"Authorization"`
}



// V1ProjectsInstancesAlertconfigsReceiversCreateJSONBody defines parameters for V1ProjectsInstancesAlertconfigsReceiversCreate.
type V1ProjectsInstancesAlertconfigsReceiversCreateJSONBody  struct {
// EmailConfigs Email configurations
    EmailConfigs *[]struct {
// AuthIdentity SMTP authentication information.
// `Additional Validators:`
// * must be a syntactically valid email address
    AuthIdentity *string`json:"authIdentity,omitempty"`

// AuthPassword SMTP authentication information.
    AuthPassword *string`json:"authPassword,omitempty"`

// AuthUsername SMTP authentication information.
    AuthUsername *string`json:"authUsername,omitempty"`

// From The sender address.
// `Additional Validators:`
// * must be a syntactically valid email address
    From *string`json:"from,omitempty"`

// Smarthost The SMTP host through which emails are sent.
// `Additional Validators:`
// * should only include the characters: a-zA-Z0-9_./@&?:-
    Smarthost *string`json:"smarthost,omitempty"`

// To The email address to send notifications to.
// `Additional Validators:`
// * must be a syntactically valid email address
    To *string`json:"to,omitempty"`
}`json:"emailConfigs,omitempty"`

// Name `Additional Validators:`
// * must be unique
// * should only include the characters: a-zA-Z0-9-
    Name string`json:"name"`

// OpsgenieConfigs Configuration for ops genie.
    OpsgenieConfigs *[]struct {
// ApiKey The API key to use when talking to the OpsGenie API.
// `Additional Validators:`
// * should only include the characters: a-zA-Z0-9-
    ApiKey *string`json:"apiKey,omitempty"`

// ApiUrl The host to send OpsGenie API requests to.
// `Additional Validators:`
// * must be a syntactically valid url address
    ApiUrl *string`json:"apiUrl,omitempty"`

// Tags Comma separated list of tags attached to the notifications.
    Tags *string`json:"tags,omitempty"`
}`json:"opsgenieConfigs,omitempty"`
    WebHookConfigs *[]struct {
// MsTeams Microsoft Teams webhooks require special handling. If you set this property to true, it is treated as such
    MsTeams *bool`json:"msTeams,omitempty"`

// Url The endpoint to send HTTP POST requests to.
// `Additional Validators:`
// * must be a syntactically valid url address
    Url *string`json:"url,omitempty"`
}`json:"webHookConfigs,omitempty"`
}

// V1ProjectsInstancesAlertconfigsReceiversCreateParams defines parameters for V1ProjectsInstancesAlertconfigsReceiversCreate.
type V1ProjectsInstancesAlertconfigsReceiversCreateParams  struct {
// Authorization Accepts technical credentials and api gateway access.
    Authorization string`json:"Authorization"`
}



// V1ProjectsInstancesAlertconfigsReceiversDeleteParams defines parameters for V1ProjectsInstancesAlertconfigsReceiversDelete.
type V1ProjectsInstancesAlertconfigsReceiversDeleteParams  struct {
// Authorization Accepts technical credentials and api gateway access.
    Authorization string`json:"Authorization"`
}



// V1ProjectsInstancesAlertconfigsReceiversReadParams defines parameters for V1ProjectsInstancesAlertconfigsReceiversRead.
type V1ProjectsInstancesAlertconfigsReceiversReadParams  struct {
// Authorization Accepts technical credentials and api gateway access.
    Authorization string`json:"Authorization"`
}



// V1ProjectsInstancesAlertconfigsReceiversUpdateJSONBody defines parameters for V1ProjectsInstancesAlertconfigsReceiversUpdate.
type V1ProjectsInstancesAlertconfigsReceiversUpdateJSONBody  struct {
// EmailConfigs Email configurations
    EmailConfigs *[]struct {
// AuthIdentity SMTP authentication information.
// `Additional Validators:`
// * must be a syntactically valid email address
    AuthIdentity *string`json:"authIdentity,omitempty"`

// AuthPassword SMTP authentication information.
    AuthPassword *string`json:"authPassword,omitempty"`

// AuthUsername SMTP authentication information.
    AuthUsername *string`json:"authUsername,omitempty"`

// From The sender address.
// `Additional Validators:`
// * must be a syntactically valid email address
    From *string`json:"from,omitempty"`

// Smarthost The SMTP host through which emails are sent.
// `Additional Validators:`
// * should only include the characters: a-zA-Z0-9_./@&?:-
    Smarthost *string`json:"smarthost,omitempty"`

// To The email address to send notifications to.
// `Additional Validators:`
// * must be a syntactically valid email address
    To *string`json:"to,omitempty"`
}`json:"emailConfigs,omitempty"`

// Name `Additional Validators:`
// * must be unique
// * should only include the characters: a-zA-Z0-9-
    Name string`json:"name"`

// OpsgenieConfigs Configuration for ops genie.
    OpsgenieConfigs *[]struct {
// ApiKey The API key to use when talking to the OpsGenie API.
// `Additional Validators:`
// * should only include the characters: a-zA-Z0-9-
    ApiKey *string`json:"apiKey,omitempty"`

// ApiUrl The host to send OpsGenie API requests to.
// `Additional Validators:`
// * must be a syntactically valid url address
    ApiUrl *string`json:"apiUrl,omitempty"`

// Tags Comma separated list of tags attached to the notifications.
    Tags *string`json:"tags,omitempty"`
}`json:"opsgenieConfigs,omitempty"`
    WebHookConfigs *[]struct {
// MsTeams Microsoft Teams webhooks require special handling. If you set this property to true, it is treated as such
    MsTeams *bool`json:"msTeams,omitempty"`

// Url The endpoint to send HTTP POST requests to.
// `Additional Validators:`
// * must be a syntactically valid url address
    Url *string`json:"url,omitempty"`
}`json:"webHookConfigs,omitempty"`
}

// V1ProjectsInstancesAlertconfigsReceiversUpdateParams defines parameters for V1ProjectsInstancesAlertconfigsReceiversUpdate.
type V1ProjectsInstancesAlertconfigsReceiversUpdateParams  struct {
// Authorization Accepts technical credentials and api gateway access.
    Authorization string`json:"Authorization"`
}



// V1ProjectsInstancesAlertconfigsRoutesListParams defines parameters for V1ProjectsInstancesAlertconfigsRoutesList.
type V1ProjectsInstancesAlertconfigsRoutesListParams  struct {
// Authorization Accepts technical credentials and api gateway access.
    Authorization string`json:"Authorization"`
}



// V1ProjectsInstancesAlertconfigsRoutesCreateJSONBody defines parameters for V1ProjectsInstancesAlertconfigsRoutesCreate.
type V1ProjectsInstancesAlertconfigsRoutesCreateJSONBody  struct {
// GroupBy The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels use the special value '...' as the sole label name, for example: group_by: ['...']. This effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what you want, unless you have a very low alert volume or your upstream notification system performs its own grouping.
    GroupBy *[]string`json:"groupBy,omitempty"`

// GroupInterval How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.)
// `Additional Validators:`
// * must be a valid time format
    GroupInterval *string`json:"groupInterval,omitempty"`

// GroupWait How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.)
// `Additional Validators:`
// * must be a valid time format
    GroupWait *string`json:"groupWait,omitempty"`

// Match map of key:value. A set of equality matchers an alert has to fulfill to match the node. 
// `Additional Validators:`
// * should not contain more than 5 keys
// * each key and value should not be longer than 200 characters
// * key and values should only include the characters: a-zA-Z0-9_./@&?:-
    Match *map[string]interface{}`json:"match,omitempty"`

// MatchRe map of key:value. A set of regex-matchers an alert has to fulfill to match the node. 
// `Additional Validators:`
// * should not contain more than 5 keys
// * each key and value should not be longer than 200 characters
    MatchRe *map[string]interface{}`json:"matchRe,omitempty"`

// Matchers A list of matchers that an alert has to fulfill to match the node. A matcher is a string with a syntax inspired by PromQL and OpenMetrics. The syntax of a matcher consists of three tokens:
// * A valid Prometheus label name.
// * One of =, !=, =~, or !~. = means equals, != means that the strings are not equal, =~ is used for equality of regex expressions and !~ is used for un-equality of regex expressions. They have the same meaning as known from PromQL selectors.
// * A UTF-8 string, which may be enclosed in double quotes. Before or after each token, there may be any amount of whitespace.
// `Additional Validators:`
// * should not contain more than 5 keys
// * each key and value should not be longer than 200 characters
    Matchers *[]string`json:"matchers,omitempty"`

// Receiver Receiver that should be one item of receivers
// `Additional Validators:`
// * must be a in name of receivers
    Receiver string`json:"receiver"`

// RepeatInterval How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).
// `Additional Validators:`
// * must be a valid time format
    RepeatInterval *string`json:"repeatInterval,omitempty"`

// Routes Zero or more child routes.
    Routes *[]struct {
    GroupBy *[]string`json:"groupBy,omitempty"`

// GroupInterval As in one level above
    GroupInterval *string`json:"groupInterval,omitempty"`

// GroupWait As in one level above
    GroupWait *string`json:"groupWait,omitempty"`

// Match As in one level above
    Match *map[string]interface{}`json:"match,omitempty"`

// MatchRe As in one level above
    MatchRe *map[string]interface{}`json:"matchRe,omitempty"`

// Receiver As in one level above
    Receiver *string`json:"receiver,omitempty"`

// RepeatInterval As in one level above
    RepeatInterval *string`json:"repeatInterval,omitempty"`

// Routes Another child routes
    Routes *[]map[string]interface{}`json:"routes,omitempty"`
}`json:"routes,omitempty"`
}

// V1ProjectsInstancesAlertconfigsRoutesCreateParams defines parameters for V1ProjectsInstancesAlertconfigsRoutesCreate.
type V1ProjectsInstancesAlertconfigsRoutesCreateParams  struct {
// Authorization Accepts technical credentials and api gateway access.
    Authorization string`json:"Authorization"`
}



// V1ProjectsInstancesAlertconfigsRoutesDeleteParams defines parameters for V1ProjectsInstancesAlertconfigsRoutesDelete.
type V1ProjectsInstancesAlertconfigsRoutesDeleteParams  struct {
// Authorization Accepts technical credentials and api gateway access.
    Authorization string`json:"Authorization"`
}



// V1ProjectsInstancesAlertconfigsRoutesReadParams defines parameters for V1ProjectsInstancesAlertconfigsRoutesRead.
type V1ProjectsInstancesAlertconfigsRoutesReadParams  struct {
// Authorization Accepts technical credentials and api gateway access.
    Authorization string`json:"Authorization"`
}



// V1ProjectsInstancesAlertconfigsRoutesUpdateJSONBody defines parameters for V1ProjectsInstancesAlertconfigsRoutesUpdate.
type V1ProjectsInstancesAlertconfigsRoutesUpdateJSONBody  struct {
// GroupBy The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels use the special value '...' as the sole label name, for example: group_by: ['...']. This effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what you want, unless you have a very low alert volume or your upstream notification system performs its own grouping.
    GroupBy *[]string`json:"groupBy,omitempty"`

// GroupInterval How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.)
// `Additional Validators:`
// * must be a valid time format
    GroupInterval *string`json:"groupInterval,omitempty"`

// GroupWait How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.)
// `Additional Validators:`
// * must be a valid time format
    GroupWait *string`json:"groupWait,omitempty"`

// Match map of key:value. A set of equality matchers an alert has to fulfill to match the node. 
// `Additional Validators:`
// * should not contain more than 5 keys
// * each key and value should not be longer than 200 characters
// * key and values should only include the characters: a-zA-Z0-9_./@&?:-
    Match *map[string]interface{}`json:"match,omitempty"`

// MatchRe map of key:value. A set of regex-matchers an alert has to fulfill to match the node. 
// `Additional Validators:`
// * should not contain more than 5 keys
// * each key and value should not be longer than 200 characters
    MatchRe *map[string]interface{}`json:"matchRe,omitempty"`

// Matchers A list of matchers that an alert has to fulfill to match the node. A matcher is a string with a syntax inspired by PromQL and OpenMetrics. The syntax of a matcher consists of three tokens:
// * A valid Prometheus label name.
// * One of =, !=, =~, or !~. = means equals, != means that the strings are not equal, =~ is used for equality of regex expressions and !~ is used for un-equality of regex expressions. They have the same meaning as known from PromQL selectors.
// * A UTF-8 string, which may be enclosed in double quotes. Before or after each token, there may be any amount of whitespace.
// `Additional Validators:`
// * should not contain more than 5 keys
// * each key and value should not be longer than 200 characters
    Matchers *[]string`json:"matchers,omitempty"`

// Receiver Receiver that should be one item of receivers
// `Additional Validators:`
// * must be a in name of receivers
    Receiver string`json:"receiver"`

// RepeatInterval How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).
// `Additional Validators:`
// * must be a valid time format
    RepeatInterval *string`json:"repeatInterval,omitempty"`

// Routes Zero or more child routes.
    Routes *[]struct {
    GroupBy *[]string`json:"groupBy,omitempty"`

// GroupInterval As in one level above
    GroupInterval *string`json:"groupInterval,omitempty"`

// GroupWait As in one level above
    GroupWait *string`json:"groupWait,omitempty"`

// Match As in one level above
    Match *map[string]interface{}`json:"match,omitempty"`

// MatchRe As in one level above
    MatchRe *map[string]interface{}`json:"matchRe,omitempty"`

// Receiver As in one level above
    Receiver *string`json:"receiver,omitempty"`

// RepeatInterval As in one level above
    RepeatInterval *string`json:"repeatInterval,omitempty"`

// Routes Another child routes
    Routes *[]map[string]interface{}`json:"routes,omitempty"`
}`json:"routes,omitempty"`
}

// V1ProjectsInstancesAlertconfigsRoutesUpdateParams defines parameters for V1ProjectsInstancesAlertconfigsRoutesUpdate.
type V1ProjectsInstancesAlertconfigsRoutesUpdateParams  struct {
// Authorization Accepts technical credentials and api gateway access.
    Authorization string`json:"Authorization"`
}








// V1ProjectsInstancesAlertconfigsUpdateJSONRequestBody defines body for V1ProjectsInstancesAlertconfigsUpdate for application/json ContentType.
type V1ProjectsInstancesAlertconfigsUpdateJSONRequestBody  V1ProjectsInstancesAlertconfigsUpdateJSONBody








// V1ProjectsInstancesAlertconfigsReceiversCreateJSONRequestBody defines body for V1ProjectsInstancesAlertconfigsReceiversCreate for application/json ContentType.
type V1ProjectsInstancesAlertconfigsReceiversCreateJSONRequestBody  V1ProjectsInstancesAlertconfigsReceiversCreateJSONBody










// V1ProjectsInstancesAlertconfigsReceiversUpdateJSONRequestBody defines body for V1ProjectsInstancesAlertconfigsReceiversUpdate for application/json ContentType.
type V1ProjectsInstancesAlertconfigsReceiversUpdateJSONRequestBody  V1ProjectsInstancesAlertconfigsReceiversUpdateJSONBody








// V1ProjectsInstancesAlertconfigsRoutesCreateJSONRequestBody defines body for V1ProjectsInstancesAlertconfigsRoutesCreate for application/json ContentType.
type V1ProjectsInstancesAlertconfigsRoutesCreateJSONRequestBody  V1ProjectsInstancesAlertconfigsRoutesCreateJSONBody










// V1ProjectsInstancesAlertconfigsRoutesUpdateJSONRequestBody defines body for V1ProjectsInstancesAlertconfigsRoutesUpdate for application/json ContentType.
type V1ProjectsInstancesAlertconfigsRoutesUpdateJSONRequestBody  V1ProjectsInstancesAlertconfigsRoutesUpdateJSONBody






// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error


// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client common.Client
}

// Creates a new Client, with reasonable defaults
func NewClient(server string, httpClient common.Client) *Client {
    // create a client with sane default values
    client := Client{
        Server: server,
        Client: httpClient,
    }
    return &client
}

// The interface specification for the client above.
type ClientInterface interface {
// V1ProjectsInstancesAlertconfigsList request
    V1ProjectsInstancesAlertconfigsList(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsListParams, reqEditors... RequestEditorFn) (*http.Response, error)

// V1ProjectsInstancesAlertconfigsUpdate request with any body
    V1ProjectsInstancesAlertconfigsUpdateWithBody(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsUpdateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    V1ProjectsInstancesAlertconfigsUpdate(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsUpdateParams, body V1ProjectsInstancesAlertconfigsUpdateJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)
    
// V1ProjectsInstancesAlertconfigsReceiversList request
    V1ProjectsInstancesAlertconfigsReceiversList(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsReceiversListParams, reqEditors... RequestEditorFn) (*http.Response, error)

// V1ProjectsInstancesAlertconfigsReceiversCreate request with any body
    V1ProjectsInstancesAlertconfigsReceiversCreateWithBody(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsReceiversCreateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    V1ProjectsInstancesAlertconfigsReceiversCreate(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsReceiversCreateParams, body V1ProjectsInstancesAlertconfigsReceiversCreateJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)
    
// V1ProjectsInstancesAlertconfigsReceiversDelete request
    V1ProjectsInstancesAlertconfigsReceiversDelete(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversDeleteParams, reqEditors... RequestEditorFn) (*http.Response, error)

// V1ProjectsInstancesAlertconfigsReceiversRead request
    V1ProjectsInstancesAlertconfigsReceiversRead(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversReadParams, reqEditors... RequestEditorFn) (*http.Response, error)

// V1ProjectsInstancesAlertconfigsReceiversUpdate request with any body
    V1ProjectsInstancesAlertconfigsReceiversUpdateWithBody(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversUpdateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    V1ProjectsInstancesAlertconfigsReceiversUpdate(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversUpdateParams, body V1ProjectsInstancesAlertconfigsReceiversUpdateJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)
    
// V1ProjectsInstancesAlertconfigsRoutesList request
    V1ProjectsInstancesAlertconfigsRoutesList(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsRoutesListParams, reqEditors... RequestEditorFn) (*http.Response, error)

// V1ProjectsInstancesAlertconfigsRoutesCreate request with any body
    V1ProjectsInstancesAlertconfigsRoutesCreateWithBody(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsRoutesCreateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    V1ProjectsInstancesAlertconfigsRoutesCreate(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsRoutesCreateParams, body V1ProjectsInstancesAlertconfigsRoutesCreateJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)
    
// V1ProjectsInstancesAlertconfigsRoutesDelete request
    V1ProjectsInstancesAlertconfigsRoutesDelete(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesDeleteParams, reqEditors... RequestEditorFn) (*http.Response, error)

// V1ProjectsInstancesAlertconfigsRoutesRead request
    V1ProjectsInstancesAlertconfigsRoutesRead(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesReadParams, reqEditors... RequestEditorFn) (*http.Response, error)

// V1ProjectsInstancesAlertconfigsRoutesUpdate request with any body
    V1ProjectsInstancesAlertconfigsRoutesUpdateWithBody(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesUpdateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    V1ProjectsInstancesAlertconfigsRoutesUpdate(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesUpdateParams, body V1ProjectsInstancesAlertconfigsRoutesUpdateJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)
    

}



func (c *Client) V1ProjectsInstancesAlertconfigsList(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsListParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewV1ProjectsInstancesAlertconfigsListRequest(ctx, c.Server, projectID, instanceID, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) V1ProjectsInstancesAlertconfigsUpdateWithBody(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsUpdateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewV1ProjectsInstancesAlertconfigsUpdateRequestWithBody(ctx, c.Server, projectID, instanceID, params, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) V1ProjectsInstancesAlertconfigsUpdate(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsUpdateParams, body V1ProjectsInstancesAlertconfigsUpdateJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewV1ProjectsInstancesAlertconfigsUpdateRequest(ctx, c.Server, projectID, instanceID, params, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) V1ProjectsInstancesAlertconfigsReceiversList(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsReceiversListParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewV1ProjectsInstancesAlertconfigsReceiversListRequest(ctx, c.Server, projectID, instanceID, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) V1ProjectsInstancesAlertconfigsReceiversCreateWithBody(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsReceiversCreateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewV1ProjectsInstancesAlertconfigsReceiversCreateRequestWithBody(ctx, c.Server, projectID, instanceID, params, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) V1ProjectsInstancesAlertconfigsReceiversCreate(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsReceiversCreateParams, body V1ProjectsInstancesAlertconfigsReceiversCreateJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewV1ProjectsInstancesAlertconfigsReceiversCreateRequest(ctx, c.Server, projectID, instanceID, params, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) V1ProjectsInstancesAlertconfigsReceiversDelete(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversDeleteParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewV1ProjectsInstancesAlertconfigsReceiversDeleteRequest(ctx, c.Server, projectID, instanceID, receiver, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) V1ProjectsInstancesAlertconfigsReceiversRead(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversReadParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewV1ProjectsInstancesAlertconfigsReceiversReadRequest(ctx, c.Server, projectID, instanceID, receiver, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) V1ProjectsInstancesAlertconfigsReceiversUpdateWithBody(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversUpdateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewV1ProjectsInstancesAlertconfigsReceiversUpdateRequestWithBody(ctx, c.Server, projectID, instanceID, receiver, params, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) V1ProjectsInstancesAlertconfigsReceiversUpdate(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversUpdateParams, body V1ProjectsInstancesAlertconfigsReceiversUpdateJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewV1ProjectsInstancesAlertconfigsReceiversUpdateRequest(ctx, c.Server, projectID, instanceID, receiver, params, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) V1ProjectsInstancesAlertconfigsRoutesList(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsRoutesListParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewV1ProjectsInstancesAlertconfigsRoutesListRequest(ctx, c.Server, projectID, instanceID, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) V1ProjectsInstancesAlertconfigsRoutesCreateWithBody(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsRoutesCreateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewV1ProjectsInstancesAlertconfigsRoutesCreateRequestWithBody(ctx, c.Server, projectID, instanceID, params, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) V1ProjectsInstancesAlertconfigsRoutesCreate(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsRoutesCreateParams, body V1ProjectsInstancesAlertconfigsRoutesCreateJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewV1ProjectsInstancesAlertconfigsRoutesCreateRequest(ctx, c.Server, projectID, instanceID, params, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) V1ProjectsInstancesAlertconfigsRoutesDelete(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesDeleteParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewV1ProjectsInstancesAlertconfigsRoutesDeleteRequest(ctx, c.Server, projectID, instanceID, receiver, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) V1ProjectsInstancesAlertconfigsRoutesRead(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesReadParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewV1ProjectsInstancesAlertconfigsRoutesReadRequest(ctx, c.Server, projectID, instanceID, receiver, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) V1ProjectsInstancesAlertconfigsRoutesUpdateWithBody(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesUpdateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewV1ProjectsInstancesAlertconfigsRoutesUpdateRequestWithBody(ctx, c.Server, projectID, instanceID, receiver, params, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) V1ProjectsInstancesAlertconfigsRoutesUpdate(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesUpdateParams, body V1ProjectsInstancesAlertconfigsRoutesUpdateJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewV1ProjectsInstancesAlertconfigsRoutesUpdateRequest(ctx, c.Server, projectID, instanceID, receiver, params, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}








// NewV1ProjectsInstancesAlertconfigsListRequest generates requests for V1ProjectsInstancesAlertconfigsList
func NewV1ProjectsInstancesAlertconfigsListRequest(ctx context.Context, server string, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsListParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs", pathParam0, pathParam1)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    

    
    var headerParam0 string
    
    
    
    headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Authorization", headerParam0)
    



    return req, nil
}



// NewV1ProjectsInstancesAlertconfigsUpdateRequest calls the generic V1ProjectsInstancesAlertconfigsUpdate builder with application/json body
func NewV1ProjectsInstancesAlertconfigsUpdateRequest(ctx context.Context, server string, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsUpdateParams, body V1ProjectsInstancesAlertconfigsUpdateJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
        if err != nil {
            return nil, err
        }
        bodyReader = bytes.NewReader(buf)
    return NewV1ProjectsInstancesAlertconfigsUpdateRequestWithBody(ctx, server, projectID, instanceID, params, "application/json", bodyReader)
}


// NewV1ProjectsInstancesAlertconfigsUpdateRequestWithBody generates requests for V1ProjectsInstancesAlertconfigsUpdate with any type of body
func NewV1ProjectsInstancesAlertconfigsUpdateRequestWithBody(ctx context.Context, server string, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsUpdateParams, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs", pathParam0, pathParam1)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequestWithContext(ctx, "PUT", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)

    
    var headerParam0 string
    
    
    
    headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Authorization", headerParam0)
    



    return req, nil
}




// NewV1ProjectsInstancesAlertconfigsReceiversListRequest generates requests for V1ProjectsInstancesAlertconfigsReceiversList
func NewV1ProjectsInstancesAlertconfigsReceiversListRequest(ctx context.Context, server string, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsReceiversListParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/receivers", pathParam0, pathParam1)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    

    
    var headerParam0 string
    
    
    
    headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Authorization", headerParam0)
    



    return req, nil
}



// NewV1ProjectsInstancesAlertconfigsReceiversCreateRequest calls the generic V1ProjectsInstancesAlertconfigsReceiversCreate builder with application/json body
func NewV1ProjectsInstancesAlertconfigsReceiversCreateRequest(ctx context.Context, server string, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsReceiversCreateParams, body V1ProjectsInstancesAlertconfigsReceiversCreateJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
        if err != nil {
            return nil, err
        }
        bodyReader = bytes.NewReader(buf)
    return NewV1ProjectsInstancesAlertconfigsReceiversCreateRequestWithBody(ctx, server, projectID, instanceID, params, "application/json", bodyReader)
}


// NewV1ProjectsInstancesAlertconfigsReceiversCreateRequestWithBody generates requests for V1ProjectsInstancesAlertconfigsReceiversCreate with any type of body
func NewV1ProjectsInstancesAlertconfigsReceiversCreateRequestWithBody(ctx context.Context, server string, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsReceiversCreateParams, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/receivers", pathParam0, pathParam1)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)

    
    var headerParam0 string
    
    
    
    headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Authorization", headerParam0)
    



    return req, nil
}




// NewV1ProjectsInstancesAlertconfigsReceiversDeleteRequest generates requests for V1ProjectsInstancesAlertconfigsReceiversDelete
func NewV1ProjectsInstancesAlertconfigsReceiversDeleteRequest(ctx context.Context, server string, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversDeleteParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
    if err != nil {
        return nil, err
    }
    

    var pathParam2 string
    
    
    
    pathParam2, err = runtime.StyleParamWithLocation("simple", false, "receiver", runtime.ParamLocationPath, receiver)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/receivers/%s", pathParam0, pathParam1, pathParam2)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    

    
    var headerParam0 string
    
    
    
    headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Authorization", headerParam0)
    



    return req, nil
}




// NewV1ProjectsInstancesAlertconfigsReceiversReadRequest generates requests for V1ProjectsInstancesAlertconfigsReceiversRead
func NewV1ProjectsInstancesAlertconfigsReceiversReadRequest(ctx context.Context, server string, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversReadParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
    if err != nil {
        return nil, err
    }
    

    var pathParam2 string
    
    
    
    pathParam2, err = runtime.StyleParamWithLocation("simple", false, "receiver", runtime.ParamLocationPath, receiver)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/receivers/%s", pathParam0, pathParam1, pathParam2)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    

    
    var headerParam0 string
    
    
    
    headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Authorization", headerParam0)
    



    return req, nil
}



// NewV1ProjectsInstancesAlertconfigsReceiversUpdateRequest calls the generic V1ProjectsInstancesAlertconfigsReceiversUpdate builder with application/json body
func NewV1ProjectsInstancesAlertconfigsReceiversUpdateRequest(ctx context.Context, server string, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversUpdateParams, body V1ProjectsInstancesAlertconfigsReceiversUpdateJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
        if err != nil {
            return nil, err
        }
        bodyReader = bytes.NewReader(buf)
    return NewV1ProjectsInstancesAlertconfigsReceiversUpdateRequestWithBody(ctx, server, projectID, instanceID, receiver, params, "application/json", bodyReader)
}


// NewV1ProjectsInstancesAlertconfigsReceiversUpdateRequestWithBody generates requests for V1ProjectsInstancesAlertconfigsReceiversUpdate with any type of body
func NewV1ProjectsInstancesAlertconfigsReceiversUpdateRequestWithBody(ctx context.Context, server string, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversUpdateParams, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
    if err != nil {
        return nil, err
    }
    

    var pathParam2 string
    
    
    
    pathParam2, err = runtime.StyleParamWithLocation("simple", false, "receiver", runtime.ParamLocationPath, receiver)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/receivers/%s", pathParam0, pathParam1, pathParam2)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequestWithContext(ctx, "PUT", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)

    
    var headerParam0 string
    
    
    
    headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Authorization", headerParam0)
    



    return req, nil
}




// NewV1ProjectsInstancesAlertconfigsRoutesListRequest generates requests for V1ProjectsInstancesAlertconfigsRoutesList
func NewV1ProjectsInstancesAlertconfigsRoutesListRequest(ctx context.Context, server string, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsRoutesListParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/routes", pathParam0, pathParam1)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    

    
    var headerParam0 string
    
    
    
    headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Authorization", headerParam0)
    



    return req, nil
}



// NewV1ProjectsInstancesAlertconfigsRoutesCreateRequest calls the generic V1ProjectsInstancesAlertconfigsRoutesCreate builder with application/json body
func NewV1ProjectsInstancesAlertconfigsRoutesCreateRequest(ctx context.Context, server string, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsRoutesCreateParams, body V1ProjectsInstancesAlertconfigsRoutesCreateJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
        if err != nil {
            return nil, err
        }
        bodyReader = bytes.NewReader(buf)
    return NewV1ProjectsInstancesAlertconfigsRoutesCreateRequestWithBody(ctx, server, projectID, instanceID, params, "application/json", bodyReader)
}


// NewV1ProjectsInstancesAlertconfigsRoutesCreateRequestWithBody generates requests for V1ProjectsInstancesAlertconfigsRoutesCreate with any type of body
func NewV1ProjectsInstancesAlertconfigsRoutesCreateRequestWithBody(ctx context.Context, server string, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsRoutesCreateParams, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/routes", pathParam0, pathParam1)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)

    
    var headerParam0 string
    
    
    
    headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Authorization", headerParam0)
    



    return req, nil
}




// NewV1ProjectsInstancesAlertconfigsRoutesDeleteRequest generates requests for V1ProjectsInstancesAlertconfigsRoutesDelete
func NewV1ProjectsInstancesAlertconfigsRoutesDeleteRequest(ctx context.Context, server string, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesDeleteParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
    if err != nil {
        return nil, err
    }
    

    var pathParam2 string
    
    
    
    pathParam2, err = runtime.StyleParamWithLocation("simple", false, "receiver", runtime.ParamLocationPath, receiver)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/routes/%s", pathParam0, pathParam1, pathParam2)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    

    
    var headerParam0 string
    
    
    
    headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Authorization", headerParam0)
    



    return req, nil
}




// NewV1ProjectsInstancesAlertconfigsRoutesReadRequest generates requests for V1ProjectsInstancesAlertconfigsRoutesRead
func NewV1ProjectsInstancesAlertconfigsRoutesReadRequest(ctx context.Context, server string, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesReadParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
    if err != nil {
        return nil, err
    }
    

    var pathParam2 string
    
    
    
    pathParam2, err = runtime.StyleParamWithLocation("simple", false, "receiver", runtime.ParamLocationPath, receiver)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/routes/%s", pathParam0, pathParam1, pathParam2)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    

    
    var headerParam0 string
    
    
    
    headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Authorization", headerParam0)
    



    return req, nil
}



// NewV1ProjectsInstancesAlertconfigsRoutesUpdateRequest calls the generic V1ProjectsInstancesAlertconfigsRoutesUpdate builder with application/json body
func NewV1ProjectsInstancesAlertconfigsRoutesUpdateRequest(ctx context.Context, server string, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesUpdateParams, body V1ProjectsInstancesAlertconfigsRoutesUpdateJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
        if err != nil {
            return nil, err
        }
        bodyReader = bytes.NewReader(buf)
    return NewV1ProjectsInstancesAlertconfigsRoutesUpdateRequestWithBody(ctx, server, projectID, instanceID, receiver, params, "application/json", bodyReader)
}


// NewV1ProjectsInstancesAlertconfigsRoutesUpdateRequestWithBody generates requests for V1ProjectsInstancesAlertconfigsRoutesUpdate with any type of body
func NewV1ProjectsInstancesAlertconfigsRoutesUpdateRequestWithBody(ctx context.Context, server string, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesUpdateParams, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
    if err != nil {
        return nil, err
    }
    

    var pathParam2 string
    
    
    
    pathParam2, err = runtime.StyleParamWithLocation("simple", false, "receiver", runtime.ParamLocationPath, receiver)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/alertconfigs/routes/%s", pathParam0, pathParam1, pathParam2)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequestWithContext(ctx, "PUT", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)

    
    var headerParam0 string
    
    
    
    headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Authorization", headerParam0)
    



    return req, nil
}



func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
    for _, r := range additionalEditors {
        if err := r(ctx, req); err != nil {
            return err
        }
    }
    return nil
}
// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
    ClientInterface
}


// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, httpClient common.Client) *ClientWithResponses{
    return &ClientWithResponses{NewClient(server, httpClient)}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
// V1ProjectsInstancesAlertconfigsList request
    V1ProjectsInstancesAlertconfigsListWithResponse(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsListParams, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsListResponse, error)

// V1ProjectsInstancesAlertconfigsUpdate request with any body
    V1ProjectsInstancesAlertconfigsUpdateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsUpdateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsUpdateResponse, error)

    V1ProjectsInstancesAlertconfigsUpdateWithResponse(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsUpdateParams, body V1ProjectsInstancesAlertconfigsUpdateJSONRequestBody, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsUpdateResponse, error)
    
// V1ProjectsInstancesAlertconfigsReceiversList request
    V1ProjectsInstancesAlertconfigsReceiversListWithResponse(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsReceiversListParams, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsReceiversListResponse, error)

// V1ProjectsInstancesAlertconfigsReceiversCreate request with any body
    V1ProjectsInstancesAlertconfigsReceiversCreateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsReceiversCreateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsReceiversCreateResponse, error)

    V1ProjectsInstancesAlertconfigsReceiversCreateWithResponse(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsReceiversCreateParams, body V1ProjectsInstancesAlertconfigsReceiversCreateJSONRequestBody, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsReceiversCreateResponse, error)
    
// V1ProjectsInstancesAlertconfigsReceiversDelete request
    V1ProjectsInstancesAlertconfigsReceiversDeleteWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversDeleteParams, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsReceiversDeleteResponse, error)

// V1ProjectsInstancesAlertconfigsReceiversRead request
    V1ProjectsInstancesAlertconfigsReceiversReadWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversReadParams, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsReceiversReadResponse, error)

// V1ProjectsInstancesAlertconfigsReceiversUpdate request with any body
    V1ProjectsInstancesAlertconfigsReceiversUpdateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversUpdateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsReceiversUpdateResponse, error)

    V1ProjectsInstancesAlertconfigsReceiversUpdateWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversUpdateParams, body V1ProjectsInstancesAlertconfigsReceiversUpdateJSONRequestBody, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsReceiversUpdateResponse, error)
    
// V1ProjectsInstancesAlertconfigsRoutesList request
    V1ProjectsInstancesAlertconfigsRoutesListWithResponse(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsRoutesListParams, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsRoutesListResponse, error)

// V1ProjectsInstancesAlertconfigsRoutesCreate request with any body
    V1ProjectsInstancesAlertconfigsRoutesCreateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsRoutesCreateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsRoutesCreateResponse, error)

    V1ProjectsInstancesAlertconfigsRoutesCreateWithResponse(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsRoutesCreateParams, body V1ProjectsInstancesAlertconfigsRoutesCreateJSONRequestBody, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsRoutesCreateResponse, error)
    
// V1ProjectsInstancesAlertconfigsRoutesDelete request
    V1ProjectsInstancesAlertconfigsRoutesDeleteWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesDeleteParams, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsRoutesDeleteResponse, error)

// V1ProjectsInstancesAlertconfigsRoutesRead request
    V1ProjectsInstancesAlertconfigsRoutesReadWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesReadParams, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsRoutesReadResponse, error)

// V1ProjectsInstancesAlertconfigsRoutesUpdate request with any body
    V1ProjectsInstancesAlertconfigsRoutesUpdateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesUpdateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsRoutesUpdateResponse, error)

    V1ProjectsInstancesAlertconfigsRoutesUpdateWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesUpdateParams, body V1ProjectsInstancesAlertconfigsRoutesUpdateJSONRequestBody, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsRoutesUpdateResponse, error)
    

}



type V1ProjectsInstancesAlertconfigsListResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *GetAlert
    JSON403 *PermissionDenied
    HasError error  // Aggregated error
}

// Status returns HTTPResponse.Status
func (r V1ProjectsInstancesAlertconfigsListResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1ProjectsInstancesAlertconfigsListResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}


type V1ProjectsInstancesAlertconfigsUpdateResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON202 *PutAlert
    JSON400 *Error
    JSON403 *PermissionDenied
    HasError error  // Aggregated error
}

// Status returns HTTPResponse.Status
func (r V1ProjectsInstancesAlertconfigsUpdateResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1ProjectsInstancesAlertconfigsUpdateResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}


type V1ProjectsInstancesAlertconfigsReceiversListResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *ReceiversResponse
    JSON403 *PermissionDenied
    HasError error  // Aggregated error
}

// Status returns HTTPResponse.Status
func (r V1ProjectsInstancesAlertconfigsReceiversListResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1ProjectsInstancesAlertconfigsReceiversListResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}


type V1ProjectsInstancesAlertconfigsReceiversCreateResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON202 *ReceiversResponse
    JSON400 *Error
    JSON403 *PermissionDenied
    HasError error  // Aggregated error
}

// Status returns HTTPResponse.Status
func (r V1ProjectsInstancesAlertconfigsReceiversCreateResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1ProjectsInstancesAlertconfigsReceiversCreateResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}


type V1ProjectsInstancesAlertconfigsReceiversDeleteResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON202 *ReceiversResponse
    JSON403 *PermissionDenied
    JSON404 *Message
    HasError error  // Aggregated error
}

// Status returns HTTPResponse.Status
func (r V1ProjectsInstancesAlertconfigsReceiversDeleteResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1ProjectsInstancesAlertconfigsReceiversDeleteResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}


type V1ProjectsInstancesAlertconfigsReceiversReadResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *ReceiversResponseSerializerSingle
    JSON403 *PermissionDenied
    JSON404 *Message
    HasError error  // Aggregated error
}

// Status returns HTTPResponse.Status
func (r V1ProjectsInstancesAlertconfigsReceiversReadResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1ProjectsInstancesAlertconfigsReceiversReadResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}


type V1ProjectsInstancesAlertconfigsReceiversUpdateResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON202 *ReceiversResponse
    JSON400 *Error
    JSON403 *PermissionDenied
    JSON404 *Message
    HasError error  // Aggregated error
}

// Status returns HTTPResponse.Status
func (r V1ProjectsInstancesAlertconfigsReceiversUpdateResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1ProjectsInstancesAlertconfigsReceiversUpdateResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}


type V1ProjectsInstancesAlertconfigsRoutesListResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *RouteResponse
    JSON403 *PermissionDenied
    HasError error  // Aggregated error
}

// Status returns HTTPResponse.Status
func (r V1ProjectsInstancesAlertconfigsRoutesListResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1ProjectsInstancesAlertconfigsRoutesListResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}


type V1ProjectsInstancesAlertconfigsRoutesCreateResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON202 *RouteResponse
    JSON400 *Error
    JSON403 *PermissionDenied
    HasError error  // Aggregated error
}

// Status returns HTTPResponse.Status
func (r V1ProjectsInstancesAlertconfigsRoutesCreateResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1ProjectsInstancesAlertconfigsRoutesCreateResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}


type V1ProjectsInstancesAlertconfigsRoutesDeleteResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON202 *RouteResponse
    JSON403 *PermissionDenied
    JSON404 *Message
    HasError error  // Aggregated error
}

// Status returns HTTPResponse.Status
func (r V1ProjectsInstancesAlertconfigsRoutesDeleteResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1ProjectsInstancesAlertconfigsRoutesDeleteResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}


type V1ProjectsInstancesAlertconfigsRoutesReadResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *RouteResponse
    JSON403 *PermissionDenied
    HasError error  // Aggregated error
}

// Status returns HTTPResponse.Status
func (r V1ProjectsInstancesAlertconfigsRoutesReadResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1ProjectsInstancesAlertconfigsRoutesReadResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}


type V1ProjectsInstancesAlertconfigsRoutesUpdateResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON202 *RouteResponse
    JSON400 *Error
    JSON403 *PermissionDenied
    JSON404 *Message
    HasError error  // Aggregated error
}

// Status returns HTTPResponse.Status
func (r V1ProjectsInstancesAlertconfigsRoutesUpdateResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1ProjectsInstancesAlertconfigsRoutesUpdateResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}






// V1ProjectsInstancesAlertconfigsListWithResponse request returning *V1ProjectsInstancesAlertconfigsListResponse
func (c *ClientWithResponses) V1ProjectsInstancesAlertconfigsListWithResponse(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsListParams, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsListResponse, error){
    rsp, err := c.V1ProjectsInstancesAlertconfigsList(ctx, projectID, instanceID, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return c.ParseV1ProjectsInstancesAlertconfigsListResponse(rsp)
}






// V1ProjectsInstancesAlertconfigsUpdateWithBodyWithResponse request with arbitrary body returning *V1ProjectsInstancesAlertconfigsUpdateResponse
func (c *ClientWithResponses) V1ProjectsInstancesAlertconfigsUpdateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsUpdateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsUpdateResponse, error){
    rsp, err := c.V1ProjectsInstancesAlertconfigsUpdateWithBody(ctx, projectID, instanceID, params, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return c.ParseV1ProjectsInstancesAlertconfigsUpdateResponse(rsp)
}


func (c *ClientWithResponses) V1ProjectsInstancesAlertconfigsUpdateWithResponse(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsUpdateParams, body V1ProjectsInstancesAlertconfigsUpdateJSONRequestBody, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsUpdateResponse, error) {
    rsp, err := c.V1ProjectsInstancesAlertconfigsUpdate(ctx, projectID, instanceID, params, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return c.ParseV1ProjectsInstancesAlertconfigsUpdateResponse(rsp)
}






// V1ProjectsInstancesAlertconfigsReceiversListWithResponse request returning *V1ProjectsInstancesAlertconfigsReceiversListResponse
func (c *ClientWithResponses) V1ProjectsInstancesAlertconfigsReceiversListWithResponse(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsReceiversListParams, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsReceiversListResponse, error){
    rsp, err := c.V1ProjectsInstancesAlertconfigsReceiversList(ctx, projectID, instanceID, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return c.ParseV1ProjectsInstancesAlertconfigsReceiversListResponse(rsp)
}






// V1ProjectsInstancesAlertconfigsReceiversCreateWithBodyWithResponse request with arbitrary body returning *V1ProjectsInstancesAlertconfigsReceiversCreateResponse
func (c *ClientWithResponses) V1ProjectsInstancesAlertconfigsReceiversCreateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsReceiversCreateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsReceiversCreateResponse, error){
    rsp, err := c.V1ProjectsInstancesAlertconfigsReceiversCreateWithBody(ctx, projectID, instanceID, params, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return c.ParseV1ProjectsInstancesAlertconfigsReceiversCreateResponse(rsp)
}


func (c *ClientWithResponses) V1ProjectsInstancesAlertconfigsReceiversCreateWithResponse(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsReceiversCreateParams, body V1ProjectsInstancesAlertconfigsReceiversCreateJSONRequestBody, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsReceiversCreateResponse, error) {
    rsp, err := c.V1ProjectsInstancesAlertconfigsReceiversCreate(ctx, projectID, instanceID, params, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return c.ParseV1ProjectsInstancesAlertconfigsReceiversCreateResponse(rsp)
}






// V1ProjectsInstancesAlertconfigsReceiversDeleteWithResponse request returning *V1ProjectsInstancesAlertconfigsReceiversDeleteResponse
func (c *ClientWithResponses) V1ProjectsInstancesAlertconfigsReceiversDeleteWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversDeleteParams, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsReceiversDeleteResponse, error){
    rsp, err := c.V1ProjectsInstancesAlertconfigsReceiversDelete(ctx, projectID, instanceID, receiver, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return c.ParseV1ProjectsInstancesAlertconfigsReceiversDeleteResponse(rsp)
}






// V1ProjectsInstancesAlertconfigsReceiversReadWithResponse request returning *V1ProjectsInstancesAlertconfigsReceiversReadResponse
func (c *ClientWithResponses) V1ProjectsInstancesAlertconfigsReceiversReadWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversReadParams, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsReceiversReadResponse, error){
    rsp, err := c.V1ProjectsInstancesAlertconfigsReceiversRead(ctx, projectID, instanceID, receiver, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return c.ParseV1ProjectsInstancesAlertconfigsReceiversReadResponse(rsp)
}






// V1ProjectsInstancesAlertconfigsReceiversUpdateWithBodyWithResponse request with arbitrary body returning *V1ProjectsInstancesAlertconfigsReceiversUpdateResponse
func (c *ClientWithResponses) V1ProjectsInstancesAlertconfigsReceiversUpdateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversUpdateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsReceiversUpdateResponse, error){
    rsp, err := c.V1ProjectsInstancesAlertconfigsReceiversUpdateWithBody(ctx, projectID, instanceID, receiver, params, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return c.ParseV1ProjectsInstancesAlertconfigsReceiversUpdateResponse(rsp)
}


func (c *ClientWithResponses) V1ProjectsInstancesAlertconfigsReceiversUpdateWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsReceiversUpdateParams, body V1ProjectsInstancesAlertconfigsReceiversUpdateJSONRequestBody, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsReceiversUpdateResponse, error) {
    rsp, err := c.V1ProjectsInstancesAlertconfigsReceiversUpdate(ctx, projectID, instanceID, receiver, params, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return c.ParseV1ProjectsInstancesAlertconfigsReceiversUpdateResponse(rsp)
}






// V1ProjectsInstancesAlertconfigsRoutesListWithResponse request returning *V1ProjectsInstancesAlertconfigsRoutesListResponse
func (c *ClientWithResponses) V1ProjectsInstancesAlertconfigsRoutesListWithResponse(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsRoutesListParams, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsRoutesListResponse, error){
    rsp, err := c.V1ProjectsInstancesAlertconfigsRoutesList(ctx, projectID, instanceID, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return c.ParseV1ProjectsInstancesAlertconfigsRoutesListResponse(rsp)
}






// V1ProjectsInstancesAlertconfigsRoutesCreateWithBodyWithResponse request with arbitrary body returning *V1ProjectsInstancesAlertconfigsRoutesCreateResponse
func (c *ClientWithResponses) V1ProjectsInstancesAlertconfigsRoutesCreateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsRoutesCreateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsRoutesCreateResponse, error){
    rsp, err := c.V1ProjectsInstancesAlertconfigsRoutesCreateWithBody(ctx, projectID, instanceID, params, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return c.ParseV1ProjectsInstancesAlertconfigsRoutesCreateResponse(rsp)
}


func (c *ClientWithResponses) V1ProjectsInstancesAlertconfigsRoutesCreateWithResponse(ctx context.Context, projectID string, instanceID string, params *V1ProjectsInstancesAlertconfigsRoutesCreateParams, body V1ProjectsInstancesAlertconfigsRoutesCreateJSONRequestBody, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsRoutesCreateResponse, error) {
    rsp, err := c.V1ProjectsInstancesAlertconfigsRoutesCreate(ctx, projectID, instanceID, params, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return c.ParseV1ProjectsInstancesAlertconfigsRoutesCreateResponse(rsp)
}






// V1ProjectsInstancesAlertconfigsRoutesDeleteWithResponse request returning *V1ProjectsInstancesAlertconfigsRoutesDeleteResponse
func (c *ClientWithResponses) V1ProjectsInstancesAlertconfigsRoutesDeleteWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesDeleteParams, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsRoutesDeleteResponse, error){
    rsp, err := c.V1ProjectsInstancesAlertconfigsRoutesDelete(ctx, projectID, instanceID, receiver, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return c.ParseV1ProjectsInstancesAlertconfigsRoutesDeleteResponse(rsp)
}






// V1ProjectsInstancesAlertconfigsRoutesReadWithResponse request returning *V1ProjectsInstancesAlertconfigsRoutesReadResponse
func (c *ClientWithResponses) V1ProjectsInstancesAlertconfigsRoutesReadWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesReadParams, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsRoutesReadResponse, error){
    rsp, err := c.V1ProjectsInstancesAlertconfigsRoutesRead(ctx, projectID, instanceID, receiver, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return c.ParseV1ProjectsInstancesAlertconfigsRoutesReadResponse(rsp)
}






// V1ProjectsInstancesAlertconfigsRoutesUpdateWithBodyWithResponse request with arbitrary body returning *V1ProjectsInstancesAlertconfigsRoutesUpdateResponse
func (c *ClientWithResponses) V1ProjectsInstancesAlertconfigsRoutesUpdateWithBodyWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesUpdateParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsRoutesUpdateResponse, error){
    rsp, err := c.V1ProjectsInstancesAlertconfigsRoutesUpdateWithBody(ctx, projectID, instanceID, receiver, params, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return c.ParseV1ProjectsInstancesAlertconfigsRoutesUpdateResponse(rsp)
}


func (c *ClientWithResponses) V1ProjectsInstancesAlertconfigsRoutesUpdateWithResponse(ctx context.Context, projectID string, instanceID string, receiver string, params *V1ProjectsInstancesAlertconfigsRoutesUpdateParams, body V1ProjectsInstancesAlertconfigsRoutesUpdateJSONRequestBody, reqEditors... RequestEditorFn) (*V1ProjectsInstancesAlertconfigsRoutesUpdateResponse, error) {
    rsp, err := c.V1ProjectsInstancesAlertconfigsRoutesUpdate(ctx, projectID, instanceID, receiver, params, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return c.ParseV1ProjectsInstancesAlertconfigsRoutesUpdateResponse(rsp)
}








// ParseV1ProjectsInstancesAlertconfigsListResponse parses an HTTP response from a V1ProjectsInstancesAlertconfigsListWithResponse call
func (c *ClientWithResponses) ParseV1ProjectsInstancesAlertconfigsListResponse(rsp *http.Response) (*V1ProjectsInstancesAlertconfigsListResponse, error) {
    bodyBytes, err := io.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &V1ProjectsInstancesAlertconfigsListResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}
    response.HasError = validate.DefaultResponseErrorHandler(rsp)

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest GetAlert
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
var dest PermissionDenied
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON403 = &dest

}


    return response, nil
}


// ParseV1ProjectsInstancesAlertconfigsUpdateResponse parses an HTTP response from a V1ProjectsInstancesAlertconfigsUpdateWithResponse call
func (c *ClientWithResponses) ParseV1ProjectsInstancesAlertconfigsUpdateResponse(rsp *http.Response) (*V1ProjectsInstancesAlertconfigsUpdateResponse, error) {
    bodyBytes, err := io.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &V1ProjectsInstancesAlertconfigsUpdateResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}
    response.HasError = validate.DefaultResponseErrorHandler(rsp)

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
var dest PutAlert
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON202 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest Error
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
var dest PermissionDenied
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON403 = &dest

}


    return response, nil
}


// ParseV1ProjectsInstancesAlertconfigsReceiversListResponse parses an HTTP response from a V1ProjectsInstancesAlertconfigsReceiversListWithResponse call
func (c *ClientWithResponses) ParseV1ProjectsInstancesAlertconfigsReceiversListResponse(rsp *http.Response) (*V1ProjectsInstancesAlertconfigsReceiversListResponse, error) {
    bodyBytes, err := io.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &V1ProjectsInstancesAlertconfigsReceiversListResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}
    response.HasError = validate.DefaultResponseErrorHandler(rsp)

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest ReceiversResponse
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
var dest PermissionDenied
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON403 = &dest

}


    return response, nil
}


// ParseV1ProjectsInstancesAlertconfigsReceiversCreateResponse parses an HTTP response from a V1ProjectsInstancesAlertconfigsReceiversCreateWithResponse call
func (c *ClientWithResponses) ParseV1ProjectsInstancesAlertconfigsReceiversCreateResponse(rsp *http.Response) (*V1ProjectsInstancesAlertconfigsReceiversCreateResponse, error) {
    bodyBytes, err := io.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &V1ProjectsInstancesAlertconfigsReceiversCreateResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}
    response.HasError = validate.DefaultResponseErrorHandler(rsp)

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
var dest ReceiversResponse
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON202 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest Error
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
var dest PermissionDenied
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON403 = &dest

}


    return response, nil
}


// ParseV1ProjectsInstancesAlertconfigsReceiversDeleteResponse parses an HTTP response from a V1ProjectsInstancesAlertconfigsReceiversDeleteWithResponse call
func (c *ClientWithResponses) ParseV1ProjectsInstancesAlertconfigsReceiversDeleteResponse(rsp *http.Response) (*V1ProjectsInstancesAlertconfigsReceiversDeleteResponse, error) {
    bodyBytes, err := io.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &V1ProjectsInstancesAlertconfigsReceiversDeleteResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}
    response.HasError = validate.DefaultResponseErrorHandler(rsp)

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
var dest ReceiversResponse
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON202 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
var dest PermissionDenied
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON403 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
var dest Message
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON404 = &dest

}


    return response, nil
}


// ParseV1ProjectsInstancesAlertconfigsReceiversReadResponse parses an HTTP response from a V1ProjectsInstancesAlertconfigsReceiversReadWithResponse call
func (c *ClientWithResponses) ParseV1ProjectsInstancesAlertconfigsReceiversReadResponse(rsp *http.Response) (*V1ProjectsInstancesAlertconfigsReceiversReadResponse, error) {
    bodyBytes, err := io.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &V1ProjectsInstancesAlertconfigsReceiversReadResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}
    response.HasError = validate.DefaultResponseErrorHandler(rsp)

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest ReceiversResponseSerializerSingle
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
var dest PermissionDenied
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON403 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
var dest Message
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON404 = &dest

}


    return response, nil
}


// ParseV1ProjectsInstancesAlertconfigsReceiversUpdateResponse parses an HTTP response from a V1ProjectsInstancesAlertconfigsReceiversUpdateWithResponse call
func (c *ClientWithResponses) ParseV1ProjectsInstancesAlertconfigsReceiversUpdateResponse(rsp *http.Response) (*V1ProjectsInstancesAlertconfigsReceiversUpdateResponse, error) {
    bodyBytes, err := io.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &V1ProjectsInstancesAlertconfigsReceiversUpdateResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}
    response.HasError = validate.DefaultResponseErrorHandler(rsp)

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
var dest ReceiversResponse
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON202 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest Error
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
var dest PermissionDenied
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON403 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
var dest Message
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON404 = &dest

}


    return response, nil
}


// ParseV1ProjectsInstancesAlertconfigsRoutesListResponse parses an HTTP response from a V1ProjectsInstancesAlertconfigsRoutesListWithResponse call
func (c *ClientWithResponses) ParseV1ProjectsInstancesAlertconfigsRoutesListResponse(rsp *http.Response) (*V1ProjectsInstancesAlertconfigsRoutesListResponse, error) {
    bodyBytes, err := io.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &V1ProjectsInstancesAlertconfigsRoutesListResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}
    response.HasError = validate.DefaultResponseErrorHandler(rsp)

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest RouteResponse
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
var dest PermissionDenied
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON403 = &dest

}


    return response, nil
}


// ParseV1ProjectsInstancesAlertconfigsRoutesCreateResponse parses an HTTP response from a V1ProjectsInstancesAlertconfigsRoutesCreateWithResponse call
func (c *ClientWithResponses) ParseV1ProjectsInstancesAlertconfigsRoutesCreateResponse(rsp *http.Response) (*V1ProjectsInstancesAlertconfigsRoutesCreateResponse, error) {
    bodyBytes, err := io.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &V1ProjectsInstancesAlertconfigsRoutesCreateResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}
    response.HasError = validate.DefaultResponseErrorHandler(rsp)

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
var dest RouteResponse
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON202 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest Error
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
var dest PermissionDenied
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON403 = &dest

}


    return response, nil
}


// ParseV1ProjectsInstancesAlertconfigsRoutesDeleteResponse parses an HTTP response from a V1ProjectsInstancesAlertconfigsRoutesDeleteWithResponse call
func (c *ClientWithResponses) ParseV1ProjectsInstancesAlertconfigsRoutesDeleteResponse(rsp *http.Response) (*V1ProjectsInstancesAlertconfigsRoutesDeleteResponse, error) {
    bodyBytes, err := io.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &V1ProjectsInstancesAlertconfigsRoutesDeleteResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}
    response.HasError = validate.DefaultResponseErrorHandler(rsp)

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
var dest RouteResponse
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON202 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
var dest PermissionDenied
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON403 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
var dest Message
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON404 = &dest

}


    return response, nil
}


// ParseV1ProjectsInstancesAlertconfigsRoutesReadResponse parses an HTTP response from a V1ProjectsInstancesAlertconfigsRoutesReadWithResponse call
func (c *ClientWithResponses) ParseV1ProjectsInstancesAlertconfigsRoutesReadResponse(rsp *http.Response) (*V1ProjectsInstancesAlertconfigsRoutesReadResponse, error) {
    bodyBytes, err := io.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &V1ProjectsInstancesAlertconfigsRoutesReadResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}
    response.HasError = validate.DefaultResponseErrorHandler(rsp)

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest RouteResponse
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
var dest PermissionDenied
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON403 = &dest

}


    return response, nil
}


// ParseV1ProjectsInstancesAlertconfigsRoutesUpdateResponse parses an HTTP response from a V1ProjectsInstancesAlertconfigsRoutesUpdateWithResponse call
func (c *ClientWithResponses) ParseV1ProjectsInstancesAlertconfigsRoutesUpdateResponse(rsp *http.Response) (*V1ProjectsInstancesAlertconfigsRoutesUpdateResponse, error) {
    bodyBytes, err := io.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &V1ProjectsInstancesAlertconfigsRoutesUpdateResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}
    response.HasError = validate.DefaultResponseErrorHandler(rsp)

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
var dest RouteResponse
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON202 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest Error
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
var dest PermissionDenied
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON403 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
var dest Message
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON404 = &dest

}


    return response, nil
}

: alert config.go:4:15: expected ';', found config