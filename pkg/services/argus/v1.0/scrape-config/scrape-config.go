// Package scrapeconfig provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/do87/stackit-client-generator version v0.0.3 DO NOT EDIT.
package scrapeconfig

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/pkg/errors"

	contracts "github.com/SchwarzIT/community-stackit-go-client/pkg/contracts"
	"github.com/SchwarzIT/community-stackit-go-client/pkg/helpers/runtime"
	"github.com/SchwarzIT/community-stackit-go-client/pkg/validate"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for JobScheme.
const (
	JOB_SCHEME_HTTP  JobScheme = "http"
	JOB_SCHEME_HTTPS JobScheme = "https"
)

// Defines values for MetricsRelabelConfigAction.
const (
	METRICS_RELABEL_CONFIG_ACTION_DROP      MetricsRelabelConfigAction = "drop"
	METRICS_RELABEL_CONFIG_ACTION_HASHMOD   MetricsRelabelConfigAction = "hashmod"
	METRICS_RELABEL_CONFIG_ACTION_KEEP      MetricsRelabelConfigAction = "keep"
	METRICS_RELABEL_CONFIG_ACTION_LABELDROP MetricsRelabelConfigAction = "labeldrop"
	METRICS_RELABEL_CONFIG_ACTION_LABELKEEP MetricsRelabelConfigAction = "labelkeep"
	METRICS_RELABEL_CONFIG_ACTION_LABELMAP  MetricsRelabelConfigAction = "labelmap"
	METRICS_RELABEL_CONFIG_ACTION_REPLACE   MetricsRelabelConfigAction = "replace"
)

// Defines values for PartialUpdateJSONBodyMetricsRelabelConfigsAction.
const (
	PARTIAL_UPDATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_DROP      PartialUpdateJSONBodyMetricsRelabelConfigsAction = "drop"
	PARTIAL_UPDATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_HASHMOD   PartialUpdateJSONBodyMetricsRelabelConfigsAction = "hashmod"
	PARTIAL_UPDATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_KEEP      PartialUpdateJSONBodyMetricsRelabelConfigsAction = "keep"
	PARTIAL_UPDATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_LABELDROP PartialUpdateJSONBodyMetricsRelabelConfigsAction = "labeldrop"
	PARTIAL_UPDATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_LABELKEEP PartialUpdateJSONBodyMetricsRelabelConfigsAction = "labelkeep"
	PARTIAL_UPDATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_LABELMAP  PartialUpdateJSONBodyMetricsRelabelConfigsAction = "labelmap"
	PARTIAL_UPDATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_REPLACE   PartialUpdateJSONBodyMetricsRelabelConfigsAction = "replace"
)

// Defines values for PartialUpdateJSONBodyScheme.
const (
	PARTIAL_UPDATE_JSON_BODY_SCHEME_HTTP  PartialUpdateJSONBodyScheme = "http"
	PARTIAL_UPDATE_JSON_BODY_SCHEME_HTTPS PartialUpdateJSONBodyScheme = "https"
)

// Defines values for CreateJSONBodyMetricsRelabelConfigsAction.
const (
	CREATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_DROP      CreateJSONBodyMetricsRelabelConfigsAction = "drop"
	CREATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_HASHMOD   CreateJSONBodyMetricsRelabelConfigsAction = "hashmod"
	CREATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_KEEP      CreateJSONBodyMetricsRelabelConfigsAction = "keep"
	CREATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_LABELDROP CreateJSONBodyMetricsRelabelConfigsAction = "labeldrop"
	CREATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_LABELKEEP CreateJSONBodyMetricsRelabelConfigsAction = "labelkeep"
	CREATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_LABELMAP  CreateJSONBodyMetricsRelabelConfigsAction = "labelmap"
	CREATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_REPLACE   CreateJSONBodyMetricsRelabelConfigsAction = "replace"
)

// Defines values for CreateJSONBodyScheme.
const (
	CREATE_JSON_BODY_SCHEME_HTTP  CreateJSONBodyScheme = "http"
	CREATE_JSON_BODY_SCHEME_HTTPS CreateJSONBodyScheme = "https"
)

// Defines values for UpdateJSONBodyMetricsRelabelConfigsAction.
const (
	UPDATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_DROP      UpdateJSONBodyMetricsRelabelConfigsAction = "drop"
	UPDATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_HASHMOD   UpdateJSONBodyMetricsRelabelConfigsAction = "hashmod"
	UPDATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_KEEP      UpdateJSONBodyMetricsRelabelConfigsAction = "keep"
	UPDATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_LABELDROP UpdateJSONBodyMetricsRelabelConfigsAction = "labeldrop"
	UPDATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_LABELKEEP UpdateJSONBodyMetricsRelabelConfigsAction = "labelkeep"
	UPDATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_LABELMAP  UpdateJSONBodyMetricsRelabelConfigsAction = "labelmap"
	UPDATE_JSON_BODY_METRICS_RELABEL_CONFIGS_ACTION_REPLACE   UpdateJSONBodyMetricsRelabelConfigsAction = "replace"
)

// Defines values for UpdateJSONBodyScheme.
const (
	UPDATE_JSON_BODY_SCHEME_HTTP  UpdateJSONBodyScheme = "http"
	UPDATE_JSON_BODY_SCHEME_HTTPS UpdateJSONBodyScheme = "https"
)

// BasicAuth defines model for BasicAuth.
type BasicAuth struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// CreateJob defines model for CreateJob.
type CreateJob struct {
	Data    []Job  `json:"data"`
	Message string `json:"message"`
}

// DeleteJob defines model for DeleteJob.
type DeleteJob struct {
	Data    []Job  `json:"data"`
	Message string `json:"message"`
}

// Error defines model for Error.
type Error struct {
	Errors  *[]map[string]string `json:"errors,omitempty"`
	Message string               `json:"message"`
}

// GetAllJob defines model for GetAllJob.
type GetAllJob struct {
	Data    []Job  `json:"data"`
	Message string `json:"message"`
}

// GetJob defines model for GetJob.
type GetJob struct {
	Data    Job    `json:"data"`
	Message string `json:"message"`
}

// HTTPServiceSD defines model for HTTPServiceSD.
type HTTPServiceSD struct {
	BasicAuth       *BasicAuth `json:"basicAuth,omitempty"`
	Oauth2          *OAuth2    `json:"oauth2,omitempty"`
	RefreshInterval *string    `json:"refreshInterval,omitempty"`
	TlsConfig       *TLSConfig `json:"tlsConfig,omitempty"`
	URL             string     `json:"url"`
}

// Job defines model for Job.
type Job struct {
	BasicAuth             *BasicAuth              `json:"basicAuth,omitempty"`
	BearerToken           *string                 `json:"bearerToken,omitempty"`
	HonorLabels           *bool                   `json:"honorLabels,omitempty"`
	HonorTimeStamps       *bool                   `json:"honorTimeStamps,omitempty"`
	HttpSdConfigs         *[]HTTPServiceSD        `json:"httpSdConfigs,omitempty"`
	JobName               string                  `json:"jobName"`
	MetricsPath           *string                 `json:"metricsPath,omitempty"`
	MetricsRelabelConfigs *[]MetricsRelabelConfig `json:"metricsRelabelConfigs,omitempty"`
	Oauth2                *OAuth2                 `json:"oauth2,omitempty"`
	Params                *map[string][]string    `json:"params,omitempty"`
	SampleLimit           *int                    `json:"sampleLimit,omitempty"`
	Scheme                *JobScheme              `json:"scheme,omitempty"`
	ScrapeInterval        string                  `json:"scrapeInterval"`
	ScrapeTimeout         string                  `json:"scrapeTimeout"`
	StaticConfigs         []StaticConfigs         `json:"staticConfigs"`
	TlsConfig             *TLSConfig              `json:"tlsConfig,omitempty"`
}

// JobScheme defines model for Job.Scheme.
type JobScheme string

// Message defines model for Message.
type Message struct {
	Message string `json:"message"`
}

// MetricsRelabelConfig defines model for MetricsRelabelConfig.
type MetricsRelabelConfig struct {
	Action       *MetricsRelabelConfigAction `json:"action,omitempty"`
	Modulus      *int                        `json:"modulus,omitempty"`
	Regex        *string                     `json:"regex,omitempty"`
	Replacement  *string                     `json:"replacement,omitempty"`
	Separator    *string                     `json:"separator,omitempty"`
	SourceLabels []string                    `json:"sourceLabels"`
	TargetLabel  *string                     `json:"targetLabel,omitempty"`
}

// MetricsRelabelConfigAction defines model for MetricsRelabelConfig.Action.
type MetricsRelabelConfigAction string

// OAuth2 defines model for OAuth2.
type OAuth2 struct {
	ClientID     string     `json:"clientId"`
	ClientSecret string     `json:"clientSecret"`
	Scopes       *[]string  `json:"scopes,omitempty"`
	TlsConfig    *TLSConfig `json:"tlsConfig,omitempty"`
	TokenURL     string     `json:"tokenUrl"`
}

// PermissionDenied defines model for PermissionDenied.
type PermissionDenied struct {
	Detail string `json:"detail"`
}

// StaticConfigs defines model for StaticConfigs.
type StaticConfigs struct {
	Labels  *map[string]string `json:"labels,omitempty"`
	Targets []string           `json:"targets"`
}

// TLSConfig defines model for TLSConfig.
type TLSConfig struct {
	InsecureSkipVerify *bool `json:"insecureSkipVerify,omitempty"`
}

// DeleteParams defines parameters for Delete.
type DeleteParams struct {
	// JobName Name of the jobs that should be deleted
	JobName []string `form:"jobName" json:"jobName"`
}

// PartialUpdateJSONBody defines parameters for PartialUpdate.
type PartialUpdateJSONBody = []struct {
	// BasicAuth Sets the 'Authorization' header on every scrape request with the configured username and password.
	// `Additional Validators:`
	// * if basicAuth is in the body no other authentication method should be in the body
	BasicAuth *struct {
		// Password password
		Password *string `json:"password,omitempty"`

		// Username username
		Username *string `json:"username,omitempty"`
	} `json:"basicAuth,omitempty"`

	// BearerToken Sets the 'Authorization' header on every scrape request with the configured bearer token. It is mutually exclusive with 'bearer_token_file'.
	// `Additional Validators:`
	// * needs to be a valid bearer token
	// * if bearerToken is in the body no other authentication method should be in the body
	BearerToken *string `json:"bearerToken,omitempty"`

	// HonorLabels Note that any globally configured 'external_labels' are unaffected by this setting. In communication with external systems, they are always applied only when a time series does not have a given label yet and are ignored otherwise.
	HonorLabels *bool `json:"honorLabels,omitempty"`

	// HonorTimeStamps honor_timestamps controls whether Prometheus respects the timestamps present in scraped data. If honor_timestamps is set to 'true', the timestamps of the metrics exposed by the target will be used.
	HonorTimeStamps *bool `json:"honorTimeStamps,omitempty"`

	// HttpSdConfigs HTTP-based service discovery provides a more generic way to configure static targets and serves as an interface to plug in custom service discovery mechanisms.
	HttpSdConfigs *[]struct {
		// BasicAuth Sets the 'Authorization' header on every scrape request with the configured username and password.
		// `Additional Validators:`
		// * if basicAuth is in the body no other authentication method should be in the body
		BasicAuth *struct {
			// Password password
			Password *string `json:"password,omitempty"`

			// Username username
			Username *string `json:"username,omitempty"`
		} `json:"basicAuth,omitempty"`

		// Oauth2 OAuth 2.0 authentication using the client credentials grant type. Prometheus fetches an access token from the specified endpoint with the given client access and secret keys.
		// `Additional Validators:`
		// * if oauth2 is in the body no other authentication method should be in the body
		Oauth2 *struct {
			// ClientId clientId
			ClientID string `json:"clientId"`

			// ClientSecret clientSecret
			ClientSecret string `json:"clientSecret"`

			// Scopes The URL to fetch the token from.
			Scopes *[]string `json:"scopes,omitempty"`

			// TlsConfig Configures the scrape request's TLS settings.
			TlsConfig *struct {
				// InsecureSkipVerify Disable validation of the server certificate.
				InsecureSkipVerify *bool `json:"insecureSkipVerify,omitempty"`
			} `json:"tlsConfig,omitempty"`

			// TokenUrl The URL to fetch the token from.
			TokenURL string `json:"tokenUrl"`
		} `json:"oauth2,omitempty"`

		// RefreshInterval Refresh interval to re-query the endpoint. E.g. 60s
		// `Additional Validators:`
		// * must be a valid time format* must be >= 60s
		RefreshInterval *string `json:"refreshInterval,omitempty"`

		// TlsConfig Configures the scrape request's TLS settings.
		TlsConfig *struct {
			// InsecureSkipVerify Disable validation of the server certificate.
			InsecureSkipVerify *bool `json:"insecureSkipVerify,omitempty"`
		} `json:"tlsConfig,omitempty"`

		// Url URL from which the targets are fetched.
		URL string `json:"url"`
	} `json:"httpSdConfigs,omitempty"`

	// JobName The job name assigned to scraped metrics by default.
	// `Additional Validators:`
	// * must be unique
	// * key and values should only include the characters: a-zA-Z0-9-
	JobName string `json:"jobName"`

	// MetricsPath The HTTP resource path on which to fetch metrics from targets. E.g. /metrics
	MetricsPath *string `json:"metricsPath,omitempty"`

	// MetricsRelabelConfigs List of metric relabel configurations
	MetricsRelabelConfigs *[]struct {
		// Action Action to perform based on regex matching.
		// `Additional Validators:`
		// * if action is replace, targetLabel needs to be in body
		Action *PartialUpdateJSONBodyMetricsRelabelConfigsAction `json:"action,omitempty"`

		// Modulus Modulus to take of the hash of the source label values.
		Modulus *float32 `json:"modulus,omitempty"`

		// Regex Regular expression against which the extracted value is matched.
		Regex *string `json:"regex,omitempty"`

		// Replacement Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available.
		Replacement *string `json:"replacement,omitempty"`

		// Separator Separator placed between concatenated source label values.
		Separator *string `json:"separator,omitempty"`

		// SourceLabels The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.
		SourceLabels *[]string `json:"sourceLabels,omitempty"`

		// TargetLabel Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.
		TargetLabel *string `json:"targetLabel,omitempty"`
	} `json:"metricsRelabelConfigs,omitempty"`

	// Oauth2 OAuth 2.0 authentication using the client credentials grant type. Prometheus fetches an access token from the specified endpoint with the given client access and secret keys.
	// `Additional Validators:`
	// * if oauth2 is in the body no other authentication method should be in the body
	Oauth2 *struct {
		// ClientId clientId
		ClientID string `json:"clientId"`

		// ClientSecret clientSecret
		ClientSecret string `json:"clientSecret"`

		// Scopes The URL to fetch the token from.
		Scopes *[]string `json:"scopes,omitempty"`

		// TlsConfig Configures the scrape request's TLS settings.
		TlsConfig *struct {
			// InsecureSkipVerify Disable validation of the server certificate.
			InsecureSkipVerify *bool `json:"insecureSkipVerify,omitempty"`
		} `json:"tlsConfig,omitempty"`

		// TokenUrl The URL to fetch the token from.
		TokenURL string `json:"tokenUrl"`
	} `json:"oauth2,omitempty"`

	// Params Optional http params
	// `Additional Validators:`
	// * should not contain more than 5 keys
	// * each key and value should not have more than 200 characters
	Params *map[string]interface{} `json:"params,omitempty"`

	// SampleLimit Per-scrape limit on number of scraped samples that will be accepted. If more than this number of samples are present after metric relabeling the entire scrape will be treated as failed. The total limit depends on the service plan target limits * samples
	SampleLimit *float32 `json:"sampleLimit,omitempty"`

	// Scheme Configures the protocol scheme used for requests. https or http
	Scheme PartialUpdateJSONBodyScheme `json:"scheme"`

	// ScrapeInterval How frequently to scrape targets from this job. E.g. 5m
	// `Additional Validators:`
	// * must be a valid time format* must be >= 60s
	ScrapeInterval string `json:"scrapeInterval"`

	// ScrapeTimeout Per-scrape timeout when scraping this job.
	// `Additional Validators:`
	// * must be a valid time format* must be smaller than scrapeInterval
	ScrapeTimeout string `json:"scrapeTimeout"`

	// StaticConfigs A list of scrape configurations.
	StaticConfigs []struct {
		// Labels Labels assigned to all metrics scraped from the targets.
		// `Additional Validators:`
		// * should not contain more than 10 keys
		// * each key and value should not be longer than 200 characters
		Labels *map[string]interface{} `json:"labels,omitempty"`

		// Targets The targets specified by the static config.
		Targets []string `json:"targets"`
	} `json:"staticConfigs"`

	// TlsConfig Configures the scrape request's TLS settings.
	TlsConfig *struct {
		// InsecureSkipVerify Disable validation of the server certificate.
		InsecureSkipVerify *bool `json:"insecureSkipVerify,omitempty"`
	} `json:"tlsConfig,omitempty"`
}

// PartialUpdateJSONBodyMetricsRelabelConfigsAction defines parameters for PartialUpdate.
type PartialUpdateJSONBodyMetricsRelabelConfigsAction string

// PartialUpdateJSONBodyScheme defines parameters for PartialUpdate.
type PartialUpdateJSONBodyScheme string

// CreateJSONBody defines parameters for Create.
type CreateJSONBody struct {
	// BasicAuth Sets the 'Authorization' header on every scrape request with the configured username and password.
	// `Additional Validators:`
	// * if basicAuth is in the body no other authentication method should be in the body
	BasicAuth *struct {
		// Password password
		Password *string `json:"password,omitempty"`

		// Username username
		Username *string `json:"username,omitempty"`
	} `json:"basicAuth,omitempty"`

	// BearerToken Sets the 'Authorization' header on every scrape request with the configured bearer token. It is mutually exclusive with 'bearer_token_file'.
	// `Additional Validators:`
	// * needs to be a valid bearer token
	// * if bearerToken is in the body no other authentication method should be in the body
	BearerToken *string `json:"bearerToken,omitempty"`

	// HonorLabels Note that any globally configured 'external_labels' are unaffected by this setting. In communication with external systems, they are always applied only when a time series does not have a given label yet and are ignored otherwise.
	HonorLabels *bool `json:"honorLabels,omitempty"`

	// HonorTimeStamps honor_timestamps controls whether Prometheus respects the timestamps present in scraped data. If honor_timestamps is set to 'true', the timestamps of the metrics exposed by the target will be used.
	HonorTimeStamps *bool `json:"honorTimeStamps,omitempty"`

	// HttpSdConfigs HTTP-based service discovery provides a more generic way to configure static targets and serves as an interface to plug in custom service discovery mechanisms.
	HttpSdConfigs *[]struct {
		// BasicAuth Sets the 'Authorization' header on every scrape request with the configured username and password.
		// `Additional Validators:`
		// * if basicAuth is in the body no other authentication method should be in the body
		BasicAuth *struct {
			// Password password
			Password *string `json:"password,omitempty"`

			// Username username
			Username *string `json:"username,omitempty"`
		} `json:"basicAuth,omitempty"`

		// Oauth2 OAuth 2.0 authentication using the client credentials grant type. Prometheus fetches an access token from the specified endpoint with the given client access and secret keys.
		// `Additional Validators:`
		// * if oauth2 is in the body no other authentication method should be in the body
		Oauth2 *struct {
			// ClientId clientId
			ClientID string `json:"clientId"`

			// ClientSecret clientSecret
			ClientSecret string `json:"clientSecret"`

			// Scopes The URL to fetch the token from.
			Scopes *[]string `json:"scopes,omitempty"`

			// TlsConfig Configures the scrape request's TLS settings.
			TlsConfig *struct {
				// InsecureSkipVerify Disable validation of the server certificate.
				InsecureSkipVerify *bool `json:"insecureSkipVerify,omitempty"`
			} `json:"tlsConfig,omitempty"`

			// TokenUrl The URL to fetch the token from.
			TokenURL string `json:"tokenUrl"`
		} `json:"oauth2,omitempty"`

		// RefreshInterval Refresh interval to re-query the endpoint. E.g. 60s
		// `Additional Validators:`
		// * must be a valid time format* must be >= 60s
		RefreshInterval *string `json:"refreshInterval,omitempty"`

		// TlsConfig Configures the scrape request's TLS settings.
		TlsConfig *struct {
			// InsecureSkipVerify Disable validation of the server certificate.
			InsecureSkipVerify *bool `json:"insecureSkipVerify,omitempty"`
		} `json:"tlsConfig,omitempty"`

		// Url URL from which the targets are fetched.
		URL string `json:"url"`
	} `json:"httpSdConfigs,omitempty"`

	// JobName The job name assigned to scraped metrics by default.
	// `Additional Validators:`
	// * must be unique
	// * key and values should only include the characters: a-zA-Z0-9-
	JobName string `json:"jobName"`

	// MetricsPath The HTTP resource path on which to fetch metrics from targets. E.g. /metrics
	MetricsPath *string `json:"metricsPath,omitempty"`

	// MetricsRelabelConfigs List of metric relabel configurations
	MetricsRelabelConfigs *[]struct {
		// Action Action to perform based on regex matching.
		// `Additional Validators:`
		// * if action is replace, targetLabel needs to be in body
		Action *CreateJSONBodyMetricsRelabelConfigsAction `json:"action,omitempty"`

		// Modulus Modulus to take of the hash of the source label values.
		Modulus *float32 `json:"modulus,omitempty"`

		// Regex Regular expression against which the extracted value is matched.
		Regex *string `json:"regex,omitempty"`

		// Replacement Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available.
		Replacement *string `json:"replacement,omitempty"`

		// Separator Separator placed between concatenated source label values.
		Separator *string `json:"separator,omitempty"`

		// SourceLabels The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.
		SourceLabels *[]string `json:"sourceLabels,omitempty"`

		// TargetLabel Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.
		TargetLabel *string `json:"targetLabel,omitempty"`
	} `json:"metricsRelabelConfigs,omitempty"`

	// Oauth2 OAuth 2.0 authentication using the client credentials grant type. Prometheus fetches an access token from the specified endpoint with the given client access and secret keys.
	// `Additional Validators:`
	// * if oauth2 is in the body no other authentication method should be in the body
	Oauth2 *struct {
		// ClientId clientId
		ClientID string `json:"clientId"`

		// ClientSecret clientSecret
		ClientSecret string `json:"clientSecret"`

		// Scopes The URL to fetch the token from.
		Scopes *[]string `json:"scopes,omitempty"`

		// TlsConfig Configures the scrape request's TLS settings.
		TlsConfig *struct {
			// InsecureSkipVerify Disable validation of the server certificate.
			InsecureSkipVerify *bool `json:"insecureSkipVerify,omitempty"`
		} `json:"tlsConfig,omitempty"`

		// TokenUrl The URL to fetch the token from.
		TokenURL string `json:"tokenUrl"`
	} `json:"oauth2,omitempty"`

	// Params Optional http params
	// `Additional Validators:`
	// * should not contain more than 5 keys
	// * each key and value should not have more than 200 characters
	Params *map[string]interface{} `json:"params,omitempty"`

	// SampleLimit Per-scrape limit on number of scraped samples that will be accepted. If more than this number of samples are present after metric relabeling the entire scrape will be treated as failed. The total limit depends on the service plan target limits * samples
	SampleLimit *float32 `json:"sampleLimit,omitempty"`

	// Scheme Configures the protocol scheme used for requests. https or http
	Scheme CreateJSONBodyScheme `json:"scheme"`

	// ScrapeInterval How frequently to scrape targets from this job. E.g. 5m
	// `Additional Validators:`
	// * must be a valid time format* must be >= 60s
	ScrapeInterval string `json:"scrapeInterval"`

	// ScrapeTimeout Per-scrape timeout when scraping this job.
	// `Additional Validators:`
	// * must be a valid time format* must be smaller than scrapeInterval
	ScrapeTimeout string `json:"scrapeTimeout"`

	// StaticConfigs A list of scrape configurations.
	StaticConfigs []struct {
		// Labels Labels assigned to all metrics scraped from the targets.
		// `Additional Validators:`
		// * should not contain more than 10 keys
		// * each key and value should not be longer than 200 characters
		Labels *map[string]interface{} `json:"labels,omitempty"`

		// Targets The targets specified by the static config.
		Targets []string `json:"targets"`
	} `json:"staticConfigs"`

	// TlsConfig Configures the scrape request's TLS settings.
	TlsConfig *struct {
		// InsecureSkipVerify Disable validation of the server certificate.
		InsecureSkipVerify *bool `json:"insecureSkipVerify,omitempty"`
	} `json:"tlsConfig,omitempty"`
}

// CreateJSONBodyMetricsRelabelConfigsAction defines parameters for Create.
type CreateJSONBodyMetricsRelabelConfigsAction string

// CreateJSONBodyScheme defines parameters for Create.
type CreateJSONBodyScheme string

// UpdateJSONBody defines parameters for Update.
type UpdateJSONBody struct {
	// BasicAuth Sets the 'Authorization' header on every scrape request with the configured username and password.
	// `Additional Validators:`
	// * if basicAuth is in the body no other authentication method should be in the body
	BasicAuth *struct {
		// Password password
		Password *string `json:"password,omitempty"`

		// Username username
		Username *string `json:"username,omitempty"`
	} `json:"basicAuth,omitempty"`

	// BearerToken Sets the 'Authorization' header on every scrape request with the configured bearer token. It is mutually exclusive with 'bearer_token_file'.
	// `Additional Validators:`
	// * needs to be a valid bearer token
	// * if bearerToken is in the body no other authentication method should be in the body
	BearerToken *string `json:"bearerToken,omitempty"`

	// HonorLabels Note that any globally configured 'external_labels' are unaffected by this setting. In communication with external systems, they are always applied only when a time series does not have a given label yet and are ignored otherwise.
	HonorLabels *bool `json:"honorLabels,omitempty"`

	// HonorTimeStamps honor_timestamps controls whether Prometheus respects the timestamps present in scraped data. If honor_timestamps is set to 'true', the timestamps of the metrics exposed by the target will be used.
	HonorTimeStamps *bool `json:"honorTimeStamps,omitempty"`

	// MetricsPath The HTTP resource path on which to fetch metrics from targets. E.g. /metrics
	MetricsPath string `json:"metricsPath"`

	// MetricsRelabelConfigs List of metric relabel configurations
	MetricsRelabelConfigs *[]struct {
		// Action Action to perform based on regex matching.
		// `Additional Validators:`
		// * if action is replace, targetLabel needs to be in body
		Action *UpdateJSONBodyMetricsRelabelConfigsAction `json:"action,omitempty"`

		// Modulus Modulus to take of the hash of the source label values.
		Modulus *float32 `json:"modulus,omitempty"`

		// Regex Regular expression against which the extracted value is matched.
		Regex *string `json:"regex,omitempty"`

		// Replacement Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available.
		Replacement *string `json:"replacement,omitempty"`

		// Separator Separator placed between concatenated source label values.
		Separator *string `json:"separator,omitempty"`

		// SourceLabels The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.
		SourceLabels *[]string `json:"sourceLabels,omitempty"`

		// TargetLabel Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.
		TargetLabel *string `json:"targetLabel,omitempty"`
	} `json:"metricsRelabelConfigs,omitempty"`

	// Params Optional http params
	// `Additional Validators:`
	// * should not contain more than 5 keys
	// * each key and value should not have more than 200 characters
	Params *map[string]interface{} `json:"params,omitempty"`

	// Scheme Configures the protocol scheme used for requests. https or http
	Scheme UpdateJSONBodyScheme `json:"scheme"`

	// ScrapeInterval How frequently to scrape targets from this job. E.g. 5m
	// `Additional Validators:`
	// * must be a valid time format* must be >= 60s
	ScrapeInterval string `json:"scrapeInterval"`

	// ScrapeTimeout Per-scrape timeout when scraping this job.
	// `Additional Validators:`
	// * must be a valid time format* must be smaller than scrapeInterval
	ScrapeTimeout string `json:"scrapeTimeout"`

	// StaticConfigs A list of scrape configurations.
	StaticConfigs []struct {
		// Labels Labels assigned to all metrics scraped from the targets.
		// `Additional Validators:`
		// * should not contain more than 5 keys
		// * each key and value should not be longer than 200 characters
		Labels *map[string]interface{} `json:"labels,omitempty"`

		// Targets The targets specified by the static config.
		Targets []string `json:"targets"`
	} `json:"staticConfigs"`

	// TlsConfig Configures the scrape request's TLS settings.
	TlsConfig *struct {
		// InsecureSkipVerify Disable validation of the server certificate.
		InsecureSkipVerify *bool `json:"insecureSkipVerify,omitempty"`
	} `json:"tlsConfig,omitempty"`
}

// UpdateJSONBodyMetricsRelabelConfigsAction defines parameters for Update.
type UpdateJSONBodyMetricsRelabelConfigsAction string

// UpdateJSONBodyScheme defines parameters for Update.
type UpdateJSONBodyScheme string

// PartialUpdateJSONRequestBody defines body for PartialUpdate for application/json ContentType.
type PartialUpdateJSONRequestBody = PartialUpdateJSONBody

// CreateJSONRequestBody defines body for Create for application/json ContentType.
type CreateJSONRequestBody CreateJSONBody

// UpdateJSONRequestBody defines body for Update for application/json ContentType.
type UpdateJSONRequestBody UpdateJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client contracts.BaseClientInterface
}

// NewRawClient Creates a new Client, with reasonable defaults
func NewRawClient(server string, httpClient contracts.BaseClientInterface) *Client {
	// create a client with sane default values
	client := Client{
		Server: server,
		Client: httpClient,
	}
	return &client
}

// The interface specification for the client above.
type rawClientInterface interface {
	// Delete request
	DeleteRaw(ctx context.Context, projectID string, instanceID string, params *DeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// List request
	ListRaw(ctx context.Context, projectID string, instanceID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PartialUpdate request with any body
	PartialUpdateRawWithBody(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PartialUpdateRaw(ctx context.Context, projectID string, instanceID string, body PartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Create request with any body
	CreateRawWithBody(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRaw(ctx context.Context, projectID string, instanceID string, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteConfigs request
	DeleteConfigsRaw(ctx context.Context, projectID string, instanceID string, jobName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Get request
	GetRaw(ctx context.Context, projectID string, instanceID string, jobName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Update request with any body
	UpdateRawWithBody(ctx context.Context, projectID string, instanceID string, jobName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRaw(ctx context.Context, projectID string, instanceID string, jobName string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DeleteRaw(ctx context.Context, projectID string, instanceID string, params *DeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRequest(ctx, c.Server, projectID, instanceID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRaw(ctx context.Context, projectID string, instanceID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRequest(ctx, c.Server, projectID, instanceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartialUpdateRawWithBody(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartialUpdateRequestWithBody(ctx, c.Server, projectID, instanceID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PartialUpdateRaw(ctx context.Context, projectID string, instanceID string, body PartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPartialUpdateRequest(ctx, c.Server, projectID, instanceID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRawWithBody(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequestWithBody(ctx, c.Server, projectID, instanceID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRaw(ctx context.Context, projectID string, instanceID string, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequest(ctx, c.Server, projectID, instanceID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteConfigsRaw(ctx context.Context, projectID string, instanceID string, jobName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConfigsRequest(ctx, c.Server, projectID, instanceID, jobName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRaw(ctx context.Context, projectID string, instanceID string, jobName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequest(ctx, c.Server, projectID, instanceID, jobName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRawWithBody(ctx context.Context, projectID string, instanceID string, jobName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequestWithBody(ctx, c.Server, projectID, instanceID, jobName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRaw(ctx context.Context, projectID string, instanceID string, jobName string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequest(ctx, c.Server, projectID, instanceID, jobName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDeleteRequest generates requests for Delete
func NewDeleteRequest(ctx context.Context, server string, projectID string, instanceID string, params *DeleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/scrapeconfigs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", false, "jobName", runtime.ParamLocationQuery, params.JobName); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRequest generates requests for List
func NewListRequest(ctx context.Context, server string, projectID string, instanceID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/scrapeconfigs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPartialUpdateRequest calls the generic PartialUpdate builder with application/json body
func NewPartialUpdateRequest(ctx context.Context, server string, projectID string, instanceID string, body PartialUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPartialUpdateRequestWithBody(ctx, server, projectID, instanceID, "application/json", bodyReader)
}

// NewPartialUpdateRequestWithBody generates requests for PartialUpdate with any type of body
func NewPartialUpdateRequestWithBody(ctx context.Context, server string, projectID string, instanceID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/scrapeconfigs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateRequest calls the generic Create builder with application/json body
func NewCreateRequest(ctx context.Context, server string, projectID string, instanceID string, body CreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRequestWithBody(ctx, server, projectID, instanceID, "application/json", bodyReader)
}

// NewCreateRequestWithBody generates requests for Create with any type of body
func NewCreateRequestWithBody(ctx context.Context, server string, projectID string, instanceID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/scrapeconfigs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteConfigsRequest generates requests for DeleteConfigs
func NewDeleteConfigsRequest(ctx context.Context, server string, projectID string, instanceID string, jobName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobName", runtime.ParamLocationPath, jobName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/scrapeconfigs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRequest generates requests for Get
func NewGetRequest(ctx context.Context, server string, projectID string, instanceID string, jobName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobName", runtime.ParamLocationPath, jobName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/scrapeconfigs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRequest calls the generic Update builder with application/json body
func NewUpdateRequest(ctx context.Context, server string, projectID string, instanceID string, jobName string, body UpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRequestWithBody(ctx, server, projectID, instanceID, jobName, "application/json", bodyReader)
}

// NewUpdateRequestWithBody generates requests for Update with any type of body
func NewUpdateRequestWithBody(ctx context.Context, server string, projectID string, instanceID string, jobName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "jobName", runtime.ParamLocationPath, jobName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/instances/%s/scrapeconfigs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on rawClientInterface to offer response payloads
type ClientWithResponses struct {
	rawClientInterface
}

// NewClient creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClient(server string, httpClient contracts.BaseClientInterface) *ClientWithResponses {
	return &ClientWithResponses{NewRawClient(server, httpClient)}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// Delete request
	Delete(ctx context.Context, projectID string, instanceID string, params *DeleteParams, reqEditors ...RequestEditorFn) (*DeleteResponse, error)

	// List request
	List(ctx context.Context, projectID string, instanceID string, reqEditors ...RequestEditorFn) (*ListResponse, error)

	// PartialUpdate request with any body
	PartialUpdateWithBody(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartialUpdateResponse, error)

	PartialUpdate(ctx context.Context, projectID string, instanceID string, body PartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PartialUpdateResponse, error)

	// Create request with any body
	CreateWithBody(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResponse, error)

	Create(ctx context.Context, projectID string, instanceID string, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResponse, error)

	// DeleteConfigs request
	DeleteConfigs(ctx context.Context, projectID string, instanceID string, jobName string, reqEditors ...RequestEditorFn) (*DeleteConfigsResponse, error)

	// Get request
	Get(ctx context.Context, projectID string, instanceID string, jobName string, reqEditors ...RequestEditorFn) (*GetResponse, error)

	// Update request with any body
	UpdateWithBody(ctx context.Context, projectID string, instanceID string, jobName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResponse, error)

	Update(ctx context.Context, projectID string, instanceID string, jobName string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResponse, error)
}

type DeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateJob
	JSON403      *PermissionDenied
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r DeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAllJob
	JSON403      *PermissionDenied
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r ListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PartialUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateJob
	JSON400      *Error
	JSON403      *PermissionDenied
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r PartialUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PartialUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateJob
	JSON400      *Error
	JSON403      *PermissionDenied
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r CreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteConfigsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *DeleteJob
	JSON403      *PermissionDenied
	JSON404      *Message
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r DeleteConfigsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConfigsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetJob
	JSON403      *PermissionDenied
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r GetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateJob
	JSON400      *Message
	JSON403      *PermissionDenied
	JSON404      *Message
	Error        error // Aggregated error
}

// Status returns HTTPResponse.Status
func (r UpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// Delete request returning *DeleteResponse
func (c *ClientWithResponses) Delete(ctx context.Context, projectID string, instanceID string, params *DeleteParams, reqEditors ...RequestEditorFn) (*DeleteResponse, error) {
	rsp, err := c.DeleteRaw(ctx, projectID, instanceID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseDeleteResponse(rsp)
}

// List request returning *ListResponse
func (c *ClientWithResponses) List(ctx context.Context, projectID string, instanceID string, reqEditors ...RequestEditorFn) (*ListResponse, error) {
	rsp, err := c.ListRaw(ctx, projectID, instanceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseListResponse(rsp)
}

// PartialUpdateWithBody request with arbitrary body returning *PartialUpdateResponse
func (c *ClientWithResponses) PartialUpdateWithBody(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PartialUpdateResponse, error) {
	rsp, err := c.PartialUpdateRawWithBody(ctx, projectID, instanceID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParsePartialUpdateResponse(rsp)
}

func (c *ClientWithResponses) PartialUpdate(ctx context.Context, projectID string, instanceID string, body PartialUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PartialUpdateResponse, error) {
	rsp, err := c.PartialUpdateRaw(ctx, projectID, instanceID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParsePartialUpdateResponse(rsp)
}

// CreateWithBody request with arbitrary body returning *CreateResponse
func (c *ClientWithResponses) CreateWithBody(ctx context.Context, projectID string, instanceID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResponse, error) {
	rsp, err := c.CreateRawWithBody(ctx, projectID, instanceID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateResponse(rsp)
}

func (c *ClientWithResponses) Create(ctx context.Context, projectID string, instanceID string, body CreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResponse, error) {
	rsp, err := c.CreateRaw(ctx, projectID, instanceID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseCreateResponse(rsp)
}

// DeleteConfigs request returning *DeleteConfigsResponse
func (c *ClientWithResponses) DeleteConfigs(ctx context.Context, projectID string, instanceID string, jobName string, reqEditors ...RequestEditorFn) (*DeleteConfigsResponse, error) {
	rsp, err := c.DeleteConfigsRaw(ctx, projectID, instanceID, jobName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseDeleteConfigsResponse(rsp)
}

// Get request returning *GetResponse
func (c *ClientWithResponses) Get(ctx context.Context, projectID string, instanceID string, jobName string, reqEditors ...RequestEditorFn) (*GetResponse, error) {
	rsp, err := c.GetRaw(ctx, projectID, instanceID, jobName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseGetResponse(rsp)
}

// UpdateWithBody request with arbitrary body returning *UpdateResponse
func (c *ClientWithResponses) UpdateWithBody(ctx context.Context, projectID string, instanceID string, jobName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResponse, error) {
	rsp, err := c.UpdateRawWithBody(ctx, projectID, instanceID, jobName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseUpdateResponse(rsp)
}

func (c *ClientWithResponses) Update(ctx context.Context, projectID string, instanceID string, jobName string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResponse, error) {
	rsp, err := c.UpdateRaw(ctx, projectID, instanceID, jobName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return c.ParseUpdateResponse(rsp)
}

// ParseDeleteResponse parses an HTTP response from a Delete call
func (c *ClientWithResponses) ParseDeleteResponse(rsp *http.Response) (*DeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseListResponse parses an HTTP response from a List call
func (c *ClientWithResponses) ParseListResponse(rsp *http.Response) (*ListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAllJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParsePartialUpdateResponse parses an HTTP response from a PartialUpdate call
func (c *ClientWithResponses) ParsePartialUpdateResponse(rsp *http.Response) (*PartialUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PartialUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseCreateResponse parses an HTTP response from a Create call
func (c *ClientWithResponses) ParseCreateResponse(rsp *http.Response) (*CreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseDeleteConfigsResponse parses an HTTP response from a DeleteConfigs call
func (c *ClientWithResponses) ParseDeleteConfigsResponse(rsp *http.Response) (*DeleteConfigsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteConfigsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest DeleteJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON404 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseGetResponse parses an HTTP response from a Get call
func (c *ClientWithResponses) ParseGetResponse(rsp *http.Response) (*GetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	}

	return response, validate.ResponseObject(response)
}

// ParseUpdateResponse parses an HTTP response from a Update call
func (c *ClientWithResponses) ParseUpdateResponse(rsp *http.Response) (*UpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}
	response.Error = validate.DefaultResponseErrorHandler(rsp)

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDenied
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("body was: %s", string(bodyBytes)))
		}
		response.JSON404 = &dest

	}

	return response, validate.ResponseObject(response)
}
